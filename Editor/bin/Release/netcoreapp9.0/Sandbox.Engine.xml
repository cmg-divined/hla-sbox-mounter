<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sandbox.Engine</name>
    </assembly>
    <members>
        <member name="P:Sandbox.Application.IsInitialized">
            <summary>
            Prevent double initialization
            </summary>
        </member>
        <member name="P:Sandbox.Application.AppId">
            <summary>
            Steam AppId of S&amp;box.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsUnitTest">
            <summary>
            True if we're running the engine as part of a unit test
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsLiveUnitTest">
            <summary>
            True if we're running a live unit test.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsHeadless">
            <summary>
            True if running as a background task, or terminal, like a dedicated server.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsConsoleApp">
            <summary>
            True if running in a terminal like console, instead of a game window or editor.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsDedicatedServer">
            <summary>
            True if this is a dedicated server
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsBenchmark">
            <summary>
            True if running a benchmark
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsEditor">
            <summary>
            True if running with the tools or editor attached
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsJoinLocal">
            <summary>
            True if running with -joinlocal. This is an instance that launches and joins
            an in process editor session.
            </summary>
        </member>
        <member name="P:Sandbox.Application.Version">
            <summary>
            The engine's version string
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsRetail">
            <summary>
            True if this is compiled and published on steam
            </summary>
        </member>
        <member name="P:Sandbox.Application.VersionDate">
            <summary>
            The date of this version, as a UTC datetime.
            </summary>
        </member>
        <member name="P:Sandbox.Application.ExceptionCount">
            <summary>
            Number of exceptions we've had. Resets on game exit.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsStandalone">
            <summary>
            True if the game is running in standalone mode
            </summary>
        </member>
        <member name="P:Sandbox.Application.LanguageCode">
            <summary>
            The language code for the current language
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsVR">
            <summary>
            True if the game is running in VR mode
            </summary>
        </member>
        <member name="M:Sandbox.Application.InitUnitTest``1(System.Boolean,System.Boolean)">
            <summary>
            Called from unit test projects to initialize the engine
            </summary>
        </member>
        <member name="M:Sandbox.Application.ShutdownUnitTest">
            <summary>
            Called from unit test projects to politely shut down the engine
            </summary>
        </member>
        <member name="P:Sandbox.Application.GamePackage">
            <summary>
            The currently loaded game package. May be null if no game loaded. 
            Controlled by GameMenuDll.
            </summary>
        </member>
        <member name="P:Sandbox.Application.MapPackage">
            <summary>
            The currently loaded map package
            </summary>
        </member>
        <member name="P:Sandbox.Application.GameIdent">
            <summary>
            The currently loaded game package's ident - if applicable.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsMicrophoneListening">
            <summary>
            Returns true if the microphone is currently listening
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsMicrophoneRecording">
            <summary>
            Returns true if the microphone is currently listening and actually hearing/capturing sounds
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsFocused">
            <summary>
            Is the game window in focus?
            </summary>
        </member>
        <member name="M:Sandbox.Application.Exit">
            <summary>
            Exits the application if we're running in standalone mode or we are a Dedicated Server.
            </summary>
        </member>
        <member name="P:Sandbox.Application.RenderSettings">
            <summary>
            Allows access to the RenderSettings singleton, which contains settings related to rendering in the game.
            You're only able to access this when in standalone mode. When accessing in the editor, or in sbox it will return null.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Bootstrap.VersionSha">
            <summary>
            The github SHA of the current build
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.PreInit(CMaterialSystem2AppSystemDict)">
            <summary>
            Called before anything else. This should set up any low level stuff that
            might be relied on if static functions are called.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.EnvironmentExit(System.Int32)">
            <summary>
            Let's native exit the C# app so AppDomain.ProcessExit gets called
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.TaskScheduler_UnobservedTaskException(System.Object,System.Threading.Tasks.UnobservedTaskExceptionEventArgs)">
            <summary>
            Called on exceptions from a task (delayed, because it'll only get called when the exception gets collected)
            TODO: Move this somewhere else
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.Init">
            <summary>
            Called to initialize the engine.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.LoadingFinished">
            <summary>
            Should be called when startup has finished.
            If we have a client, this is when the menu is first entered.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IGameInstanceDll.Disconnect">
            <summary>
            Called when the "disconnect" command is ran.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IGameInstanceDll.CloseGame">
            <summary>
            Closes the current GameInstance immediately
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IGameInstanceDll.TryGetReplicatedVarValue(System.String,System.String@)">
            <summary>
            Get the replicated var value from the host
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IGameInstanceDll.LoadPackageAssembliesAsync(Sandbox.Package)">
            <summary>
            Load the assemblies from this package into the current game instance
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GameLoadingFlags.Remote">
            <summary>
            Set if we're loading a game as a result of joining a server
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GameLoadingFlags.Host">
            <summary>
            Set if we're the hosting as the result of starting our own server
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GameLoadingFlags.Reload">
            <summary>
            Set if we want to reload the game, even if it's already loaded
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GameLoadingFlags.Developer">
            <summary>
            Set if this is a developer session. It started from an editor session and as such we shouldn't load
            assemblies from the package, they should be loaded from the Network Tables instead.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.Name">
            <summary>
            The name of this context, for debugging purposes
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.MouseCursor">
            <summary>
            What mouse cursor does this context want to show?
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.MouseState">
            <summary>
            What kind of mouse interaction is this context interested in right now
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.MouseCapture">
            <summary>
            Mouse is UI mode but wants to use the mouse capture/delta mode
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.KeyboardState">
            <summary>
            What kind of keyboard interaction is this context interested in right now
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.OnMouseMotion">
            <summary>
            Mouse moved in game mode
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.OnGameButton">
            <summary>
            A button event to be sent to the game
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.TargetUISystem">
            <summary>
            Which system should we be sending our input to?
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.TrappingKeys">
            <summary>
            When true we've called StartTrapping and are waiting for the user to release keys
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputContext.StartTrapping(System.Action{System.String[]})">
            <summary>
            Start trapping keys. When the user releases all keys the callback will be called
            with a list of buttons that were pressed during the trap.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputContext.EndTrapping">
            <summary>
            Called when a key is released if we're trapping keys.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputContext.In_Escape">
            <summary>
            Special handling for the escape button. Return false if we didn't use it.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputContext.IN_ButtonReleased(NativeEngine.ButtonCode,Sandbox.KeyboardModifiers)">
            <summary>
            This is called even if the context doesn't have focus.
            It's just a place to unpress buttons, if they're down.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputContext.IsReservedButton(NativeEngine.ButtonCode)">
            <summary>
            Is this a reserved button? This means developers can not detect these keys as up or down.
            </summary>
            <param name="button"></param>
            <returns></returns>
        </member>
        <member name="F:Sandbox.Engine.InputContext.InputState.Ignore">
            <summary>
            Doesn't want it, pass down to next context
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputContext.InputState.UI">
            <summary>
            Interacting with UI
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputContext.InputState.Game">
            <summary>
            Interacting with the game
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IToolsDll.RegisterHandle(System.IntPtr,System.UInt32)">
            <summary>
            Registers exclusive Sandbox.Tools <see cref="T:Sandbox.IHandle"/> types
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IToolsDll.LoadProject">
            <summary>
            Load the startup project for the first time
            </summary>
        </member>
        <member name="P:Sandbox.Engine.IToolsDll.IsGameViewVisible">
            <summary>
            Is the game view visible, or is it in a tab in the background?
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IToolsDll.OnInitializeHost">
            <summary>
            Called after the host network system is initialised, used to add additional package references etc. to dev servers 
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.LocalAssembly">
            <summary>
            Sandbox.GameInstance or Sandbox.Menu
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.InputContext">
            <summary>
            The input context for this game instance, which contains the current input state and bindings.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.ActiveScene">
            <summary>
            The active scene for this game instance.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.ResourceSystem">
            <summary>
            For the resource library
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.TypeLibrary">
            <summary>
            Holds a list of available classes and types in the game, used for serialization and reflection.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.NodeLibrary">
            <summary>
            For actiongraph
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.FileMount">
            <summary>
            All of the mounted assets
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.FileData">
            <summary>
            A persistent data folder for the current package.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.FileOrg">
            <summary>
            Allows a common place for an org's data
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.JsonSerializerOptions">
            <summary>
            Special options for serializing json
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.TaskSource">
            <summary>
            For running tasks in a kind of sandboxed way
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.CancellationTokenSource">
            <summary>
            Creates tokens that will be cancelled at the end of the game
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.EventSystem">
            <summary>
            The event system isn't used that much anymore, we should move away from it.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.UISystem">
            <summary>
            The UI system for the game, which manages the user interface elements and their interactions.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.Cookies">
            <summary>
            Holds cookies for the game, which can be used for storing session data or other small pieces of information that need to persist across requests.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.GlobalContext.Language">
            <summary>
            Holds language data for the game.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.GlobalContext.#ctor">
            <summary>
            The global context for the game, which holds references to various systems and libraries used throughout the game.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.GlobalContext.Reset">
            <summary>
            Should be called before using. This will re-initialize the task source stuff, ready to use.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.GlobalContext.DisableTypelibraryScope(System.String)">
            <summary>
            We sometimes want to disable access to certain things, like when we're running static initializers.
            This prevents users from relying on behaviours that are not stable.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.GlobalContext.GameScope">
            <summary>
            Should rarely have to get called, game scope is implicit. Will need to be called if we're 
            in the menu scope, and have to call something in the game scope.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.GlobalContext.MenuScope">
            <summary>
            Should only be called at a really high level, when doing menu stuff
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GlobalContext.Current">
            <summary>
            The current active context
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GlobalContext.Menu">
            <summary>
            The context used for the menu system
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GlobalContext.Game">
            <summary>
            The context used for the game. This is the default context.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.GlobalContext.#cctor">
            <summary>
            The global context for the game, which holds references to various systems and libraries used throughout the game.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.GlobalContext.AssertMenu(System.String)">
            <summary>
            Throws an exception when called from client or server.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.Username">
            <summary>
            Your own username
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.UserId">
            <summary>
            Your own user id
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.ServiceType">
            <summary>
            The service type (ie "Twitch")
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.IsActive">
            <summary>
            Are we connected to a service
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Protocol">
            <summary>
            A centralized place to access the protocols
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Protocol.Api">
            <summary>
            We cannot play packages with an Api version higher than this.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Protocol.Network">
            <summary>
            We cannot talk to servers or clients with a network protocol different to this.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.MaterialAccessor">
             <summary>
             A wrapper to allow the unification of editing materials. This is usually a member on a Component which implements MaterialAccessor.ITarget.
             </summary>
             <example>
             <code>
             MaterialAccessor materialAccessor;
            
            	[Property]
            	public MaterialAccessor Materials => materialAccessor ??= new MaterialAccessor( this );
             </code>
             </example>
        </member>
        <member name="T:Sandbox.Engine.MaterialAccessor.ITarget">
            <summary>
            The target of a MaterialAccessor. This is the object that will be modified when setting or clearing material overrides.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.MaterialAccessor.ITarget.IsValid">
            <summary>
            Return true if this target is valid
            </summary>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.ITarget.GetMaterialCount">
            <summary>
            The number of materials on this target
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.ITarget.Get(System.Int32)">
            <summary>
            Get the original material, before overrides, matching this index
            </summary>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.ITarget.SetOverride(System.Int32,Sandbox.Material)">
            <summary>
            Set the override material for this index.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.ITarget.ClearOverrides">
            <summary>
            Wipe all overrides
            </summary>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.#ctor(Sandbox.Engine.MaterialAccessor.ITarget)">
            <summary>
            Create a new material accessor for this object. 
            </summary>
        </member>
        <member name="P:Sandbox.Engine.MaterialAccessor.Count">
            <summary>
            Total number of material slots
            </summary>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.GetOriginal(System.Int32)">
            <summary>
            Get the original material for the specified index.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.HasOverride(System.Int32)">
            <summary>
            Does this index have an override material?
            </summary>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.GetOverride(System.Int32)">
            <summary>
            Get the override material for this slot. Or null if not set.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.SetOverride(System.Int32,Sandbox.Material)">
            <summary>
            Set an override material for this slot. If the material is null, it will clear the override.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.MaterialAccessor.Apply">
            <summary>
            Apply to the object. You don't need to call this when setting overrides, as it will automatically apply them to the target when you set them.
            This is here as a convenience if this object holds data, and you need to apply it to another object that didn't exist when the
            overrides were originally set, or loaded.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.BindCollection">
            <summary>
            
            A collection of action binds. 
            
             BindCollection
               - Action: attack1
                 - Slot0: mouse1
               - Action: selectall
                 - Slot0: ctrl + a
                 
            The bind collection can be saved and loaded from disk via the BindSaveConfig class.
            
            The bind collection can have a base collection which it will fall back to if it contains
            the same binds. This allows us to have a "common" collection which can be shared between
            all games, but can also let the games + users to override those binds if they choose.
            
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindCollection.Base">
            <summary>
            The base collection. Game binds have this set to the common binds.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindCollection.CollectionName">
            <summary>
            Will be either "common" or the ident of the current game.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindCollection.ConfigPath">
            <summary>
            The location of the config file to load from in EngineFileSystem.Config
            </summary>
        </member>
        <member name="F:Sandbox.Engine.BindCollection.Actions">
            <summary>
            The actual collection of binds.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.#ctor(System.String)">
            <summary>
            Creates a collection and tries to load it from disk.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.FillDefaultCommonInputs">
            <summary>
            If we're the common collection and have no binds (because we haven't
            been able to load a customized config from disk) then we'll fill in
            the defaults based on Input.CommonInputs.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.GetBind(System.String,System.Boolean)">
            <summary>
            Get the bind, create if it doesn't exist
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.Set(System.String,System.Int32,System.String)">
            <summary>
            Set the bind value for this action. This will overwrite what's in this slot.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.Get(System.String,System.Int32)">
            <summary>
            Get the bind value at this slot
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.SaveToDisk">
            <summary>
            Save the collection to disk
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.ResetToDefaults">
            <summary>
            Reset the collection to the default values.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.EnumerateWithButton(System.String)">
            <summary>
            Enumerate all actions that contain this button
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.UpdateActions(System.Collections.Generic.List{Sandbox.InputAction})">
            <summary>
            The action list has changed, we just got the config from the server.
            Here we'll clear the actions, add all of the defaults from the new config
            and then load the user config if it exists.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindCollection.ActionBind.IsCommon">
            <summary>
            If this is set then we want to read the value from the base collection
            </summary>
        </member>
        <member name="T:Sandbox.Engine.BindSaveConfig">
            <summary>
            A struct which is serialized/deserialized to save binds to a file (in a more readable format)
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindSaveConfig.Schema">
            <summary>
            To allow us to cater for changes in schema
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindSaveConfig.Binds">
            <summary>
            A list of strings that describe the binds
                "jump": "space;m",
            	"run": "shift",
            	"walk": "alt",
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindSaveConfig.Load(System.String,Sandbox.Engine.BindCollection)">
            <summary>
            Load a serialized collection from disk
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindSaveConfig.Save(System.String,Sandbox.Engine.BindCollection)">
            <summary>
            Save a serialized collection to disk
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputBinds.FindCollection(System.String)">
            <summary>
            Find a bind collection by name. The name is generally the ident of the current game.
            We'll try to load the binds from /config/input/*.json - if we fail then we'll serve
            the default.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Input">
            <summary>
            Temporary housing for common inputs
            Games that don't define any input actions will get a bunch of default actions given to them
            </summary>
        </member>
        <member name="T:Sandbox.Engine.InputRouter">
            <summary>
            This is where input is sent to from the engine. This is the first place input is routed to.
            From here it tries to route it to the menu, game menu and client - in that order. That should
            really be abstracted out though, so we can use this properly in Standalone.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.MouseCursorVisible">
            <summary>
            True if the cursor is visible
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.MouseCursorPosition">
            <summary>
            The mouse cursor position. Or the last position if it's now invisible.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.MouseCursorDelta">
            <summary>
            The mouse cursor delta
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.KeyboardFocusPanel">
            <summary>
            The panel we're keyboard focusing on
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputRouter.mouseCapturePosition">
            <summary>
            The position in which we entered capture/relative mode
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.EscapeIsDown">
            <summary>
            True if an "exit game" button is pressed, escape on keyboard
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.EscapeWasPressed">
            <summary>
            The escape button was pressed this frame. 
            The game is allowed to consume this. Then it will go to the menu.
            This is distinct from EscapeIsDown, because that is used to close the game when held down.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.TimeSinceEscapePressed">
            <summary>
            Time since escape was pressed
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputRouter.PressedButtons">
            <summary>
            Buttons that are currently pressed
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputRouter.PressedControllerButtons">
            <summary>
            Controller buttons that are currently pressed
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.EscapeTime">
            <summary>
            Returns the number of seconds escape has been held down
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.Contexts">
            <summary>
            Return the input contexts of each context, in order of priority
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.SetCursorPosition(Sandbox.Engine.InputContext,Vector2)">
            <summary>
            An input context wants to set the cursor position
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.IsButtonDown(NativeEngine.ButtonCode)">
            <summary>
            Return true if button is pressed
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.SetButtonState(NativeEngine.ButtonCode,System.Boolean)">
            <summary>
            Return true if button is pressed
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.IsButtonDown(Sandbox.GamepadCode)">
            <summary>
            Return true if button is pressed
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.SetButtonState(Sandbox.GamepadCode,System.Boolean)">
            <summary>
            Return true if button is pressed
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.OnConsoleCommand(System.String)">
            <summary>
            A console command from the engine.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.OnMouseMotion(System.Int32,System.Int32)">
            <summary>
            Cursor is hidden and restricted to window (game mode) but the mouse has been moved
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.OnMousePositionChange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Cursor is visible and mouse is being moved
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.OnEscapePressed(System.Boolean)">
            <summary>
            The escape, or start button has been pressed
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.EngineToModifier(System.Int32)">
            <summary>
            Convert engine (IE_ShiftPressed etc) to our KeyboardModifiers enum
            </summary>
        </member>
        <member name="T:Sandbox.Engine.WebSocket">
            <summary>
            A WebSocket client for connecting to external services.
            </summary>
            <remarks>
            Events handlers will be called on the synchronization context that <see cref="M:Sandbox.Engine.WebSocket.Connect(System.String,System.Threading.CancellationToken)"/> was called on.
            </remarks>
        </member>
        <member name="T:Sandbox.Engine.WebSocket.MessageReceivedHandler">
            <summary>
            Event handler which processes text messages from the WebSocket service.
            </summary>
            <param name="message">The message text that was received.</param>
        </member>
        <member name="T:Sandbox.Engine.WebSocket.DataReceivedHandler">
            <summary>
            Event handler which processes binary messages from the WebSocket service.
            </summary>
            <param name="data">The binary message data that was received.</param>
        </member>
        <member name="T:Sandbox.Engine.WebSocket.DisconnectedHandler">
            <summary>
            Event handler which fires when the WebSocket disconnects from the server.
            </summary>
            <param name="status">The close status code from the server, or 0 if there was none. See known values here: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</param>
            <param name="reason">The reason string for closing the connection. This may not be populated, may be from the server, or may be a client exception message.</param>
        </member>
        <member name="P:Sandbox.Engine.WebSocket.IsConnected">
            <summary>
            Returns true as long as a WebSocket connection is established.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.WebSocket.SubProtocol">
            <summary>
            Get the sub-protocol that was negotiated during the opening handshake.
            </summary>
        </member>
        <member name="E:Sandbox.Engine.WebSocket.OnMessageReceived">
            <summary>
            Event which fires when a text message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.Engine.WebSocket.OnDataReceived">
            <summary>
            Event which fires when a binary message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.Engine.WebSocket.OnDisconnected">
            <summary>
            Event which fires when the connection to the WebSocket service is lost, for any reason.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.#ctor(System.Int32)">
            <summary>
            Initialized a new WebSocket client.
            </summary>
            <param name="maxMessageSize">The maximum message size to allow from the server, in bytes. Default 64 KiB.</param>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Dispose">
            <summary>
            Cleans up resources used by the WebSocket client. This will also immediately close the connection if it is currently open.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.AddSubProtocol(System.String)">
            <summary>
            Add a sub-protocol to be negotiated during the WebSocket connection handshake.
            </summary>
            <param name="protocol"></param>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Connect(System.String,System.Threading.CancellationToken)">
            <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
            <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
            <param name="ct">A <see cref="T:System.Threading.CancellationToken"/> which allows the connection attempt to be aborted if necessary.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the connection is established, or throws if it failed to connect.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.String)">
            <summary>
            Sends a text message to the WebSocket server.
            </summary>
            <param name="message">The message text to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.Byte[])">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <remarks>
            The <see cref="M:Sandbox.Engine.WebSocket.Send(System.ArraySegment{System.Byte})"/> and <see cref="M:Sandbox.Engine.WebSocket.Send(System.Span{System.Byte})"/> overloads allow sending subsections of byte arrays.
            </remarks>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.ArraySegment{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.Span{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.Settings.RenderSettings.ApplySettingsForBenchmarks">
            <summary>
            We want benchmarks to have all similar settings. Set them here.
            The only fluctuations we should see are resolution and hardware.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Shaders.CompiledCombo">
            <summary>
            The results of compiling a single combo
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Shaders.ProgramSource.Compile(Sandbox.Engine.Shaders.ShaderCompileOptions,Sandbox.Shader,System.String,Sandbox.Engine.Shaders.ShaderCompile.Results,System.Threading.CancellationToken,System.String,System.String)">
            <summary>
            Compile a single program on this shader
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Shaders.ShaderCompile.Results">
            <summary>
            The results of a shader compile
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Success">
            <summary>
            True if the shader was compiled successfully. False indicates an error
            occurred. You can dig deeper into why in Programs.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Skipped">
            <summary>
            If true then this compile was skipped because nothing changed
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.CompiledShader">
            <summary>
            If successful, this contains the actual resource-encoded bytes of the
            shader compile.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Shaders.ShaderCompile.Results.Program">
            <summary>
            The results of an individual shader program compile (PS, VS etc)
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.Name">
            <summary>
            The identifier for this program
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.ComboCount">
            <summary>
            How many combos had to be compiled for this program. This is Static * Dynamic.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.Source">
            <summary>
            The full pre-processed source for this shader
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.Success">
            <summary>
            True if this was compiled successfully
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.Output">
            <summary>
            Shader compile output, warnings and errors
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Shaders.ShaderCompile.Compile(System.String,System.String,Sandbox.Engine.Shaders.ShaderCompileOptions,System.Threading.CancellationToken)">
            <summary>
            Compile a shader from a filename ("/folder/file.shader")
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Shaders.ShaderCompile.CompileResourceFile(System.String,System.Byte[])">
            <summary>
            Convert a shader to a resource file
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Shaders.ShaderCompileContext">
            <summary>
            Passed to shader compiles to provide a shared context between the compiles.
            This provides the source code to the compile, but it also gives an opportunity
            for the threaded, individual compiles, to share and cache information between them.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Shaders.ShaderCompileOptions">
            <summary>
            Options used when compiling a shader
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Shaders.ShaderCompileOptions.ConsoleOutput">
            <summary>
            Write to console. Used when running from the command line.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Shaders.ShaderSource">
            <summary>
            A source version of the shader. 
            In the future we'll use this to pre-process the shader, work out what programs it contains, and pull out all of the meta data that we need. 
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Shaders.ShaderSource.CheckOutOfDate">
            <summary>
            Updates IsOutOfDate
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Shaders.ShaderSource.ReadPrograms(System.String[])">
            <summary>
            Go through each line and find the programs that we have
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Shaders.ShaderSource.AddProgram(Sandbox.ShaderProgramType)">
            <summary>
            Add a program to compile
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Shaders.ShaderSource.Serialize(Sandbox.Shader,Sandbox.Engine.Shaders.ShaderCompile.Results,System.Boolean)">
            <summary>
            Serialize to the correct format
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Run">
            <summary>
            Run the trace and return the result. The result will return the first hit.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Ray(Vector3@,Vector3@)">
            <summary>
            Casts a ray from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Ray(Ray@,System.Single@)">
            <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithTag(System.String)">
            <summary>
            Only return scene objects with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the scene object will need all tags).
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithAllTags(System.String[])">
            <summary>
            Only return scene objects with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithAnyTags(System.String[])">
            <summary>
            Only return scene objects with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithoutTags(System.String[])">
            <summary>
            Only return scene objects without any of these tags
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Distance">
            <summary>
            The distance between start and end positions.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.StartPosition">
            <summary>
            The start position of the trace
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.EndPosition">
            <summary>
            The end or hit position of the trace
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.HitPosition">
            <summary>
            The hit position of the trace
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Fraction">
            <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Normal">
            <summary>
            The hit surface normal (direction vector)
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Transform">
            <summary>
            The transform of the hit object (if it has one)
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.SceneObject">
            <summary>
            If we hit something associated with a sceneobject, this will be that object.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.HitTriangleUv">
            <summary>
            This is the Uv coordinate on the triangle hit. 'x' represents the distance between Vertex 0-1, 'y' represents the distance between Vertex 0-2.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.VertexInfluence">
            <summary>
            Given the position on the triangle hit, this vector gives the influence of each vertex on that position.
            So for example, if the Vector is [1,0,0] that means that the hit point is right on vertex 0. If it's [0.33, 0.33, 0.33] then it's 
            right in the middle of each vertex.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.ProcessorName">
            <summary>
            Human-readable product name of this system's processor.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.ProcessorFrequency">
            <summary>
            The frequency of this system's processor in GHz.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.ProcessorCount">
            <summary>
            The number of logical processors in this system.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.TotalMemory">
            <summary>
            Total physical memory available on this machine, in bytes.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.Gpu">
            <summary>
            Human-readable product name of the graphics card in this system.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.GpuVersion">
            <summary>
            The version number of the graphics card driver.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.GpuMemory">
            <summary>
            Total VRAM on this system's graphics card.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.StorageSizeAvailable">
            <summary>
            Indicates the amount of available free space on game drive in bytes
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.StorageSizeTotal">
            <summary>
            Gets the total size of storage space on game drive in bytes
            </summary>
        </member>
        <member name="M:Sandbox.Engine.SystemInfo.AsObject">
            <summary>
            Return as an object, for sending to backends
            </summary>
        </member>
        <member name="T:Sandbox.Diagnostics.Allocations">
            <summary>
            Tools for diagnosing heap allocations
            </summary>
        </member>
        <member name="T:Sandbox.Diagnostics.CodeIterate">
            <summary>
            A shared private class with the explicit purpose of recording how long it takes
            between a developer saving a .cs file, and the changes being available on the client.
            This is used to diagnose and monitor the code iteration time.
            </summary>
        </member>
        <member name="T:Sandbox.Diagnostics.FrameStats">
            <summary>
            Stats returned from the engine each frame describing what was rendered, and how much of it.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsRendered">
            <summary>
            Number of objects rendered that passed the cull checks.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.TrianglesRendered">
            <summary>
            Total number of triangles rendered
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.DrawCalls">
            <summary>
            Number of draw calls
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.MaterialChanges">
            <summary>
            Number of scenesystem material changes
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.DisplayLists">
            <summary>
            Number of display lists submitted to the GPU
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.SceneViewsRendered">
            <summary>
            Number of scene system views rendered
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.RenderTargetResolves">
            <summary>
            Number of render target resolves
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsCulledByVis">
            <summary>
            Number of objects culled by static visibility (vis)
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsCulledByScreenSize">
            <summary>
            Number of objects culled by screen size
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsCulledByFade">
            <summary>
            Number of objects culled by distance fading
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsFading">
            <summary>
            Number of objects currently being distance-faded
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.ShadowedLightsInView">
            <summary>
            Number of lights in view that cast shadows
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.UnshadowedLightsInView">
            <summary>
            Number of lights in view that don't cast shadows
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.FrameStats.ShadowMaps">
            <summary>
            Number of shadow maps rendered this frame
            </summary>
        </member>
        <member name="M:Sandbox.Diagnostics.Performance.Scope(System.String)">
            <summary>
            Record a frame state section in PerformanceStats
            </summary>
        </member>
        <member name="T:Sandbox.Diagnostics.Performance.ScopeSection">
            <summary>
            This exists to allow the creation of performance scopes without
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.FrameTime">
            <summary>
            Get the time taken, in seconds, that were required to process the previous frame.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.GpuFrametime">
            <summary>
            Latest available GPU frametime, in ms.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.GpuFrameNumber">
            <summary>
            Frame number of the last reported <see cref="P:Sandbox.Diagnostics.PerformanceStats.GpuFrametime"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.BytesAllocated">
            <summary>
            The number of bytes that were allocated on the managed heap in the last frame.
            <remarks>This may not include allocations from threads other than the game thread.</remarks>
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.Gen0Collections">
            <summary>
            Number of generation 0 (fastest) garbage collections were done in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.Gen1Collections">
            <summary>
            Number of generation 1 (fast) garbage collections were done in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.Gen2Collections">
            <summary>
            Number of generation 2 (slow) garbage collections were done in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.GcPause">
            <summary>
            How many ticks we paused in the last frame
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.Exceptions">
            <summary>
            Number of exceptions in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.ApproximateProcessMemoryUsage">
            <summary>
            Approximate working set of this process.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.LastSecond">
            <summary>
            Performance statistics over the last period, which is dictated by "perf_time" console command.
            </summary>
        </member>
        <member name="M:Sandbox.Diagnostics.PerformanceStats.Timings.GetMain">
            <summary>
            Return a list of the main top tier timings we're interested in
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.NumFrames">
            <summary>
            How many frames have we rendered so far?
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.NumDroppedFrames">
            <summary>
            How many frames have we missed so far?
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.ReprojectionRatio">
            <summary>
            Number of frames that were reprojected as a fraction
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.TotalRenderGpu">
            <summary>
            Total GPU time in milliseconds
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.CompositorRenderGpu">
            <summary>
            Total time the compositor took on the GPU, in milliseconds
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.CompositorRenderCpu">
            <summary>
            Total time the compositor took on the CPU, in milliseconds
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.ResolutionScale">
            <summary>
            SteamVR supersampling scale as a fraction
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.Resolution">
            <summary>
            Effective render resolution (base resolution multiplied by <see cref="F:Sandbox.Diagnostics.PerformanceStats.VRStats.ResolutionScale"/>), per-eye
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.InterpupillaryDistance">
            <summary>
            IPD in millimetres
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.LeftControllerBatteryPercentage">
            <summary>
            Total left controller battery percentage (0 to 100)
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.RightControllerBatteryPercentage">
            <summary>
            Total right controller battery percentage (0 to 100)
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.HeadsetBatteryPercentage">
            <summary>
            Total headset battery percentage (0 to 100)
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.VR">
            <summary>
            Stats retrieved from the SteamVR compositor
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.EtwLogger.SymbolPath">
            <summary>
            Additional symbol path to use for resolving symbols
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.UpdateInput">
            <summary>
            Pumps the input system
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.Exiting">
            <summary>
            Called when the application is shutting down
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.DispatchConsoleCommand(System.String,System.String,System.Int64)">
            <summary>
            A console command has arrived, or a convar has changed
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.OnSceneViewSubmitted(NativeEngine.ISceneView)">
            <summary>
            Called right at the end of a view being submitted, so everything CPU is done and it's handed off to the GPU.
            This is also called for any dependent views.
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.DisposeAtFrameEnd(System.IDisposable)">
            <summary>
            Queue something to be disposed of after the frame has ended and everything has finished rendering.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.BlockingLoopPumper">
            <summary>
            Sometimes stuff is blocking that doesn't need to be. We want to keep running the main loop
            while the function is blocking. This usually happens with Qt stuff like the drag and drop.
            This should allow the main loop to still be pumped while waiting for that blocking function.
            
            - main game loop
            while ( true )
            {
            	mainloop();
            	
            	BlockingLoopPumper.Run()
            	{
            		runBlockingFunction();
            	}
            }
            
            - somewhere else - usually Qt Timer
            BlockingLoopPumper.Pump();
            {
            	mainloop();
            }
            
            </summary>
        </member>
        <member name="P:Sandbox.Internal.BlockingLoopPumper.PendingFunction">
            <summary>
            Used to call things outside of the main frame
            </summary>
        </member>
        <member name="M:Sandbox.Internal.BlockingLoopPumper.Run(System.Action)">
            <summary>
            Called outside the main game loop.
            </summary>
            <param name="pumper">An action to call the main game loop</param>
        </member>
        <member name="M:Sandbox.Internal.BlockingLoopPumper.Pump">
            <summary>
            Should be called regularly, on the main thread. Generally this is called
            automatically by Qt in the timer (search OnQtHeartbeat).
            This should do total nothing if we're not actually in a blocking loop -  
            because loopPump will be null.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IMenuSystem">
            <summary>
            This is how the engine communicates with the menu system
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.Init">
            <summary>
            Called to initialize the menu system
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.Shutdown">
            <summary>
            Close down the menu, delete everything
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.Tick">
            <summary>
            Called every frame, to let the menu think
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.Popup(System.String,System.String,System.String)">
            <summary>
            Show a popup
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.Question(System.String,System.String,System.Action,System.Action)">
            <summary>
            Show a question
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.OnPackageClosed(Sandbox.Package)">
            <summary>
            Package closed. Add a toast asking if it was cool or not
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IMenuSystem.ForceCursorVisible">
            <summary>
            True if we want to force the cursor to be visible and swallow input.
            This is used for the developer console and loading screens.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.ILoadingInterface">
            <summary>
            Used to talk to the menu's loading screen.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.Id">
            <summary>
            The Id of the element ( id="foo" )
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.SourceFile">
            <summary>
            If the panel created by razor, this is the file in which it was defined
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.SourceLine">
            <summary>
            If the panel was created by razor, this is the line in which it was defined
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.WantsPointerEvents">
            <summary>
            If true then this panel (or its ancestor) has pointer-events: all
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IPanel.SetAbsolutePosition(Sandbox.TextFlag,Vector2,System.Single)">
            <summary>
            Set the panel's absolute position. This wouldn't be needed if we could expose the styles. Which we should
            do.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.PseudoClass">
            <summary>
            Procedural classes such as :hover and :active
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.ActiveStyleBlocks">
            <summary>
            Get all style blocks active on this panel
            </summary>
        </member>
        <member name="P:Sandbox.Internal.GlobalGameNamespace.Log">
            <summary>
            Log information to console for debugging purposes.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.GlobalGameNamespace.Cookie">
            <summary>
            Data storage that persists across sessions.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.GlobalGameNamespace.TypeLibrary">
            <summary>
            Allows access to all available types, reflection style.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown when accessed during static constructors.
            </exception>
        </member>
        <member name="M:Sandbox.Internal.SceneObjectTags.GetTokens">
            <summary>
            Try to get all tags in the set.
            </summary>
        </member>
        <member name="M:Sandbox.Modals.IModalSystem.PauseMenu">
            <summary>
            The menu that is shown when escape is pressed while playing.
            </summary>
        </member>
        <member name="P:Sandbox.Modals.FriendsListModalOptions.ShowOfflineMembers">
            <summary>
            Show offline members
            </summary>
        </member>
        <member name="P:Sandbox.Modals.FriendsListModalOptions.ShowOnlineMembers">
            <summary>
            Show online (but not in-game) members
            </summary>
        </member>
        <member name="T:Sandbox.Modals.CreateGameOptions">
            <summary>
            Passed to IModalSystem.CreateGame
            </summary>
        </member>
        <member name="T:Sandbox.DelegateFunctionPointer">
            <summary>
            Helper to wrap <see cref="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)"/> while keeping
            a reference to the original delegate, so it won't be garbage collected. <see cref="M:Sandbox.DelegateFunctionPointer.Dispose"/>
            must be called to remove the reference.
            </summary>
        </member>
        <member name="M:Sandbox.DelegateFunctionPointer.op_Implicit(Sandbox.DelegateFunctionPointer)~System.IntPtr">
            <summary>
            Gets the raw function pointer.
            </summary>
        </member>
        <member name="M:Sandbox.DelegateFunctionPointer.Get``1(``0)">
            <inheritdoc cref="T:Sandbox.DelegateFunctionPointer"/>
        </member>
        <member name="M:Sandbox.DelegateFunctionPointer.Dispose">
            <summary>
            Removes the reference to the original delegate, and sets the function pointer to null.
            </summary>
        </member>
        <member name="T:Sandbox.IHandle">
            <summary>
            A base interface that all handles should use
            </summary>
        </member>
        <member name="T:Sandbox.HandleCreationData">
            <summary>
            This struct exists to differentiate the constructor of a handle object
            from the regular constructors. This way we can prevent clients creating
            the object manually, but still be able to create them at runtime.
            </summary>
        </member>
        <member name="T:Sandbox.HandleIndex">
            <summary>
            An index that can convert from a handle (int) to a class. This is
            usually a static on your Handle object called HandleIndex.
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetString(System.IntPtr)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetString(System.IntPtr,System.Int32)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetUtf8Length(System.Byte*,System.Int32)">
            <summary>
            Get the length of a null-terminated UTF-8 string using AVX2 (fallback to scalar if unavailable)
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetWString(System.IntPtr)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetWString(System.IntPtr,System.Int32)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.BindingException(System.String,System.String,System.Exception)">
            <summary>
            Called by the binding system to log an exception when calling a binding
            </summary>
        </member>
        <member name="T:Sandbox.Interop.PassBackString">
            <summary>
            used to pass a string back to native
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetTemporaryStringPointerForNative(System.String)">
            <summary>
            This is called when native calls a managed function and it returns a string. In this case
            we can't free the string immediately, so we store it in a list and free it at the end of the frame.
            This has potential to crash, if we free the string before the thread uses it but this would be super 
            rare and the other option is to never return strings like this.
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.FilterMode">
            <summary>
            Represents filtering modes for texture sampling in the rendering pipeline.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.FilterMode.Point">
            <summary>
            Uses the nearest texel without interpolation.
            Fastest but lowest visual quality.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.FilterMode.Bilinear">
            <summary>
            Interpolates between the four nearest texels in the same mip level.
            Smoother than point sampling but does not blend between mip levels.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.FilterMode.Trilinear">
            <summary>
            Bilinear sampling with smooth transitions between mipmap levels.
            Provides better visual quality across distances.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.FilterMode.Anisotropic">
            <summary>
            Enhances texture detail on steep viewing angles.
            Best visual quality, higher performance cost.
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.TextureAddressMode">
            <summary>
            Specifies how texture coordinates outside the [0.0, 1.0] range are handled.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.TextureAddressMode.Wrap">
            <summary>
            Wraps the texture coordinates. Values beyond 1.0 wrap around to the beginning.
            Produces a repeating tiling pattern.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.TextureAddressMode.Mirror">
            <summary>
            Mirrors the texture coordinates when sampling outside the [0.0, 1.0] range.
            Creates a mirrored tiling effect.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.TextureAddressMode.Clamp">
            <summary>
            Clamps the texture coordinates to the [0.0, 1.0] range.
            Texture edges are stretched when sampling outside the range.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.TextureAddressMode.Border">
            <summary>
            Uses a constant border color when sampling outside the [0.0, 1.0] range.
            Requires a border color to be defined.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.TextureAddressMode.MirrorOnce">
            <summary>
            Mirrors the texture once, then clamps to the edge.
            Coordinates in [0.0, 1.0] sample normally, [-1.0, 0.0] mirror once, and everything else clamps.
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.SceneViewRenderTargetHandle">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.SamplerState">
             <summary>
             Represents a sampler state used to control how textures are sampled in shaders.
             Example usage: 
             <code>
             SamplerState mySampler &lt; Attribute("sampler"); &gt;;
             </code>
             
             C# binding:
             <code>
             var sampler = new SamplerState
             {
                 Filter = FilterMode.Trilinear,
                 AddressModeU = TextureAddressMode.Wrap,
                 AddressModeV = TextureAddressMode.Wrap,
                 AddressModeW = TextureAddressMode.Clamp,
                 MaxAnisotropy = 4
             };
            
             Graphics.Attributes.Set("sampler", sampler);
             </code>
             </summary>
        </member>
        <member name="P:Sandbox.Rendering.SamplerState.Filter">
            <summary>
            The texture filtering mode used for sampling (e.g., point, bilinear, trilinear).
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.SamplerState.AddressModeU">
            <summary>
            The addressing mode used for the U (X) texture coordinate.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.SamplerState.AddressModeV">
            <summary>
            The addressing mode used for the V texture coordinate.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.SamplerState.AddressModeW">
            <summary>
            The addressing mode used for the W texture coordinate.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.SamplerState.MipLodBias">
            <summary>
            The bias applied to the calculated mip level during texture sampling.
            Positive values make textures appear blurrier; negative values sharpen.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.SamplerState.MaxAnisotropy">
            <summary>
            The maximum anisotropy level used for anisotropic filtering.
            Higher values improve texture quality at oblique viewing angles.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.SamplerState.BorderColor">
            <summary>
            Border color to use if <see cref="F:Sandbox.Rendering.TextureAddressMode.Border"/> is specified for AddressU, AddressV, or AddressW.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.SamplerState.GetBindlessIndex(Sandbox.Rendering.SamplerState)">
            <summary>
            Gets or creates a bindless sampler index for this <see cref="T:Sandbox.Rendering.SamplerState"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.AttributeAccess.Set(Sandbox.StringToken,Sandbox.Rendering.RenderTargetHandle.ColorTextureRef,System.Int32)">
            <summary>
            Set the color texture from this named render target to this attribute
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.AttributeAccess.Set(Sandbox.StringToken,Sandbox.Rendering.RenderTargetHandle.ColorIndexRef)">
            <summary>
            Set the color texture from this named render target to this attribute
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.AttributeAccess.GrabFrameTexture(System.String,System.Boolean)">
            <summary>
            Takes a copy of the current viewport's color texture and stores it in targetName on renderAttributes.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.AttributeAccess.GrabDepthTexture(System.String,System.Boolean)">
            <summary>
            Takes a copy of the current viewport's depth texture and stores it in targetName on renderAttributes.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.AttributeAccess.GetRenderTarget(System.String)">
            <summary>
            Get the actual render target by name. Useful for externals that need to access the render target directly.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.CommandList.GlobalAttributes">
            <summary>
            These are the attributes for the current view. Setting a variable here will let you pass it down to
            other places in the render pipeline.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.CommandList.Attributes">
            <summary>
            Access to the local attributes. What these are depends on where the command list is being called.
            If we're calling from a renderable, these are the attributes for that renderable.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.CommandList.Paint">
            <summary>
            Access to simple 2D painting functions to draw shapes and text.
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.CommandList.State">
            <summary>
            This lives for the lifetime of the command list and is 
            used to store temporary render targets and other state.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.State.Reset">
            <summary>
            Should be called at the end of usage
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.State.GetRenderTarget(System.String)">
            <summary>
            Sneaky way for externals to get render target
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.GrabFrameTexture(System.String,System.Boolean)">
            <summary>
            Takes a copy of the framebuffer and returns a handle to it
            </summary>
            <param name="token"></param>
            <param name="withMips">Generates mipmaps on the grabbed texture filtered with gaussian blur for each mip</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.GrabDepthTexture(System.String,System.Boolean)">
            <summary>
            Takes a copy of the depthbuffer and returns a handle to it
            </summary>
            <param name="token"></param>
            <param name="withMips">Generates mipmaps on the grabbed texture filtered with gaussian blur for each mip</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.InsertList(Sandbox.Rendering.CommandList)">
            <summary>
            Run this CommandList here
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.ExecuteOnRenderThread">
            <summary>
            Run this command list
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.CommandList.Flag">
            <summary>
            Command buffer flags allow us to skip command buffers if the camera 
            doesn't want a particular thing. Like post processing.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawModel(Sandbox.Model,Transform,Sandbox.RenderAttributes)">
            <summary>
            Draws a single model at the given Transform immediately.
            </summary>
            <param name="model">The model to draw</param>
            <param name="transform">Transform to draw the model at</param>
            <param name="attributes">Optional attributes to apply only for this draw call</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawModelInstanced(Sandbox.Model,System.Span{Transform},Sandbox.RenderAttributes)">
            <summary>
            Draws multiple instances of a model using GPU instancing, assuming standard implemented shaders.
            
            Use `GetTransformMatrix( int instance )` in shaders to access the instance transform.
            
            There is a limit of 1,048,576 transform slots per frame when using this method.
            </summary>
            <param name="model">The model to draw</param>
            <param name="transforms">Instance transform data to draw</param>
            <param name="attributes">Optional attributes to apply only for this draw call</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawModelInstancedIndirect(Sandbox.Model,Sandbox.GpuBuffer,System.Int32,Sandbox.RenderAttributes)">
            <summary>
            Draws multiple instances of a model using GPU instancing with the number of instances being provided by indirect draw arguments.
            Use `SV_InstanceID` semantic in shaders to access the rendered instance.
            </summary>
            <param name="model">The model to draw</param>
            <param name="buffer">The GPU buffer containing the DrawIndirectArguments</param>
            <param name="bufferOffset">Optional offset in the GPU buffer</param>
            <param name="attributes">Optional attributes to apply only for this draw call</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawModelInstanced(Sandbox.Model,System.Int32,Sandbox.RenderAttributes)">
            <summary>
            Draws multiple instances of a model using GPU instancing.
            This is similar to <see cref="M:Sandbox.Rendering.CommandList.DrawModelInstancedIndirect(Sandbox.Model,Sandbox.GpuBuffer,System.Int32,Sandbox.RenderAttributes)"/>,
            except the count is provided from the CPU rather than via a GPU buffer.
            
            Use `SV_InstanceID` semantic in shaders to access the rendered instance.
            </summary>
            <param name="model">The model to draw</param>
            <param name="count">The number of instances to draw</param>
            <param name="attributes">Optional attributes to apply only for this draw call</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.Draw``1(Sandbox.GpuBuffer{``0},Sandbox.Material,System.Int32,System.Int32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draws geometry using a vertex buffer and material.
            </summary>
            <typeparam name="T">The vertex type used for vertex layout.</typeparam>
            <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
            <param name="material">The material to use for rendering.</param>
            <param name="startVertex">The starting vertex index for rendering.</param>
            <param name="vertexCount">The number of vertices to render. If 0, uses all vertices in the buffer.</param>
            <param name="attributes">Optional render attributes to apply only for this draw call.</param>
            <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawIndexed``1(Sandbox.GpuBuffer{``0},Sandbox.GpuBuffer,Sandbox.Material,System.Int32,System.Int32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draws indexed geometry using vertex and index buffers.
            </summary>
            <typeparam name="T">The vertex type used for vertex layout.</typeparam>
            <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
            <param name="indexBuffer">The GPU buffer containing index data.</param>
            <param name="material">The material to use for rendering.</param>
            <param name="startIndex">The starting index for rendering.</param>
            <param name="indexCount">The number of indices to render. If 0, uses all indices in the buffer.</param>
            <param name="attributes">Optional render attributes to apply only for this draw call.</param>
            <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawInstancedIndirect``1(Sandbox.GpuBuffer{``0},Sandbox.Material,Sandbox.GpuBuffer,System.UInt32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draws instanced geometry using a vertex buffer and indirect draw arguments stored in a GPU buffer.
            </summary>
            <typeparam name="T">The vertex type used for vertex layout.</typeparam>
            <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
            <param name="material">The material to use for rendering.</param>
            <param name="indirectBuffer">The GPU buffer containing indirect draw arguments.</param>
            <param name="bufferOffset">Optional byte offset into the indirect buffer.</param>
            <param name="attributes">Optional render attributes to apply only for this draw call.</param>
            <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawInstancedIndirect(Sandbox.Material,Sandbox.GpuBuffer,System.UInt32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draws instanced geometry using a vertex buffer and indirect draw arguments stored in a GPU buffer.
            </summary>
            <remarks>
            Vertex data is accessed in shader through buffer attribute and SV_VertexID.
            </remarks>
            <param name="material">The material to use for rendering.</param>
            <param name="indirectBuffer">The GPU buffer containing indirect draw arguments.</param>
            <param name="bufferOffset">Optional byte offset into the indirect buffer.</param>
            <param name="attributes">Optional render attributes to apply only for this draw call.</param>
            <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawIndexedInstancedIndirect``1(Sandbox.GpuBuffer{``0},Sandbox.GpuBuffer,Sandbox.Material,Sandbox.GpuBuffer,System.UInt32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draws instanced indexed geometry using indirect draw arguments stored in a GPU buffer.
            </summary>
            <typeparam name="T">The vertex type used for vertex layout.</typeparam>
            <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
            <param name="indexBuffer">The GPU buffer containing index data.</param>
            <param name="material">The material to use for rendering.</param>
            <param name="indirectBuffer">The GPU buffer containing indirect draw arguments.</param>
            <param name="bufferOffset">Optional byte offset into the indirect buffer.</param>
            <param name="attributes">Optional render attributes to apply only for this draw call.</param>
            <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawIndexedInstancedIndirect(Sandbox.GpuBuffer,Sandbox.Material,Sandbox.GpuBuffer,System.UInt32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draws instanced indexed geometry using indirect draw arguments stored in a GPU buffer.
            </summary>
            <remarks>
            Vertex data is accessed in shader through buffer attribute and SV_VertexID.
            </remarks>
            <param name="indexBuffer">The GPU buffer containing index data.</param>
            <param name="material">The material to use for rendering.</param>
            <param name="indirectBuffer">The GPU buffer containing indirect draw arguments.</param>
            <param name="bufferOffset">Optional byte offset into the indirect buffer.</param>
            <param name="attributes">Optional render attributes to apply only for this draw call.</param>
            <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.GetRenderTarget(System.String,Sandbox.ImageFormat,System.Int32,System.Int32)">
            <summary>
            Get a screen sized temporary render target. You should release the returned handle when you're done to return the textures to the pool.
            </summary>
            <param name="name">The name of the render target handle.</param>
            <param name="sizeFactor">Divide the screen size by this factor. 2 would be half screen sized. 1 for full screen sized.</param>
            <param name="format">The format for the color buffer. If set to default we'll use whatever the current pipeline is using.</param>
            <param name="numMips">Number of mips you want in this texture. You probably don't want this unless you want to generate mips in a second pass.</param>
            <returns>A RenderTarget that is ready to render to.</returns>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.GetRenderTarget(System.String,System.Int32,Sandbox.ImageFormat,Sandbox.ImageFormat,Sandbox.MultisampleAmount,System.Int32)">
            <summary>
            Get a screen sized temporary render target. You should release the returned handle when you're done to return the textures to the pool.
            </summary>
            <param name="name">The name of the render target handle.</param>
            <param name="sizeFactor">Divide the screen size by this factor. 2 would be half screen sized. 1 for full screen sized.</param>
            <param name="colorFormat">The format for the color buffer. If set to default we'll use whatever the current pipeline is using.</param>
            <param name="depthFormat">The format for the depth buffer.</param>
            <param name="msaa">The number of msaa samples you'd like. Msaa render textures are a pain in the ass so you're probably gonna regret trying to use this.</param>
            <param name="numMips">Number of mips you want in this texture. You probably don't want this unless you want to generate mips in a second pass.</param>
            <returns>A RenderTarget that is ready to render to.</returns>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.GetRenderTarget(System.String,System.Int32,System.Int32,Sandbox.ImageFormat,Sandbox.ImageFormat,Sandbox.MultisampleAmount,System.Int32)">
            <summary>
            Get a temporary render target. You should release the returned handle when you're done to return the textures to the pool.
            </summary>
            <param name="name">The name of the render target handle.</param>
            <param name="width">Width of the render target you want.</param>
            <param name="height">Height of the render target you want.</param>
            <param name="colorFormat">The format for the color buffer. If set to default we'll use whatever the current pipeline is using.</param>
            <param name="depthFormat">The format for the depth buffer.</param>
            <param name="msaa">The number of msaa samples you'd like. Msaa render textures are a pain in the ass so you're probably gonna regret trying to use this.</param>
            <param name="numMips">Number of mips you want in this texture. You probably don't want this unless you want to generate mips in a second pass.</param>
            <returns>A RenderTarget that is ready to render to.</returns>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.ReleaseRenderTarget(Sandbox.Rendering.RenderTargetHandle)">
            <summary>
            We're no longer using this RT, return it to the pool
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.SetRenderTarget(Sandbox.Rendering.RenderTargetHandle)">
            <summary>
            Set the current render target. Setting this will bind the render target and change the viewport to match it.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.SetRenderTarget(Sandbox.RenderTarget)">
            <summary>
            Set the current render target. Setting this will bind the render target and change the viewport to match it.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.ClearRenderTarget">
            <summary>
            Set the current render target. Setting this will bind the render target and change the viewport to match it.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.Set(Sandbox.StringToken,Sandbox.Rendering.RenderTargetHandle.ColorTextureRef,System.Int32)">
            <summary>
            Set the color texture from this named render target to this attribute
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.SetGlobal(Sandbox.StringToken,Sandbox.Rendering.RenderTargetHandle.ColorIndexRef)">
            <summary>
            Set the color texture from this named render target to this attribute
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DispatchCompute(Sandbox.ComputeShader,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:Sandbox.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DispatchComputeIndirect(Sandbox.ComputeShader,Sandbox.GpuBuffer,System.UInt32)">
            <inheritdoc cref="M:Sandbox.ComputeShader.DispatchIndirect(Sandbox.GpuBuffer,System.UInt32)"/>
        </member>
        <member name="P:Sandbox.Rendering.CommandList.ViewportSize">
            <summary>
            A handle to the viewport size
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DispatchCompute(Sandbox.ComputeShader,Sandbox.Rendering.RenderTargetHandle.SizeHandle)">
            <summary>
            Dispatch a compute shader
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.GetDimension(System.String)">
            <summary>
            Called during rendering, convert RenderTargetHandle.SizeHandle to a dimension
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.Clear(Color,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Clear the current drawing context to given color.
            </summary>
            <param name="color">Color to clear to.</param>
            <param name="clearColor">Whether to clear the color buffer at all.</param>
            <param name="clearDepth">Whether to clear the depth buffer.</param>
            <param name="clearStencil">Whether to clear the stencil buffer.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.ResourceBarrierTransition(Sandbox.Texture,Sandbox.Rendering.ResourceState)">
            <summary>
            Executes a barrier transition for the given GPU Texture Resource.
            Transitions the texture resource to a new pipeline stage and access state.
            </summary>
            <param name="texture">The texture to transition.</param>
            <param name="state">The new resource state for the texture.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.ResourceBarrierTransition(Sandbox.GpuBuffer,Sandbox.Rendering.ResourceState)">
            <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource to a new pipeline stage and access state.
            </summary>
            <param name="buffer">The GPU buffer to transition.</param>
            <param name="state">The new resource state for the buffer.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.ResourceBarrierTransition(Sandbox.GpuBuffer,Sandbox.Rendering.ResourceState,Sandbox.Rendering.ResourceState)">
            <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource from a known source state to a specified destination state.
            </summary>
            <param name="buffer">The GPU buffer to transition.</param>
            <param name="before">The current resource state of the buffer.</param>
            <param name="after">The desired resource state of the buffer after the transition.</param>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.AddAction(System.Action)">
            <summary>
            Sneaky way for extensions to add an action
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.GetRenderTarget(System.String)">
            <summary>
            Sneaky way for externals to get render target
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.GenerateMipMaps(Sandbox.Rendering.RenderTargetHandle,Sandbox.Graphics.DownsampleMethod)">
            <summary>
            Generates a mip-map chain for the specified render target.
            This will generate mipmaps for the color texture of the render target.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.GenerateMipMaps(Sandbox.RenderTarget,Sandbox.Graphics.DownsampleMethod)">
            <summary>
            Generates a mip-map chain for the specified render target.
            This will generate mipmaps for the color texture of the render target.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawRenderer(Sandbox.Renderer,Sandbox.Rendering.RendererSetup)">
            <summary>
            Render a <see cref="T:Sandbox.Renderer"/> with the specified overrides.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawView(Sandbox.CameraComponent,Sandbox.Rendering.RenderTargetHandle,Sandbox.Rendering.ViewSetup)">
            <summary>
            Renders the view from a camera to the specified render target.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawReflection(Sandbox.CameraComponent,Sandbox.Plane,Sandbox.Rendering.RenderTargetHandle@,Sandbox.Rendering.ReflectionSetup)">
            <summary>
            Render a planar reflection using the specified camera and the specified plane.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.CommandList.DrawRefraction(Sandbox.CameraComponent,Sandbox.Plane,Sandbox.Rendering.RenderTargetHandle@,Sandbox.Rendering.RefractionSetup)">
            <summary>
            Render a planar refraction using the specified camera and the specified plane. This is for all intents and purposes a
            regular view with a plane clipping it. Usually used for rendering under water.
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.HudPainter">
            <summary>
            2D Drawing functions for a <see cref="T:Sandbox.Rendering.CommandList"/>.
            <para>
            <c>HudPainter</c> provides a set of methods for drawing shapes, textures, and text onto a command list, typically for HUD or UI rendering.
            </para>
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.HudPainter.list">
            <summary>
            The underlying <see cref="T:Sandbox.Rendering.CommandList"/> used for rendering.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.#ctor(Sandbox.Rendering.CommandList)">
            <summary>
            Initializes a new instance of the <see cref="T:Sandbox.Rendering.HudPainter"/> struct for the specified <paramref name="commandList"/>.
            </summary>
            <param name="commandList">The command list to draw to. Must not be null.</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.SetBlendMode(Sandbox.BlendMode)">
            <summary>
            Sets the blend mode for subsequent drawing operations.
            </summary>
            <param name="mode">The blend mode to use.</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.SetMatrix(Matrix)">
            <summary>
            Sets the transformation matrix for subsequent drawing operations.
            </summary>
            <param name="matrix">The transformation matrix to apply.</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.DrawCircle(Vector2,Vector2,Color)">
            <summary>
            Draws a filled circle at the specified position and size.
            </summary>
            <param name="position">The center position of the circle.</param>
            <param name="size">The size (diameter) of the circle.</param>
            <param name="color">The color of the circle.</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.DrawRect(Sandbox.Rect@,Color@,Vector4@,Vector4@,Color@)">
            <summary>
            Draws a rectangle with optional corner radius and border.
            </summary>
            <param name="rect">The rectangle to draw.</param>
            <param name="color">The fill color of the rectangle.</param>
            <param name="cornerRadius">The radius for each corner (optional).</param>
            <param name="borderWidth">The width of the border for each edge (optional).</param>
            <param name="borderColor">The color of the border (optional).</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.DrawTexture(Sandbox.Texture,Sandbox.Rect)">
            <summary>
            Draws a texture in the specified rectangle with a white tint.
            </summary>
            <param name="texture">The texture to draw.</param>
            <param name="rect">The rectangle to draw the texture in.</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.DrawTexture(Sandbox.Texture,Sandbox.Rect,Color)">
            <summary>
            Draws a texture in the specified rectangle with a tint color.
            </summary>
            <param name="texture">The texture to draw.</param>
            <param name="rect">The rectangle to draw the texture in.</param>
            <param name="tint">The tint color to apply to the texture.</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.DrawText(System.String,System.Single,Color,Vector2,Sandbox.TextFlag)">
            <summary>
            Draws text at a 3D point with the specified size, color, and alignment flags.
            </summary>
            <param name="text">The text to draw.</param>
            <param name="size">The font size.</param>
            <param name="color">The color of the text.</param>
            <param name="point">The 3D point to draw the text at.</param>
            <param name="flags">Text alignment flags (optional).</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.DrawText(System.String,System.Single,Color,Sandbox.Rect,Sandbox.TextFlag)">
            <summary>
            Draws text within a rectangle with the specified size, color, and alignment flags.
            </summary>
            <param name="text">The text to draw.</param>
            <param name="size">The font size.</param>
            <param name="color">The color of the text.</param>
            <param name="rect">The rectangle to draw the text in.</param>
            <param name="flags">Text alignment flags (optional).</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.DrawText(Sandbox.TextRendering.Scope@,Vector2,Sandbox.TextFlag)">
            <summary>
            Draws text at a 3D point using a prepared <see cref="T:Sandbox.TextRendering.Scope"/>.
            </summary>
            <param name="scope">The text rendering scope.</param>
            <param name="point">The 3D point to draw the text at.</param>
            <param name="flags">Text alignment flags (optional).</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.DrawText(Sandbox.TextRendering.Scope@,Sandbox.Rect,Sandbox.TextFlag)">
            <summary>
            Draws text within a rectangle using a prepared <see cref="T:Sandbox.TextRendering.Scope"/>.
            </summary>
            <param name="scope">The text rendering scope.</param>
            <param name="rect">The rectangle to draw the text in.</param>
            <param name="flags">Text alignment flags (optional).</param>
        </member>
        <member name="M:Sandbox.Rendering.HudPainter.DrawLine(Vector2,Vector2,System.Single,Color,Vector4)">
            <summary>
            Draws a line between two points with the specified width and color.
            </summary>
            <param name="a">The start point of the line.</param>
            <param name="b">The end point of the line.</param>
            <param name="width">The width of the line.</param>
            <param name="color">The color of the line.</param>
            <param name="corners">Optional corner flags for line end caps.</param>
        </member>
        <member name="T:Sandbox.Rendering.RenderTargetHandle">
            <summary>
            A render target handle used with CommandLists
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.RenderTargetHandle.ColorTexture">
            <summary>
            Reference to the color texture of this target
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.RenderTargetHandle.ColorIndex">
            <summary>
            Reference to the index of the color texture of this target
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.RenderTargetHandle.Size">
            <summary>
            Reference to the size of the texture
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.ViewSetup">
            <summary>
            When manually rendering a camera this will let you override specific
            elements of that render. This means you can use most of the camera's
            properties, but override some without disturbing the camera itself.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.Transform">
            <summary>
            Overrides the camera's position and rotation
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.FieldOfView">
            <summary>
            Overrides the camera's field of view
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.ZNear">
            <summary>
            Overrides the camera's znear
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.ZFar">
            <summary>
            Overrides the camera's zfar
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.ClearColor">
            <summary>
            Overrides the camera's clear color
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.ProjectionMatrix">
            <summary>
            Overrides the camera's projection matrix
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.GradientFog">
            <summary>
            Allows overriding gradient fog for this view
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.AmbientLightTint">
            <summary>
            If set then the regular scene's ambient light will be multiplied by this
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.AmbientLightAdd">
            <summary>
            If set then this will be added to the ambient light color
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.ClipSpaceBounds">
            <summary>
            Clipspace is usually used for rendering posters, or center-offsetting the view. You're basically zooming
            into a subrect of the clipspace. So imagine you draw a smaller rect inside the first rect of the frustum.. 
            that's what you're gonna render - that rect.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.FlipX">
            <summary>
            When rendering to a texture, this allows you to flip the view horizontally.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.FlipY">
            <summary>
            When rendering to a texture, this allows you to flip the view vertically.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ViewSetup.ViewHash">
            <summary>
            If you're rendering a subview this will allow the renderer to find the same view again next frame
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.GradientFogSetup">
            <summary>
            Setup for defining gradient fog in a view
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.GradientFogSetup.Enabled">
            <summary>
            Whether the fog is enabled.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.GradientFogSetup.StartDistance">
            <summary>
            Start distance of the fog.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.GradientFogSetup.EndDistance">
            <summary>
            End distance of the fog.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.GradientFogSetup.StartHeight">
            <summary>
            The starting height of the gradient fog.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.GradientFogSetup.EndHeight">
            <summary>
            The ending height of the gradient fog.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.GradientFogSetup.MaximumOpacity">
            <summary>
            The maximum opacity of the gradient fog.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.GradientFogSetup.Color">
            <summary>
            The color of the gradient fog.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.GradientFogSetup.DistanceFalloffExponent">
            <summary>
            The exponent controlling the distance-based falloff of the fog.
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.GradientFogSetup.VerticalFalloffExponent">
            <summary>
            The exponent controlling the vertical falloff of the fog.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.GradientFogSetup.LerpTo(Sandbox.Rendering.GradientFogSetup,System.Single,System.Boolean)">
            <summary>
            Lerp this GradientFogSetup to a another, allowing transition states.
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.ReflectionSetup">
            <summary>
            Allows special setup for reflections, such as offsetting the reflection plane
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ReflectionSetup.ViewSetup">
            <summary>
            Allows overriding everything you normally can
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ReflectionSetup.ClipOffset">
            <summary>
            Offset the reflection plane's clip plane by this much
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.ReflectionSetup.RenderBehind">
            <summary>
            If true we'll render the reflection even if we're behind the plane
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.ReflectionSetup.FallbackColor">
            <summary>
            If we can't render the reflection and this is set, we'll clear the render target to this color
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.RefractionSetup">
            <summary>
            Allows special setup for refraction, such as offsetting the clip plane
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.RefractionSetup.ViewSetup">
            <summary>
            Allows overriding everything you normally can
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.RefractionSetup.ClipOffset">
            <summary>
            Offset the reflection plane's clip plane by this much
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.RefractionSetup.RenderBehind">
            <summary>
            If true we'll render the reflection even if we're behind the plane
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.RefractionSetup.FallbackColor">
            <summary>
            If we can't render the reflection and this is set, we'll clear the render target to this color
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.RendererSetup">
            <summary>
            When manually rendering a Renderer this will let you override specific
            elements of that render. This means you can use most of the Renderer's
            properties, but override some without disturbing the Renderer itself.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.RendererSetup.Transform">
            <summary>
            Overrides the transform used for rendering
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.RendererSetup.Color">
            <summary>
            Overrides the color used for rendering
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.RendererSetup.Material">
            <summary>
            Overrides the material used for rendering
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.LayerFlags.DiscardColorBuffersStore">
            <summary>
            This layer does not need to store the results of its color target rendering 
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.LayerFlags.DiscardDepthStencilBufferStore">
            <summary>
            This layer does not need to store the results of its depth/stencil rendering
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.LayerFlags.SortAcrossPartitions">
            <summary>
            Similar to FullSort, but instead of using depth (or custom sort key), use default sorting
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.LayerFlags.NoOverrideDepthMaterial">
            <summary>
            Any layer marked IsDepthRenderingPass is subject to ShouldOverrideDepthMaterial.
            Setting this disables ShouldOverrideDepthMaterial for depth rendering.
            </summary>
        </member>
        <member name="F:Sandbox.Rendering.LayerFlags.UseVolumePyramidSpotlightGeo">
            <summary>
            Use pyramid geometry for light rendering instead of cone geo. Don't restrict to geometry
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.LightbinnerLayer.Setup(Sandbox.RenderAttributes)">
            <summary>
            Configures the lightbinner to react to mat_fullbright and more
            </summary>
            <param name="pipelineAttributes"></param>
        </member>
        <member name="T:Sandbox.Rendering.RenderLayer">
            <summary>
            ISceneLayer which is basically a render pass
            </summary>
            <remarks>Maybe we just call this RenderPass like every other engine.</remarks>
        </member>
        <member name="P:Sandbox.Rendering.RenderLayer.ShaderMode">
            <summary>
            Renders all matching scene objects with this shader mode if applicable
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.RenderLayer.ObjectFlagsRequired">
            <summary>
            Scene objects must have these flags to be included in the layer
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.RenderLayer.ObjectFlagsExcluded">
            <summary>
            Scene objects with these flags will be excluded from the layer
            </summary>
        </member>
        <member name="P:Sandbox.Rendering.RenderLayer.RenderTargetAttributes">
            <summary>
            Deferred render target attributes
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.RenderLayer.AddToView(NativeEngine.ISceneView,NativeEngine.RenderViewport)">
            <summary>
            Add to view
            </summary>
            <remarks>Passing viewport here might not be what we want</remarks>
        </member>
        <member name="T:Sandbox.Rendering.ProceduralRenderLayer">
            <summary>
            A render layer with a callback
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.RenderPipeline">
            <summary>
            Start moving the c++ render pipeline here
            It won't be the prettiest to start, but we can start simplifying afterwards
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.RenderPipeline.OnSceneViewSubmitted(NativeEngine.ISceneView)">
            <summary>
            Called once a view has been submitted, which means the entire render pipeline has executed and we don't need the object anymore.
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.ResourceState">
            <summary>
            Used to describe a GPU resources state for barrier transitions.
            </summary>
            <remarks>
            These match DX12's D3D12_RESOURCE_STATES as it's a nice high level description of resource states,
            which can be translated to lower level graphics APIs.
            </remarks>
        </member>
        <member name="F:Sandbox.Rendering.SceneObjectFlags.HideInCubemaps">
            <summary>
            Not rendered in cubemaps
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.TextureStreaming">
            <summary>
            Gives global access to the texture streaming system.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.TextureStreaming.ExecuteWithDisabled(System.Action)">
            <summary>
            Run a block of code with texture streaming disabled
            </summary>
        </member>
        <member name="T:Sandbox.Rendering.SpriteBatchSceneObject">
            <summary>
            This object renders every sprite registered to it in a single draw call. It takes care of sorting, sampling, and the whole pipeline regarding sprites.
            The SceneSpriteSystem is responsible for pushing sprites into this object depending on its properties.
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.SpriteBatchSceneObject.InitializeSpriteMesh">
            <summary>
            Create the initialize sprite mesh that will be instanced
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.SpriteBatchSceneObject.ResizeBuffers">
            <summary>
            Resizes GPU buffers to the nearest power of 2
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.SpriteBatchSceneObject.ResizeBuffers(System.Int32)">
            <summary>
            Resizes GPU buffers to accommodate the specified allocation size
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.SpriteBatchSceneObject.UploadOnHost">
            <summary>
            Copy host buffers onto GPU
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.SpriteBatchSceneObject.Sort">
            <summary>
            Performs a GPU bitonic sort
            </summary>
        </member>
        <member name="M:Sandbox.Rendering.SpriteBatchSceneObject.RenderSceneObject">
            <summary>
            Rendering logic of the sprites
            </summary>
        </member>
        <member name="T:Sandbox.ImageFormat">
            <summary>
            Format used when creating textures.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.RGBA8888">
            <summary>
            Four 8-bit components representing RGBA.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.ABGR8888">
            <summary>
            Four 8-bit components representing ABGR.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.RGB888">
            <summary>
            Three 8-bit components representing RGB.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.BGR888">
            <summary>
            Three 8-bit components representing BGR.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.RGB565">
            <summary>
            Three components representing RGB.
            Red and blue are 5 bit components, green is 6 bit totalling 16 bits.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.I8">
            <summary>
            Single 8-bit component representing luminance.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.IA88">
            <summary>
            Two 8-bit components representing luminance and alpha.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.A8">
            <summary>
            Single 8-bit component representing alpha.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.DXT1">
            <summary>
            Compressed texture format with no alpha.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.DXT3">
            <summary>
            Compressed texture format with alpha.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.DXT5">
            <summary>
            Compressed texture format with alpha, generally better than DXT3.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.RGBA16161616F">
            <summary>
            Four 16-bit float components representing RGBA.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.RGBA16161616">
            <summary>
            Four 16-bit integer components representing RGBA.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.RGB323232F">
            <summary>
            Three 32-bit float components representing RGB.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.R32F">
            <summary>
            Single 32-bit float component representing R.
            </summary>
        </member>
        <member name="F:Sandbox.ImageFormat.RGBA32323232F">
            <summary>
            Four 32-bit float components representing RGBA.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyType.Static">
            <inheritdoc cref="F:Sandbox.PhysicsMotionType.Static"/>
        </member>
        <member name="F:Sandbox.PhysicsBodyType.Keyframed">
            <inheritdoc cref="F:Sandbox.PhysicsMotionType.Keyframed"/>
        </member>
        <member name="F:Sandbox.PhysicsBodyType.Dynamic">
            <inheritdoc cref="F:Sandbox.PhysicsMotionType.Dynamic"/>
        </member>
        <member name="T:Sandbox.PhysicsMotionType">
            <summary>
            Represents <see cref="T:Sandbox.PhysicsBody">Physics body's</see> motion type.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsMotionType.Invalid">
            <summary>
            Invalid type.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsMotionType.Dynamic">
            <summary>
            Physically simulated body.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsMotionType.Static">
            <summary>
            Cannot move at all.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsMotionType.Keyframed">
            <summary>
            No physics simulation, but can be moved via setting position/rotation.
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.GizmoControls">
            <summary>
            Extendable helper to create common gizmos
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Position(System.String,Vector3,Vector3@,System.Nullable{Rotation},System.Single)">
            <summary>
            A front left up position movement widget. If widget was moved then will return true and out will return the new position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Arrow(System.String,Vector3,System.Single@,System.Single,System.Single,System.Single,System.Single,System.Single,System.String)">
            <summary>
            Draw an arrow - return move delta if interacted with
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.DragSquare(System.String,Vector2,Rotation,Vector3@,System.Action)">
            <summary>
            Manipulate a 2d value by moving on 2 axis
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.PushFixedScale(System.Nullable{System.Single})">
            <summary>
            Scope this before drawing a control to obey Settings.GizmoScale
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Rotate(System.String,Angles@)">
            <summary>
            A full 3d rotation gizmo. If rotated will return true and newValue will be the new value
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.RotateSingle(System.String,Color,System.Single@,System.Single)">
            <summary>
            A single rotation axis
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Scale(System.String,System.Single,System.Single@)">
            <summary>
            A front left up position movement widget. If widget was moved then will return true and out will return the new position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Scale(System.String,Vector3,Vector3@,System.Nullable{Rotation},System.Single)">
            <summary>
            A front left up position movement widget. If widget was moved then will return true and out will return the new position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Sphere(System.String,System.Single,System.Single@,Color)">
            <summary>
            A scalable sphere gizmo. Returns true if the gizmo was interacted with and outValue will return the new radius.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Control">
            <summary>
            Holds fully realized controls to manipulate some value
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Draw">
            <summary>
            Draw a shape using the gizmo library
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.GizmoDraw">
            <summary>
            Contains functions to add objects to the Gizmo Scene. This
            is an instantiable class so it's possible to add extensions.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.GizmoDraw.Color">
            <summary>
            The color to render the next object
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.GizmoDraw.IgnoreDepth">
            <summary>
            Ignore depth when drawing, draw on top of everything
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.GizmoDraw.LineThickness">
            <summary>
            The thickness of line drawings
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.GizmoDraw.CullBackfaces">
            <summary>
            Don't draw backfaces when drawing solids
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Model(System.String,Transform)">
            <summary>
            Draw a model
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Model(System.String)">
            <summary>
            Draw a model
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Model(Sandbox.Model,Transform)">
            <summary>
            Draw a model
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Model(Sandbox.Model)">
            <summary>
            Draw a model
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Particles(System.String,Transform,System.Nullable{System.Single})">
            <summary>
            Draw particles. Control points will be set to the transform position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Particles(System.String,System.Nullable{System.Single})">
            <summary>
            Draw particles. Control point 0 will be set to the transform position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Text(System.String,Transform,System.String,System.Single,Sandbox.TextFlag)">
            <summary>
            Draw text
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenText(System.String,Vector2,System.String,System.Single,Sandbox.TextFlag)">
            <summary>
            Draw text
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenText(System.String,Vector3,Vector2,System.String,System.Single,Sandbox.TextFlag)">
            <summary>
            Draw text on screen at a 3d position
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenRect(Sandbox.Rect,Color,Vector4,Color,Vector4,Sandbox.BlendMode)">
            <summary>
            Draw a rect, on the screen
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenText(System.String,Vector2,Vector2,System.Single,System.String,System.Single,Sandbox.TextFlag)">
            <summary>
            Draw text at an angle
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Plane(Vector3,Vector3)">
            <summary>
            Draw a plane
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Arrow(Vector3,Vector3,System.Single,System.Single)">
            <summary>
            Draw a line with an arrow on the end
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Grid(Sandbox.Gizmo.GridAxis,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws a grid
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Grid(Sandbox.Gizmo.GridAxis,Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Draws a grid
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Grid(Vector3,Sandbox.Gizmo.GridAxis,Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Draws a grid centered at a position
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.AddLineInternal(Sandbox.VertexSceneObject,Vector3@,Vector3@)">
            <summary>
            Adds a line to the current object, but also adds it as a potential hitbox
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Line(Vector3@,Vector3@)">
            <summary>
            Draw a line from a to b
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Line(Line@)">
            <summary>
            Draw a line from a to b
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Lines(System.Collections.Generic.IEnumerable{Line}@)">
            <summary>
            Draw a lines
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineBBox(BBox@)">
            <summary>
            Draw a bounding box
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineFrustum(Sandbox.Frustum@)">
            <summary>
            Draws a frustum.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineSphere(Vector3@,System.Single@,System.Int32@)">
            <summary>
            Draw a sphere made out of lines
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineSphere(Sandbox.Sphere@,System.Int32)">
            <summary>
            Draw a sphere made out of lines
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineCircle(Vector3@,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draw a sphere made out of lines
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineCylinder(Vector3,Vector3,System.Single,System.Single,System.Int32)">
            <summary>
            A cylinder
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineTriangle(Sandbox.Triangle@)">
            <summary>
            A triangle
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineTriangles(System.Collections.Generic.IEnumerable{Sandbox.Triangle}@)">
            <summary>
            Multiple triangles
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCone(Vector3,Vector3,System.Single,System.Nullable{System.Int32})">
            <summary>
            Draw a solid cone shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidBox(BBox)">
            <summary>
            Draw a solid box shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidTriangle(Sandbox.Triangle@)">
            <summary>
            Draw a solid triangle shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidTriangle(Vector3@,Vector3@,Vector3@)">
            <summary>
            Draw a solid triangle shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidTriangles(System.Collections.Generic.IEnumerable{Sandbox.Triangle}@)">
            <summary>
            Multiple solid triangles
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCircle(Vector3,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draw a filled circle
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidRing(Vector3,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draw a filled ring
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidSphere(Vector3,System.Single,System.Int32,System.Int32)">
            <summary>
            Draw a solid sphere shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCylinder(Vector3,Vector3,System.Single,System.Int32)">
            <summary>
            Draw a solid cylinder shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCapsule(Vector3,Vector3,System.Single,System.Int32,System.Int32)">
            <summary>
            Draw a solid capsule shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenBiasedHalfCircle(Vector3,System.Single)">
            <summary>
            Draws a half circle that tries its best to point towards the camera. This is used by
            the rotation widgets that bias towards the camera.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Sprite(Vector3,System.Single,System.String)">
            <summary>
            Draw a sprite.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Sprite(Vector3,System.Single,Sandbox.Texture)">
            <summary>
            Draw a sprite.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Sprite(Vector3,Vector2,Sandbox.Texture,System.Boolean)">
            <summary>
            Draw a sprite.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Sprite(Vector3,Vector2,Sandbox.Texture,System.Boolean,System.Single)">
            <summary>
            Draw a sprite.
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.Colors">
            <summary>
            Using pure primary colors is horrible. Lets make it easier to avoid.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Scope(System.String,Transform)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Scope(System.String,Vector3)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Scope(System.String,Vector3,Rotation,System.Single)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Scope(System.String)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.ObjectScope``1(``0,Transform)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetPositionOnPlane(Vector3,Vector3,Ray)">
            <summary>
            Get the distance from a point on a plane
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetMouseDelta(Vector3,Vector3)">
            <summary>
            Get the mouse delta at this current position
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetMouseDrag(Vector3,Vector3)">
            <summary>
            Get the mouse drag distance at this current position, assuming we are pressed
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetMouseDistance(Vector3,Vector3)">
            <summary>
            Get the distance from a point on a plane
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetMouseDistanceDelta(Vector3,Vector3)">
            <summary>
            Get the distance moved from (or towards) a position on a plane
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.CursorPosition">
            <summary>
            The current cursor position, in screen space
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.CursorMoveDelta">
            <summary>
            The delta of cursor movement between this frame and last, in screen space
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.CursorDragDelta">
            <summary>
            The delta of cursor movement between last press and now, in screen space.
            If left mouse isn't down, will return CursorMoveDelta
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.KeyboardModifiers">
            <summary>
            The current keyboard modifiers
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Snap(Vector3,Vector3)">
            <summary>
            Will snap this position, depending on the current snap settings and keys that are pressed.
            Will snap along if movement is detected along that axis. For example, if movement is 1,0,0 then we'll
            only snap on the x axis.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Snap(Angles,Angles)">
            <summary>
            Will snap this position, depending on the current snap settings and keys that are pressed.
            Will snap along if movement is detected along that axis. For example, if movement is 1,0,0 then we'll
            only snap on the x axis.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Nudge(Rotation,Vector2)">
            <summary>
            Will give you a nudge vector along the most aligned left and up axis of the rotation
            based on left/right/up/down direction and camera angle
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.CameraTransform">
            <summary>
            The cameras transform - in world space
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.LocalCameraTransform">
            <summary>
            The cameras transform - in local space
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.Inputs">
            <summary>
            The input state, allows interaction with Gizmos
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Inputs.IsHovered">
            <summary>
            True if the scene is being hovered by the mouse. False if the cursor is being used somewhere else
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.Instance">
            <summary>
            Holds the backend state for a Gizmo scope. This allows us to have multiple different gizmo
            states (for multiple views, multiple windows, game and editor) and push them as the current
            active state whenever needed.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Debug">
            <summary>
            If true, we'll draw some debug information
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.DebugHitboxes">
            <summary>
            If true we'll enable hitbox debugging
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.World">
            <summary>
            The SceneWorld this instance is writing to. This world exists only for this instance.
            You need to add this world to your camera for it to render (!)
            </summary>
        </member>
        <member name="F:Sandbox.Gizmo.Instance.Input">
            <summary>
            Input state. Should be setup before push.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.PreviousInput">
            <summary>
            The previous input state
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Pool">
            <summary>
            Last frame's objects that are available for reuse
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Entries">
            <summary>
            This frame's created (or re-used) objects
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Selection">
            <summary>
            This frame's created (or re-used) objects
            </summary>
        </member>
        <member name="F:Sandbox.Gizmo.Instance.scope">
            <summary>
            When a new scope is pushed, we store the old one and copy it to this.
            When it's disposed we restore this to the old one. This is the currently
            active scope.
            </summary>
        </member>
        <member name="F:Sandbox.Gizmo.Instance.lineScope">
            <summary>
            Holds the current hitbox line scope status
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.ControlMode">
            <summary>
            The current control mode. This is generally implementation specific. 
            We tend to use "mouse" and "firstperson".
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Settings">
            <summary>
            Some global settings accessible to the gizmos. Your implementation
            generally lets your users set up  these things to their preference, 
            and the gizmos should try to obey them.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.GetValue``1(System.String)">
            <summary>
            Generic storage for whatever you want to do. 
            You're responsible for not spamming into this and cleaning up after yourself.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.SetValue``1(System.String,``0)">
            <summary>
            Generic storage for whatever you want to do. 
            You're responsible for not spamming into this and cleaning up after yourself.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.Clear">
            <summary>
            Called when the scene changes and we don't want to inherit a bunch of values.
            We might want to just target some specific values here instead of clearing the log.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.LoopMilliseconds">
            <summary>
            how long the previous loop took, in milliseconds
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.Dispose">
            <summary>
            Destroy this instance, clean up any created resources/scene objects, destroy the world.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.Push">
            <summary>
            Push this instance as the global Gizmo state. All Gizmo calls during this scope
            will use this instance.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.Start">
            <summary>
            Called at the start of a 'frame'
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.End">
            <summary>
            Called at the end of a 'frame'
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.FindOrCreate``1(System.String,System.Func{``0})">
            <summary>
            Find a cached version of this sceneobject - if not found, create one
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.StompCursorPosition(Vector2)">
            <summary>
            Set all of the state's cursor positions to this value. This stomps previous values
            which will effectively clear any deltas. This should be used prior to starting a loop.
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.Pressed">
            <summary>
            Access to the currently pressed path information
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.Ray">
            <summary>
            The ray representing the cursor direction
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.This">
            <summary>
            True if the current gizmo scope is pressed
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.Any">
            <summary>
            True if any object is currently pressed
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.CursorDelta">
            <summary>
            The distance the cursor has travelled since press started
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.CursorPosition">
            <summary>
            The cursor position at the start of the press
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.IsActive">
            <summary>
            True if press is active. This generally means that the left mouse button is down
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.EditMode">
            <summary>
            How do we want to edit this? Usually something like "position", "rotation", "scale" etc
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.Selection">
            <summary>
            Do we want to let the user select things in the current mode?
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.ViewMode">
            <summary>
            What is the current view mode? 3d, 2d, ui?
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.GizmosEnabled">
            <summary>
            Are gizmos enabled?
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.GizmoScale">
            <summary>
            How big to show the gizmos
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.GridSpacing">
            <summary>
            Grid spacing
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.SnapToGrid">
            <summary>
            Snap positions to the grid
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.SnapToAngles">
            <summary>
            Snap angles
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.AngleSpacing">
            <summary>
            Grid spacing
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.GlobalSpace">
            <summary>
            Editing in local space
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.DebugActionGraphs">
            <summary>
            Should we show lines representing GameObject references in action graphs?
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.ScopeState">
            <summary>
            Whenever Gizmo.State is called, this is copied, stored and restored. This
            should hold whatever data is important to reset at the end of a scope. We
            should be really careful not to fill this with too much shit.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Hitbox">
            <summary>
            Allows creating a gizmo hitbox which will be interactable using the mouse (or vr deck2 super controller)
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.GizmoHitbox">
            <summary>
            Contains functions to add objects to the immediate mode Scene. This
            is an instantiable class so it's possible to add extensions.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.TrySetHovered(System.Single)">
            <summary>
            If this distance is closer than our previous best, this path will become the hovered path
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.TrySetHovered(Vector3)">
            <summary>
            If this distance is closer than our previous best, this path will become the hovered path
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.Sphere(Sandbox.Sphere)">
            <summary>
            A sphere hitbox
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.BBox(BBox)">
            <summary>
            A bounding box hitbox
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.Circle(Vector3,Vector3,System.Single,System.Single)">
            <summary>
            A 2d circle hitbox, on a plane
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.Model(Sandbox.Model)">
            <summary>
            A model hitbox
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.Sprite(Vector3,System.Single,System.Boolean)">
            <summary>
            A 2d sprite hitbox
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.LineScope">
            <summary>
            Start a line scope. Any drawn lines should become a hitbox during this scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.AddPotentialLine(Vector3@,Vector3@,System.Single)">
            <summary>
            If we're in a hitbox linescope we'll distance this test vs the current ray. If
            not, we'll return immediately.
            This is automatically called when rendering lines
            </summary>
        </member>
        <member name="T:Sandbox.GizmoInlineSceneObject">
            <summary>
            Draws anything
            </summary>
        </member>
        <member name="T:Sandbox.QuadSceneObject">
            <summary>
            Draws text in screenspace
            </summary>
        </member>
        <member name="T:Sandbox.TextSceneObject">
            <summary>
            Draws text in screenspace
            </summary>
        </member>
        <member name="P:Sandbox.TextSceneObject.AngleDegrees">
            <summary>
            this argument is short sighted and stupid, don't keep using it
            </summary>
        </member>
        <member name="T:Sandbox.VertexSceneObject">
            <summary>
            Draws a vertex object. Lines or solids usually.
            </summary>
        </member>
        <member name="T:Sandbox.ModelArchetype">
            <summary>
            Default model archetypes.
            These types are defined in "tools/model_archetypes.txt".
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.static_prop_model">
            <summary>
            A static model. It can still have collisions, but they do not have physics.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.animated_model">
            <summary>
            Animated model. Typically no physics.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.physics_prop_model">
            <summary>
            A generic physics enabled model.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.jointed_physics_model">
            <summary>
            A ragdoll type model.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.breakable_prop_model">
            <summary>
            A physics model that can be broken into other physics models.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.generic_actor_model">
            <summary>
            A generic actor/NPC model.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.Internal.BaseModelDocAttribute.AddTransform(System.Text.StringBuilder)">
            <summary>
            Internal, used to add multi level key-values.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.Internal.BaseModelDocAttribute.AddKeys(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Add generic key-values to the helper.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Bone">
            <summary>
            Internal name of the key that dictates which bone to use as parent for position/angles.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Attachment">
            <summary>
            Internal name of the key that dictates which attachment to use as parent for position/angles.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Origin">
            <summary>
            Internal name of the key to store position in, if set, allows the helper to be moved.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Angles">
            <summary>
            Internal name of the key to store angles in, allows the helper to be rotated.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.GameDataAttribute">
            <summary>
            Indicates that this class/struct should be available as GenericGameData node in ModelDoc
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.GameDataAttribute.AllowMultiple">
            <summary>
            Indicates that this type compiles as list, rather than a single entry in the model.
            This will also affect how you retrieve this data via Model.GetData().
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.AxisAttribute">
            <summary>
            Draws 3 line axis visualization, which can set up to be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.AxisAttribute.Enabled">
            <summary>
            Internal name of a boolean key that dictates whether this helper should draw or not. If unset, will draw always.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.AxisAttribute.ParentLine">
            <summary>
            If set to true, when the node is selected a line will be drawn from the helper to the parent attachment/bone.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.BoxAttribute">
            <summary>
            Draws a box, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.BoxAttribute.HideSurface">
            <summary>
            If set, the semi-transparent box "walls" will not be drawn.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.BoxAttribute.ShowGizmos">
            <summary>
            If set, gizmos will be shown in transform mode to quickly move/scale the box.
            For "dimensions" box Origin/Angles must be set.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.BoxAttribute.#ctor(System.String)">
            <summary>
            Store the box's dimensions in a single key, acting as (maxs-mins) which assumes the box's center is at the models origin.
            The box's center can be set up to be movable via "Origin" property and rotatable via "Angles" property.
            </summary>
            <param name="dimensionsKey">Internal name of a key on the node that will store the dimensions of the box.</param>
        </member>
        <member name="M:Sandbox.ModelEditor.BoxAttribute.#ctor(System.String,System.String)">
            <summary>
            Store the box's dimensions in 2 keys as Mins and Maxs. This type cannot be rotated.
            </summary>
            <param name="minsKey">Internal name of a key on the node that will store the mins of the box.</param>
            <param name="maxsKey">Internal name of a key on the node that will store the maxs of the box.</param>
        </member>
        <member name="T:Sandbox.ModelEditor.SphereAttribute">
            <summary>
            Draws a sphere, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.SphereAttribute.HideSurface">
            <summary>
            If set, the semi-transparent sphere "wall"/surface will not be drawn.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.CapsuleAttribute">
            <summary>
            Draws a capsule, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.CapsuleAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            This variation has 1 radius for both points.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.CapsuleAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            This variation has independent radius for each point.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.CylinderAttribute">
            <summary>
            Draws a cylinder, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.CylinderAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            This variation has 1 radius for both points.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.CylinderAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            This variation has independent radius for each point.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.HingeJointAttribute">
            <summary>
            A helper that draws axis of rotation and angle limit of a hinge joint.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HingeJointAttribute.EnableLimit">
            <summary>
            Key name that dictates whether the hinge limit is enabled or not.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HingeJointAttribute.MinAngle">
            <summary>
            Key name that stores the minimum angle value for the revolute joint.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HingeJointAttribute.MaxAngle">
            <summary>
            Key name that stores the maximum angle value for the revolute joint.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.EditorWidgetAttribute">
            <summary>
            Adds a custom editor widget to the game data node.
            Currently only 1 option is available - "HandPosePairEditor"
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.HandPoseAttribute">
            <summary>
            A helper used for VR hand purposes.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Origin">
            <summary>
            Internal name of the key to store position in.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Angles">
            <summary>
            Internal name of the key to store angles in.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Model">
            <summary>
            Path to a model to use.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.IsRightHand">
            <summary>
            Whether this helper represents the right hand or not.
            This decides the names of the bones the helper will try to use.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Label">
            <summary>
            Text label this helper will have when hovered/selected.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Enabled">
            <summary>
            Internal name of the key that controls whether this helper is visible or not.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.HandPoseAttribute.#ctor(System.String,System.String,System.String,System.Boolean)">
            <param name="originKey">Internal name of the key to store position in.</param>
            <param name="anglesKey">Internal name of the key to store angles in.</param>
            <param name="model">Path to a model to use.</param>
            <param name="isRightHand">Whether this helper represents the right hand or not. This decides the names of the bones the helper will try to use.</param>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.BoneFrom">
            <summary>
            Internal name of the key that dictates which bone to use as parent for start position.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.AttachmentFrom">
            <summary>
            Internal name of the key that dictates which attachment to use as parent for start position.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.OriginFrom">
            <summary>
            Internal name of the key to read line start position from.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.BoneTo">
            <summary>
            Internal name of the key that dictates which bone to use as parent for end position.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.AttachmentTo">
            <summary>
            Internal name of the key that dictates which attachment to use as parent for end position.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.OriginTo">
            <summary>
            Internal name of the key to read line end position from.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.Enabled">
            <summary>
            Internal name of the key that controls whether this helper is visible or not.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.Color">
            <summary>
            A string formatted color for this helper. Format is "255 255 255"
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.Width">
            <summary>
            The width of the line helper
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.ScaleBoneRelativeAttribute">
            <summary>
            Scales the vector with the "ScaleAndMirror" node, relative to associated bone.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.ScaleWorldAttribute">
            <summary>
            Scales the vector with the "ScaleAndMirror" node.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelBreakPiece">
            <summary>
            Defines a single breakable prop gib.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelPropData">
            <summary>
            Generic prop settings. Support for this depends on the entity.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.BakeLighting">
            <summary>
            When this model is used as prop_static, it will bake lighting by default depending on this value.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.Health">
            <summary>
            When this model is used as prop_physics, it's health will be set to this value.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.Flammable">
            <summary>
            If true well treat this prop as flammable, meaning it can catch fire and burn.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.Explosive">
            <summary>
            If true we'll explode this prop when it's destroyed
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.ExplosionDamage">
            <summary>
            Amount of damage to do at the center on the explosion. It will falloff over distance.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.ExplosionRadius">
            <summary>
            Range of explosion's damage.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.ExplosionForce">
            <summary>
            Scale of the force applied to entities damaged by the explosion and the models break pieces.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelEye">
            <summary>
            Defines an eye on a character model.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelNavData">
            <summary>
            Carries navigation related data.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelNavData.Avoid">
            <summary>
            During map compile this model would mark its volume as an area that should be avoided by AI.
            </summary>
        </member>
        <member name="T:Sandbox.AutoGenerateAttribute">
            <summary>
            Indicates that this type should generate meta data. Tagging your asset with this will
            mean that the .asset file is automatically generated - which means you don't have to do that.
            </summary>
        </member>
        <member name="T:Sandbox.FGDTypeAttribute">
            <summary>
            Overrides the auto generated FGD type.
            </summary>
        </member>
        <member name="M:Sandbox.FGDTypeAttribute.#ctor(System.String,System.String,System.String)">
            <param name="type">The FGD type override.</param>
            <param name="editor">The name of a custom editor to use for this property.</param>
            <param name="editorArgs">Arguments for given editor override. Format depends on each editor.</param>
        </member>
        <member name="T:Sandbox.ResourceTypeAttribute">
            <summary>
            Allows you to specify a string property as a resource type. This will
            give the property a resource finder. Type should be the file extension, ie "vmdl"
            </summary>
        </member>
        <member name="T:Sandbox.BitFlagsAttribute">
            <summary>
            This choices type is bitflags, so we should be able to choose more than one option at a time.
            </summary>
            <remarks>
            TODO: Once this is no longer used in assets it can be deleted.
                  It should be derived from [System.Flags]
            </remarks>
        </member>
        <member name="T:Sandbox.AssetPathAttribute">
            <summary>
            When added to a string property, will becomes a selector for AssetTypeExtension
            </summary>
        </member>
        <member name="T:Sandbox.ImageAssetPathAttribute">
            <summary>
            When added to a string property, will become an image string selector
            </summary>
        </member>
        <member name="T:Sandbox.FilePathAttribute">
            <summary>
            When added to a string property, will become a file picker for the given extension (or all by default)
            </summary>
        </member>
        <member name="P:Sandbox.FilePathAttribute.Extension">
            <summary>
            The extension to filter by. If empty, all files are shown.
            Can be a comma separated list of extensions, or a single extension.
            </summary>
        </member>
        <member name="T:Sandbox.TextureImagePathAttribute">
            <summary>
            When added to a string property, will allow selection of anything that a Texture can be
            </summary>
        </member>
        <member name="T:Sandbox.MapAssetPathAttribute">
            <summary>
            When added to a string property, will become a map string selector
            </summary>
        </member>
        <member name="T:Sandbox.Clothing">
            <summary>
            Describes an item of clothing and implicitly which other items it can be worn with
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HumanSkinModel">
            <summary>
            Model to replace the human skin with
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HumanSkinMaterial">
            <summary>
            Replace skin with this
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HumanEyesMaterial">
            <summary>
            Replace skin with this
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HumanSkinBodyGroups">
            <summary>
            Bodygroup on the model to choose
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HumanSkinMaterialGroup">
            <summary>
            Bodygroup on the model to choose
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HumanSkinTags">
            <summary>
            Allows adding tags for this skin, ie "female". This affects which alternative clothing models are used with it.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Title">
            <summary>
            Name of the clothing to show in UI.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Subtitle">
            <summary>
            A subtitle for this clothing piece.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Category">
            <summary>
            What kind of clothing this is?
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.ConditionalModels">
            <summary>
            A list of conditional models.
            (key) = tag(s), (value) = model
            </summary>
        </member>
        <member name="M:Sandbox.Clothing.GetModel(System.Collections.Generic.IEnumerable{Sandbox.Clothing},Sandbox.TagSet)">
            <summary>
             Tries to get the model for this current clothing. Takes into account any conditional model for other clothing.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.SubCategory">
            <summary>
            This should be a single word to describe the subcategory, and should match any other items you want to categorize in the same bunch. The work will be tokenized so it can become localized.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Parent">
            <summary>
            The clothing to parent this too.  It will be displayed as a variation of its parent
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Model">
            <summary>
            The model to bonemerge to the player when this clothing is equipped.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HumanAltModel">
            <summary>
            The model to bonemerge to the human player when this clothing is equipped.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HumanAltFemaleModel">
            <summary>
            The model to bonemerge to the human player when this clothing is equipped.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.SkinMaterial">
            <summary>
            Replace the skin with this material
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.EyesMaterial">
            <summary>
            Replace the eyes with this material
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.MaterialGroup">
            <summary>
            Which material group of the model to use.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HeelHeight">
            <summary>
            Do we need to lift the heel up?
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.SlotsUnder">
            <summary>
            Which slots this clothing takes on "inner" layer.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.SlotsOver">
            <summary>
            Which slots this clothing takes on "outer" layer.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HideBody">
            <summary>
            Which body parts of the player model should not show when this clothing is equipped.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.SteamItemDefinitionId">
            <summary>
            The Steam Item Definition ID for this clothing item, if it's an inventory item
            </summary>
        </member>
        <member name="M:Sandbox.Clothing.HasPermissions">
            <summary>
            Can we wear this item?
            </summary>
        </member>
        <member name="M:Sandbox.Clothing.CanBeWornWith(Sandbox.Clothing)">
            <summary>
            Return true if this item of clothing can be worn with the target item, at the same time.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Icon">
            <summary>
            Icon for this clothing piece.
            </summary>
        </member>
        <member name="M:Sandbox.Clothing.DressSceneObject(Sandbox.SceneModel,System.Collections.Generic.IEnumerable{Sandbox.Clothing})">
            <summary>
            Dress this sceneobject with the passed clothes. Return the created clothing.
            </summary>
        </member>
        <member name="M:Sandbox.Clothing.IsPlaceholder">
            <summary>
            Is this just a SteamItemDefinitionId. Usually created in the avatar editing scenario.
            </summary>
        </member>
        <member name="T:Sandbox.ClothingContainer">
            <summary>
            Holds a collection of clothing items. Won't let you add items that aren't compatible.
            </summary>
            <summary>
            Holds a collection of clothing items. Won't let you add items that aren't compatible.
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.ClothingEntry.Clothing">
            <summary>
            A direct reference to the clothing item
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.ClothingEntry.ItemDefinitionId">
            <summary>
            If this is a Steam Inventory Item then this is the item definition id. This usually means
            we'll look up the clothing item from the workshop.
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.ClothingEntry.Tint">
            <summary>
            Used to select a tint for the item. The gradients are defined in the item.
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.ClothingEntry.Bone">
            <summary>
            If this item is manually placed, this is the bone we're attached to
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.ClothingEntry.Transform">
            <summary>
            If this item is manually placed, this is the offset relative to the bone
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.DisplayName">
            <summary>
            A user set name for this setup
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.Height">
            <summary>
            The avatar's height. Default is 0.5f.
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.Age">
            <summary>
            The avatar's age. Default is 0.0f. We'll pick a skin based on this.
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.Tint">
            <summary>
            For the citizen the skin color is dynamic, based on a gradient. This is 0-1.
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.PrefersHuman">
            <summary>
            If true, this avatar prefers to use a human model when possible
            </summary>
        </member>
        <member name="F:Sandbox.ClothingContainer.Clothing">
            <summary>
            A list of clothing items the avatar is wearing
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Normalize">
            <summary>
            Restrict things like Height to their sensible limits
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Toggle(Sandbox.Clothing)">
            <summary>
            Add a clothing item if we don't already contain it, else remove it
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Add(Sandbox.Clothing)">
            <summary>
            Add clothing item
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Add(Sandbox.ClothingContainer.ClothingEntry)">
            <summary>
            Add clothing item
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.AddRange(System.Collections.Generic.IEnumerable{Sandbox.ClothingContainer.ClothingEntry})">
            <summary>
            Add clothing items
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.FindEntry(Sandbox.Clothing)">
            <summary>
            Find a clothing entry matching this clothing item
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Remove(Sandbox.Clothing)">
            <summary>
            Remove clothing item
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Has(Sandbox.Clothing)">
            <summary>
            Returns true if we have this clothing item
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.GetBodyGroups">
            <summary>
            Return a list of bodygroups and what their value should be
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.GetBodyGroups(System.Collections.Generic.IEnumerable{Sandbox.Clothing})">
            <summary>
            Return a list of bodygroups and what their value should be
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Serialize">
            <summary>
            Serialize to Json
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Deserialize(System.String)">
            <summary>
            Deserialize from Json
            </summary>
        </member>
        <member name="T:Sandbox.ClothingContainer.Entry">
            <summary>
            Used for serialization
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.Entry.Id">
            <summary>
            The resource id of this item. This means it's on disk somewhere.
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.Entry.ItemId">
            <summary>
            The Steam Inventory Item Definition Id. This means we should look up the item from the workshop.
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.Entry.Tint">
            <summary>
            Tint variable used to evaluate the model tint color gradient
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.CreateFromJson(System.String)">
            <summary>
            Create the container from json definitions
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.CreateFromLocalUser">
            <summary>
            Create the container from the local user's setup
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.ApplyAsync(Sandbox.SkinnedModelRenderer,System.Threading.CancellationToken)">
            <summary>
            Dresses a skinned model with an outfit. Will apply all the clothes it can immediately, then download any missing clothing.
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Apply(Sandbox.SkinnedModelRenderer)">
            <summary>
            Dress a skinned model renderer with an outfit. Doesn't download missing clothing.
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Reset(Sandbox.SkinnedModelRenderer)">
            <summary>
            Clear the outfit from this model, make it named
            </summary>
        </member>
        <member name="T:Sandbox.WorkshopItemMetaData">
            <summary>
            Some metadata we'll pack into a workshop submission when publishing.
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsMe">
            <summary>
            Returns true if this friend is the local user
            </summary>
        </member>
        <member name="P:Sandbox.Friend.Id">
            <summary>
            The friend's Steam Id
            </summary>
        </member>
        <member name="P:Sandbox.Friend.Name">
            <summary>
            The friend's name
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsOnline">
            <summary>
            Returns true if your friend is online
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsFriend">
            <summary>
            Returns true if this user is your friend
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsAway">
            <summary>
            Returns true if your friend is away
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsBusy">
            <summary>
            Returns true if this friend is marked as busy
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsSnoozing">
            <summary>
            Returns true if this friend is marked as snoozing
            </summary>
        </member>
        <member name="M:Sandbox.Friend.GetRichPresence(System.String)">
            <summary>
            Returns a string that was possibly set by rich presence
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsPlayingThisGame">
            <summary>
            Returns true if they're playing this game
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsPlayingAGame">
            <summary>
            Returns true if they're playing any game
            </summary>
        </member>
        <member name="M:Sandbox.Friend.OpenInOverlay">
            <summary>
            Opens the Steam overlay web browser to their user profile.
            </summary>
        </member>
        <member name="M:Sandbox.Friend.OpenAddFriendOverlay">
            <summary>
            Opens the Steam overlay with a popup that allows the local Steam user to confirm whether to add this user to their Steam friends list.
            </summary>
        </member>
        <member name="P:Sandbox.Menu.LoadingProgress.Fraction">
            <summary>
            A value between 0 and 1, to show a progress bar
            </summary>
        </member>
        <member name="P:Sandbox.Menu.LoadingProgress.Mbps">
            <summary>
            The current transfer rate in Megabits per second. 0 is none.
            </summary>
        </member>
        <member name="P:Sandbox.Menu.LoadingProgress.Percent">
            <summary>
            Delta multipled by 100
            </summary>
        </member>
        <member name="P:Sandbox.Menu.LoadingProgress.TotalSize">
            <summary>
            The total size of what we're trying to download
            </summary>
        </member>
        <member name="T:Sandbox.DataModel.GameSetting">
            <summary>
            A <see cref="T:Sandbox.ConVarAttribute"/> that has been marked with <see cref="F:Sandbox.ConVarFlags.GameSetting"/>
            This is stored as project metadata so we can set up a game without loading it.
            </summary>
        </member>
        <member name="M:Sandbox.DataModel.GameSetting.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            A <see cref="T:Sandbox.ConVarAttribute"/> that has been marked with <see cref="F:Sandbox.ConVarFlags.GameSetting"/>
            This is stored as project metadata so we can set up a game without loading it.
            </summary>
        </member>
        <member name="T:Sandbox.DataModel.ProjectConfig">
            <summary>
            Configuration of a <see cref="T:Sandbox.Project"/>.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Directory">
            <summary>
            The directory housing this addon (TODO)
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.AssetsDirectory">
            <summary>
            The directory housing this addon (TODO)
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Title">
            <summary>
            The human readable title, for example "Sandbox", "Counter-Strike"
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Type">
            <summary>
            The type of addon. Current valid values are "game"
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Org">
            <summary>
            The ident of the org that owns this addon. For example "facepunch", "valve".
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Ident">
            <summary>
            The ident of this addon. For example "sandbox", "cs" or "dm98"
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.PackageType">
            <summary>
            Type of the package.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.FullIdent">
            <summary>
            Returns a combination of Org and Ident - for example "facepunch.sandbox" or "valve.cs".
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Schema">
            <summary>
            The version of the addon file. Allows us to upgrade internally.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.IncludeSourceFiles">
            <summary>
            If true then we'll include all the source files
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Resources">
            <summary>
            A list of paths in which to look for extra assets to upload with the addon. Note that compiled asset files are automatically included.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.PackageReferences">
            <summary>
            A list of packages that this package depends on. These should be installed alongside this package.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.EditorReferences">
            <summary>
            A list of packages that this package uses but there is no need to install. For example, a map package might use
            a model package - but there is no need to download that model package because any usage will organically be included
            in the manifest. However, when loading this item in the editor, it'd make sense to install these 'cloud' packages.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Mounts">
            <summary>
            A list of mounts that are required
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.DistinctPackageReferences">
            <summary>
            Contains unique elements from <see cref="P:Sandbox.DataModel.ProjectConfig.PackageReferences"/>, along with any implicit package references.
            An example implicit reference is the parent package of an addon.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.IsStandaloneOnly">
            <summary>
            Whether or not this project is standalone-only, and supports disabling the whitelist, compiling with /unsafe, etc.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Metadata">
            <summary>
            Custom key-value storage for this project.
            </summary>
        </member>
        <member name="M:Sandbox.DataModel.ProjectConfig.ToJson">
            <summary>
            Serialize the entire config to a JSON string.
            </summary>
        </member>
        <member name="M:Sandbox.DataModel.ProjectConfig.TryGetMeta``1(System.String,``0@)">
            <summary>
            Try to get a value at given key in <see cref="P:Sandbox.DataModel.ProjectConfig.Metadata"/>.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="keyname">The key to retrieve the value of.</param>
            <param name="outvalue">The value, if it was present in the metadata storage.</param>
            <returns>Whether the value was successfully retrieved.</returns>
        </member>
        <member name="M:Sandbox.DataModel.ProjectConfig.GetMetaOrDefault``1(System.String,``0)">
            <summary>
            Get the package's meta value. If it's missing or the wrong type then use the default value.
            </summary>
        </member>
        <member name="M:Sandbox.DataModel.ProjectConfig.SetMeta(System.String,System.Object)">
            <summary>
            Store custom data at given key in the <see cref="P:Sandbox.DataModel.ProjectConfig.Metadata"/>.
            </summary>
            <param name="keyname">The key for the data.</param>
            <param name="outvalue">The data itself to store.</param>
            <returns>Always true.</returns>
        </member>
        <member name="T:Sandbox.Game">
            <summary>
            Provides global access to core game state, utilities, and operations for S&amp;box.
            <para>
            The <see cref="T:Sandbox.Game"/> class exposes static properties and methods to query and control the running game,
            such as checking if the game is running, getting your steamid, taking screenshots, and managing game sessions.
            </para>
            </summary>
            <example>
            <code>
            // Check if the game is running in the editor
            if (Game.IsEditor)
            {
                // Perform editor-specific logic
            }
            </code>
            </example>
            <example>
            <code>
            // Take a screenshot
            Game.TakeScreenshot();
            </code>
            </example>
            <seealso cref="T:Sandbox.Application"/>
        </member>
        <member name="P:Sandbox.Game.InputContext">
            <summary>
            The input context for this context (menu, gamemenu, client)
            </summary>
        </member>
        <member name="P:Sandbox.Game.AppId">
            <summary>
            Steam AppId of S&amp;box.
            </summary>
        </member>
        <member name="P:Sandbox.Game.InGame">
            <summary>
            Return true if we're in a game (ie, not in the main menu)
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsEditor">
            <summary>
            Returns true if the game is running with the editor enabled
            </summary>
        </member>
        <member name="P:Sandbox.Game.Ident">
            <summary>
            Returns the current game's ident - ie facepunch.sandbox
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsMainMenuVisible">
            <summary>
            Returns true if the main menu is visible. Note that this will work serverside too but will only
            return the state of the host.
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsRecordingVideo">
            <summary>
            True if we're currently recording a video (using the video command, or F6)
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsClosing">
            <summary>
            Set to true when the game is closing
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsRunningInVR">
            <summary>
            Return true if we're running in VR
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsRunningOnHandheld">
            <summary>
            Return true if we're running on a handheld device (the deck). Will always be false serverside.
            </summary>
        </member>
        <member name="P:Sandbox.Game.Random">
            <summary>
            A shared random that is automatically seeded on tick
            </summary>
        </member>
        <member name="M:Sandbox.Game.SetRandomSeed(System.Int32)">
            <summary>
            Set the seed for Game.Random
            </summary>
        </member>
        <member name="P:Sandbox.Game.SteamId">
            <summary>
            Your SteamId
            </summary>
        </member>
        <member name="M:Sandbox.Game.CreateWebSurface">
            <summary>
            Create a limited web surface
            </summary>
        </member>
        <member name="M:Sandbox.Game.Disconnect">
            <summary>
            Disconnect from the current game session
            </summary>
        </member>
        <member name="P:Sandbox.Game.PhysicsTrace">
            <summary>
            Trace against the physics in the current scene
            </summary>
        </member>
        <member name="P:Sandbox.Game.SceneTrace">
            <summary>
            Trace against the physics and hitboxes in the current scene
            </summary>
        </member>
        <member name="M:Sandbox.Game.Close">
            <summary>
            Close the current game.
            </summary>
        </member>
        <member name="M:Sandbox.Game.Load(System.String,System.Boolean)">
            <summary>
            Load a game. You can configure the new game with LaunchArguments before calling this.
            </summary>
        </member>
        <member name="M:Sandbox.Game.TakeScreenshot">
            <summary>
            Capture a screenshot. Saves it in Steam.
            </summary>
        </member>
        <member name="P:Sandbox.Game.CheatsEnabled">
            <summary>
            This has to be in Game.dll so the codegen will get generated for it
            </summary>
        </member>
        <member name="P:Sandbox.Game.TypeLibrary">
            <summary>
            Provides access to the global <see cref="T:Sandbox.Internal.TypeLibrary"/> for the current game context.
            <para>
            The <c>TypeLibrary</c> is a runtime reflection system that describes types, their members, and relationships in the game and engine assemblies. It allows you to
            find and create types by name and id. It's basically a sandboxed version of the .net reflection system.
            </para>
            </summary>
        </member>
        <member name="P:Sandbox.Game.Cookies">
            <summary>
            Allows access to the cookies for the current game. The cookies are used to store persistent data across game sessions, such as user preferences or session data.
            Internally the cookies are encoded to JSON and stored in a file on disk.
            </summary>
        </member>
        <member name="P:Sandbox.Game.Language">
            <summary>
            Lets you get translated phrases from the localization system
            </summary>
        </member>
        <member name="P:Sandbox.Game.NodeLibrary">
            <summary>
            A library of node definitions for action graphs.
            </summary>
        </member>
        <member name="M:Sandbox.Game.InitUnitTest``1">
            <summary>
            Initialize for a unit test
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsMenu">
            <summary>
            Returns true only when current code is running in the menu.
            </summary>
        </member>
        <member name="T:Sandbox.Game.Overlay">
             <summary>
             Provides static methods for displaying various modal overlays in the game UI.
             <para>
             The <see cref="T:Sandbox.Game.Overlay"/> class allows you to open modals for packages, maps, news, organizations, reviews, friends lists, server lists, settings, input bindings, and player profiles.
             It serves as a central point for invoking user interface overlays that interact with core game and community features.
             </para>
             </summary>
             <example>
             <code>
             // Show a modal for a specific game package
             Game.Overlay.ShowGameModal("facepunch.sandbox");
            
             // Check if any overlay is currently open
             if (Game.Overlay.IsOpen)
             {
                 // Pause game logic or input
             }
             </code>
             </example>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowGameModal(System.String)">
            <summary>
            Opens a modal for the specified game package
            </summary>
            <param name="packageIdent"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowMapModal(System.String)">
            <summary>
            Opens a modal for the specified map package
            </summary>
            <param name="packageIdent"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowPackageModal(System.String)">
            <summary>
            Opens a modal for the specified package
            </summary>
            <param name="ident"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowPackageModal(System.String,System.String)">
            <summary>
            Opens a modal for the specified package on the specified page
            </summary>
            <param name="ident"></param>
            <param name="page"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowNewsModal(Sandbox.Services.News)">
            <summary>
            Opens a modal for the news item
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowOrganizationModal(Sandbox.Package.Organization)">
            <summary>
            Opens a modal for the specified organization. 
            This is most likely called from a Package - so get the organization from there.
            </summary>
            <param name="org"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowReviewModal(Sandbox.Package)">
            <summary>
            Opens a modal to review the specified package
            </summary>
            <param name="package"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowPackageSelector(System.String,System.Action{Sandbox.Package},System.Action{System.String})">
            <summary>
            Opens a modal for selecting a package
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowFriendsList(Sandbox.Modals.FriendsListModalOptions)">
            <summary>
            Opens a modal that shows the user's friends list
            </summary>
            <param name="options"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowServerList(Sandbox.Modals.ServerListConfig@)">
            <summary>
            Opens a modal that shows a list of active servers
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowSettingsModal">
            <summary>
            Opens a modal that lets you modify your settings
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowBinds">
            <summary>
            Opens a modal that lets you view and rebind game input actions.
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.CreateGame(Sandbox.Modals.CreateGameOptions@)">
            <summary>
            Opens a modal to create a multiplayer game. We use this in the menu when you click "Create Game"
            and the game has options.
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowPlayer(Sandbox.SteamId,System.String)">
            <summary>
            View a selected user's profile
            </summary>
        </member>
        <member name="P:Sandbox.Game.Overlay.IsOpen">
            <summary>
            Returns true if any overlay is open
            </summary>
        </member>
        <member name="P:Sandbox.Game.Overlay.IsPauseMenuOpen">
            <summary>
            Returns true if the pause menu overlay is open
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsPlaying">
            <summary>
            Indicates whether the game is currently running and actively playing a scene.
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsPaused">
            <summary>
            Indicates whether the game is currently paused.
            </summary>
        </member>
        <member name="P:Sandbox.Game.ActiveScene">
            <summary>
            The current scene that is being played.
            </summary>
        </member>
        <member name="M:Sandbox.Game.ChangeScene(Sandbox.SceneLoadOptions)">
            <summary>
            Change the active scene and optionally bring all connected clients to
            the new scene (broadcast the scene change.) If we're in a networking
            session, then only the host can change the scene.
            </summary>
            <param name="options">The <see cref="T:Sandbox.SceneLoadOptions"/> to use which also specifies which scene to load.</param>
            <returns>Whether the scene was changed successfully.</returns>
        </member>
        <member name="T:Sandbox.IGameInstance">
            <summary>
            Todo: make internal - the only thing using ir right now is the binds system
            </summary>
        </member>
        <member name="M:Sandbox.IGameInstance.OnLoadingFinished">
            <summary>
            Called after all loading is done, right before we enter the game
            </summary>
        </member>
        <member name="P:Sandbox.IGameInstance.IsLoading">
            <summary>
            True after the game is fully loaded
            </summary>
        </member>
        <member name="T:Sandbox.LaunchArguments">
            <summary>
            These are arguments that were set when launching the current game.
            This is used to pre-configure the game from the menu
            </summary>
        </member>
        <member name="P:Sandbox.LaunchArguments.Map">
            <summary>
            The map to start with. It's really up to the game to use this
            </summary>
        </member>
        <member name="P:Sandbox.LaunchArguments.MaxPlayers">
            <summary>
            Preferred max players for multiplayer games. Used by games, but not enforced.
            </summary>
        </member>
        <member name="P:Sandbox.LaunchArguments.Privacy">
            <summary>
            Default privacy for lobbies created on game start.
            </summary>
        </member>
        <member name="P:Sandbox.LaunchArguments.GameSettings">
            <summary>
            The game settings to apply on join. These are a list of convars.
            </summary>
        </member>
        <member name="P:Sandbox.LaunchArguments.ServerName">
            <summary>
            The hostname for the server.
            </summary>
        </member>
        <member name="M:Sandbox.LaunchArguments.Reset">
            <summary>
            Should be called when leaving a game to set the properties back to default. We need to be
            aware and prevent these leaking between games.
            </summary>
        </member>
        <member name="T:Sandbox.LoadingScreen">
            <summary>
            Holds metadata and raw data relating to a Saved Game.
            </summary>
        </member>
        <member name="P:Sandbox.LoadingScreen.Title">
            <summary>
            A title to show
            </summary>
        </member>
        <member name="P:Sandbox.LoadingScreen.Subtitle">
            <summary>
            A subtitle to show
            </summary>
        </member>
        <member name="P:Sandbox.LoadingScreen.Media">
            <summary>
            A URL or filepath to show as the background image.
            </summary>
        </member>
        <member name="T:Sandbox.LobbyManager">
            <summary>
            A class to orchestrate lobbies, globally.
            </summary>
        </member>
        <member name="P:Sandbox.LobbyManager.ActiveLobbies">
            <summary>
            A low level list of lobbies we're in
            </summary>
        </member>
        <member name="M:Sandbox.LobbyManager.OnLeave(System.UInt64)">
            <summary>
            Note there's not a callback for this afaik, so we call this manually
            </summary>
        </member>
        <member name="P:Sandbox.Map.PhysicsGroup">
            <summary>
            The world physics objects
            </summary>
        </member>
        <member name="P:Sandbox.Map.SceneMap">
            <summary>
            The world geometry;
            </summary>
        </member>
        <member name="T:Sandbox.MapLoader.ObjectEntry">
            <summary>
            Holds key values for the map object
            </summary>
        </member>
        <member name="M:Sandbox.MapLoader.CreateObject(Sandbox.MapLoader.ObjectEntry)">
            <summary>
            Create an object from a serialized object entry
            </summary>
        </member>
        <member name="M:Sandbox.Mounting.Directory.LoadAssemblies">
            <summary>
            Load the assemblies and collect sources. That's all.
            </summary>
        </member>
        <member name="M:Sandbox.Mounting.Directory.GetAll">
            <summary>
            Get information about all the current mounts
            </summary>
        </member>
        <member name="M:Sandbox.Mounting.Directory.Get(System.String)">
            <summary>
            Get information about all the current mounts
            </summary>
        </member>
        <member name="M:Sandbox.Mounting.Directory.Mount(System.String)">
            <summary>
            Mount this game if we can. Returns null if it can't be mounted, or the mount object if it can.
            If we're already mounted, will just return the mount straight away.
            </summary>
        </member>
        <member name="M:Sandbox.Mounting.Directory.SetMountState(System.String,System.Boolean)">
            <summary>
            Set mounted or not mounted. Called by user via editor.
            </summary>
        </member>
        <member name="M:Sandbox.Mounting.Directory.TryMountFilesystem(System.String)">
            <summary>
            If /mount/{x}/assets exists, add it to our filesystem
            </summary>
        </member>
        <member name="T:Sandbox.Mounting.MountInfo">
            <summary>
            Information about a single mount
            </summary>
        </member>
        <member name="P:Sandbox.Mounting.MountInfo.Ident">
            <summary>
            A short, lowercase string that will be used to uniquely identify this asset source
            </summary>
        </member>
        <member name="P:Sandbox.Mounting.MountInfo.Title">
            <summary>
            The display name of this
            </summary>
        </member>
        <member name="P:Sandbox.Mounting.MountInfo.Available">
            <summary>
            Is this source available, is this game installed? Can we mount it?
            </summary>
        </member>
        <member name="P:Sandbox.Mounting.MountInfo.Mounted">
            <summary>
            Is this active and mounted?
            </summary>
        </member>
        <member name="M:Sandbox.Mounting.MountUtility.GetPreviewTexture(Sandbox.Mounting.ResourceLoader)">
            <summary>
            Create a preview texture for the given resource loader.
            </summary>
        </member>
        <member name="M:Sandbox.Mounting.TextureLoader.FromDds(System.ReadOnlySpan{System.Byte})">
            <summary>
            Creates a <see cref="T:Sandbox.Texture"/> from a DDS byte buffer.
            </summary>
            <param name="bytes">Raw DDS file contents.</param>
            <returns>A <see cref="T:Sandbox.Texture"/> with mips.</returns>
        </member>
        <member name="F:Sandbox.Navigation.NavMeshBoxAreaData.Box">
            <summary>
            Forms an OBB together with the transform
            </summary>
        </member>
        <member name="T:Sandbox.Navigation.NavMesh">
            <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
            <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
            <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IsEnabled">
            <summary>
            Determines wether the navigation mesh is enabled and should be generated
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IsGenerating">
            <summary>
            The navigation mesh is generating
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IsDirty">
            <summary>
            The navigation mesh is dirty and needs a complete rebuild
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IncludeStaticBodies">
            <summary>
            Should the generator include static bodies
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IncludeKeyframedBodies">
            <summary>
            Should the generator include keyframed bodies
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.ExcludedBodies">
            <summary>
            Don't include these bodies in the generation
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IncludedBodies">
            <summary>
            If any, we'll only include bodies with this tag
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.EditorAutoUpdate">
            <summary>
            Constantly update the navigation mesh in the editor
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.DrawMesh">
            <summary>
            Draw the navigation mesh in the editor
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.AgentHeight">
            <summary>
            Height of the agent
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.AgentRadius">
            <summary>
            The radius of the agent. This will change how much gap is left on the edges of surfaces, so they don't clip into walls.
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.AgentStepSize">
            <summary>
            The maximum height an agent can climb (step)
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.AgentMaxSlope">
            <summary>
            The maximum slope an agent can walk up (in degrees)
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.NavMesh.CellSize">
            <summary>
            The xz-plane cell size to use for fields. [Limit: > 0] [Units: wu] 
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.NavMesh.CellHeight">
            <summary>
            The y-axis cell size to use for fields. [Limit: > 0] [Units: wu]
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.TileSizeXYVoxels">
            <summary>
            The width/height size of tile's on the xy-plane. [Limit: &gt;= 0] [Units: vx]
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.SetDirty">
            <summary>
            Set the navgiation a dirty, so it will rebuild next update
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.CalculatePath(Sandbox.Navigation.CalculatePathRequest)">
            <summary>
            Computes a navigation path between the specified start and target positions on the navmesh.
            Uses the same pathfinding algorithm as <see cref="T:Sandbox.NavMeshAgent"/>, taking agent configuration into account if provided.
            The result is suitable for direct use with <see cref="M:Sandbox.NavMeshAgent.SetPath(Sandbox.Navigation.NavMeshPath)"/>.
            If a complete path cannot be found, the result may indicate an incomplete or failed path.
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.GetRandomPoint(BBox)">
            <summary>
            Get a random point on the navmesh, within the bounding box. 
            This will return null if it can't find a point on the navmesh in a few tries. Returning false doesn't mean it's impossible, our algorithm here isn't the best.
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.GetRandomPoint(Vector3,System.Single)">
            <summary>
            Get a random point on the navmesh, within the sphere.
            This will return null if it can't find a point on the navmesh in a few tries. Returning false doesn't mean it's impossible, our algorithm here isn't the best.
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.Serialize">
            <summary>
            Data saved in a Scene file
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.Deserialize(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Data loaded from a Scene file
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.GenerateTile(Sandbox.PhysicsWorld,Vector3)">
            <summary>
            Generates or regenerates the navmesh tile at the given world position.
            This function is thread safe but can only be called from the main thread.
            </summary>
            
            <remarks>
            While most of the generation happens in parallel, this function also requires some time on the main thread.
            If you need to update many tiles, consider spreading the updates accross multiple frames.
            </remarks>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.GenerateTiles(Sandbox.PhysicsWorld,BBox)">
            <summary>
            Generates or regenerates the navmesh tiles overlapping with the given bounds.
            This function is thread safe but can only be called from the main thread.
            </summary>
            
            <remarks>
            While most of the generation happens in parallel, this function also requires some time on the main thread.
            If you need to update many tiles, consider spreading the updates accross multiple frames.
            </remarks>
        </member>
        <member name="T:Sandbox.Navigation.CalculatePathRequest">
            <summary>
            Defines the input for a pathfinding request on the navmesh.
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.CalculatePathRequest.Start">
            <summary>
            Start position of the path, should be close to the navmesh.
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.CalculatePathRequest.Target">
            <summary>
            Target/End position of the path, should be close to the navmesh.
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.CalculatePathRequest.Agent">
            <summary>
            Optional agent whose configuration is used for path calculation.
            </summary>
        </member>
        <member name="T:Sandbox.Navigation.NavMeshPath">
            <summary>
            Contains the result of a pathfinding operation.
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMeshPath.Status">
            <summary>
            The outcome of the path calculation.
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMeshPath.IsValid">
            <summary>
            True if a path was found.
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.NavMeshPath.Polygons">
            <summary>
            Polygons traversed by the path.
            Internal for now as you cannot do anything with polygon ids yet.
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMeshPath.Points">
            <summary>
            Points along the path.
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.NavMeshPathStatus.StartNotFound">
            <summary>
            Start location was not found on the navmesh.
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.NavMeshPathStatus.TargetNotFound">
            <summary>
            Target location was not found on the navmesh.
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.NavMeshPathStatus.PathNotFound">
            <summary>
            No path could be found.
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.NavMeshPathStatus.Partial">
            <summary>
            Path found, but does not reach the target.
            The returned path will be to the closest location that can be reached.
            </summary>
        </member>
        <member name="F:Sandbox.Navigation.NavMeshPathStatus.Complete">
            <summary>
            Path found from start to target.
            </summary>
        </member>
        <member name="T:Sandbox.Navigation.NavMeshPathPoint">
            <summary>
            Represents a point in a navmesh path, including its position in 3D space.
            May be extended in the future to hold more information about the point.
            </summary>
        </member>
        <member name="T:Sandbox.PartyRoom">
            <summary>
            A Party. A Party with your friends.
            </summary>
        </member>
        <member name="P:Sandbox.PartyRoom.Id">
            <summary>
            The unique identifier of this lobby
            </summary>
        </member>
        <member name="M:Sandbox.PartyRoom.SetOwner(Sandbox.SteamId)">
            <summary>
            Set the owner to someone else. You need to be the owner
            </summary>
        </member>
        <member name="P:Sandbox.PartyRoom.VoiceCommunicationAllowed">
            <summary>
            Allow communication via voice when in the main menu.
            </summary>
        </member>
        <member name="M:Sandbox.PartyRoom.OnVoiceRecorded(System.Memory{System.Byte})">
            <summary>
            Voice data has been recieved. Send it to everyone.
            </summary>
        </member>
        <member name="P:Sandbox.PartyRoom.Members">
            <summary>
            A list of members in this room
            </summary>
        </member>
        <member name="M:Sandbox.PartyRoom.SetBroadcastVoice">
            <summary>
            Called each frame that a client wants to broadcast their voice
            </summary>
        </member>
        <member name="T:Sandbox.Preferences">
            <summary>
            Holds information about the current user's preferences.
            </summary>
        </member>
        <member name="P:Sandbox.Preferences.FieldOfView">
            <summary>
            The user's preference for their field of view
            </summary>
        </member>
        <member name="P:Sandbox.Preferences.MusicVolume">
            <summary>
            The user's preferred Music volume, as set in the options, clamped between 0 and 1
            </summary>
        </member>
        <member name="P:Sandbox.Preferences.VoipVolume">
            <summary>
            The user's preferred VOIP volume, as set in the options, clamped between 0 and 1
            </summary>
        </member>
        <member name="P:Sandbox.Preferences.Sensitivity">
            <summary>
            The mouse sensitivity
            </summary>
        </member>
        <member name="T:Sandbox.Services.AchievementOverview">
            <summary>
            Activity Feed
            </summary>
        </member>
        <member name="T:Sandbox.Services.Achievements">
            <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Achievements.DelayAchievementUnlocks(System.Single)">
            <summary>
            Delay automatic achievement unlocks for this many seconds. Useful when loading etc.
            </summary>
        </member>
        <member name="T:Sandbox.Services.Achievements.Map">
            <summary>
            Stats for the current map
            </summary>
        </member>
        <member name="M:Sandbox.Services.Auth.GetToken(System.String,System.Threading.CancellationToken)">
            <summary>
            Get an auth token, which can be passed to the backend
            </summary>
        </member>
        <member name="M:Sandbox.Services.Auth.GetAuthTicket(System.UInt64,System.Byte[]@)">
            <summary>
            Get a Steam authentication ticket intended for a target with a particular Steam Id.
            </summary>
            <param name="targetSteamId"></param>
            <param name="ticket"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Services.Auth.EndAuthSession(System.UInt64)">
            <summary>
            End an authentication session with a particular user.
            </summary>
            <param name="steamId"></param>
        </member>
        <member name="M:Sandbox.Services.Auth.BeginAuthSession(System.UInt64,System.Byte[])">
            <summary>
            Begin an authentication session with a particular user, using the ticket they provided you.
            </summary>
            <param name="senderSteamId"></param>
            <param name="ticket"></param>
        </member>
        <member name="M:Sandbox.Services.Auth.CancelAuthTicket(Steamworks.Data.HAuthTicket)">
            <summary>
            Cancel an authentication ticket from a handle obtained by <see cref="M:Sandbox.Services.Auth.GetAuthTicket(System.UInt64,System.Byte[]@)"/>.
            </summary>
            <param name="handle"></param>
        </member>
        <member name="T:Sandbox.Services.BenchmarkSystem">
            <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.Start(System.String)">
            <summary>
            Called to start a benchmark
            </summary>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.SetMetric(System.String,System.Double)">
            <summary>
            Set a custom metric, like load time, shutdown time etc
            </summary>
            <param name="name"></param>
            <param name="metric"></param>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.Finish">
            <summary>
            Called to close a benchmark off
            </summary>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.Sample">
            <summary>
            Should be called in update every frame
            </summary>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.SendAsync(System.Threading.CancellationToken)">
            <summary>
            Finish this benchmark session and send it off to the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.P5">
            <summary>
            The value below which 5% of the samples fall (the 5th percentile).
            </summary>
        </member>
        <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.P95">
            <summary>
            The value below which 95% of the samples fall (the 95th percentile).
            </summary>
        </member>
        <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.P99">
            <summary>
            The value below which 99% of the samples fall (the 99th percentile).
            </summary>
        </member>
        <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.P99_9">
            <summary>
            The value below which 99.9% of the samples fall (the 99.9th percentile).
            </summary>
        </member>
        <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.Stuttering">
            <summary>
            This is the sum of all samples that exceeded the stuttering threshold.
            May not be very useful for non time based samples.
            </summary>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.Sampler.Percentile(System.Double)">
            <summary>
            Calculates the specified percentile value from the collected samples.
            </summary>
            <param name="percentile">
            The percentile to compute (a value between 0 and 100).
            For example, passing 95 computes the 95th percentile.
            </param>
            <returns>
            The value below which the given percentage of samples fall.
            </returns>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.Sampler.Stuttering(System.Double)">
            <summary>
            Calculates the sum of all samples that exceeded the stuttering threshold.
            A sample is considered stuttering if it exceeds the moving average multiplied by the stuttering factor.
            </summary>
            <param name="stutteringFactor">
            The multiplier used to determine the stuttering threshold.
            A higher factor makes it less sensitive to spikes (default is typically 2.5).
            </param>
        </member>
        <member name="T:Sandbox.Services.Feed">
            <summary>
            Activity Feed
            </summary>
        </member>
        <member name="T:Sandbox.Services.Inventory">
            <summary>
            Allows access to the Steam Inventory system
            </summary>
            <summary>
            Allows access to the Steam Inventory system
            </summary>
        </member>
        <member name="P:Sandbox.Services.Inventory.Items">
            <summary>
            All of the items the user has in their inventory
            </summary>
        </member>
        <member name="M:Sandbox.Services.Inventory.Refresh(System.Threading.CancellationToken)">
            <summary>
            Get the user's inventory. This is called on startup - and shouldn't really need to be
            called again unless the user buys something. Returns a list of items added since the last refresh.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Inventory.HasItem(System.Int32)">
            <summary>
            Returns true if we have this item
            </summary>
        </member>
        <member name="P:Sandbox.Services.Inventory.Definitions">
            <summary>
            All item definitions
            </summary>
        </member>
        <member name="M:Sandbox.Services.Inventory.FindDefinition(System.Int32)">
            <summary>
            Find a definition by id
            </summary>
        </member>
        <member name="M:Sandbox.Services.Inventory.WaitForSteamInventoryItems(System.Threading.CancellationToken)">
            <summary>
            Wait until the items have been delievered
            </summary>
        </member>
        <member name="T:Sandbox.Services.Inventory.Item">
            <summary>
            Describes a type of item that can be in the inventory
            </summary>
        </member>
        <member name="T:Sandbox.Services.Inventory.ItemDefinition">
            <summary>
            Describes a type of item that can be in the inventory
            </summary>
        </member>
        <member name="P:Sandbox.Services.Inventory.ItemDefinition.Price">
            <summary>
            If we're for sale, this is our price
            </summary>
        </member>
        <member name="P:Sandbox.Services.Inventory.ItemDefinition.BasePrice">
            <summary>
            If we're for sale but on sale, this is our regular price
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.TargetSteamId">
            <summary>
            The steamid to get information about. If unset then this defaults to the current player.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.MaxEntries">
            <summary>
            The maximum entries to respond with.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Group">
            <summary>
            global, country, friends
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Title">
            <summary>
            The group name of this board. For example, "Global" for global, "Friends" for friends.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.DisplayName">
            <summary>
            The display name of this board, which was set in the backend.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Description">
            <summary>
            The description of this board, which was set in the backend.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.TotalEntries">
            <summary>
            The total number of chart entries for this board.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Unit">
            <summary>
            The unit type chosen for this board
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Entries">
            <summary>
            The group of entries for this board. This is usually the entries that surround
            the TargetSteamId.
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.Me">
            <summary>
            True if this entry is for the current player.
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.Rank">
            <summary>
            The rank in the board
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.Value">
            <summary>
            The value in the board
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.FormattedValue">
            <summary>
            The value, but formatted according to Unit
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.SteamId">
            <summary>
            The steamid of the entry
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.DisplayName">
            <summary>
            The player's display name
            </summary>
        </member>
        <member name="M:Sandbox.Services.Leaderboards.Board2.CenterOnSteamId(System.Int64)">
            <summary>
            Center the results on this steamid, show the surrounding results with this in the middle.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Leaderboards.Board2.CenterOnMe">
            <summary>
            Center the results on you, show the surrounding results with you in the middle.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Leaderboards.Board2.IncludeSteamIds(System.Int64[])">
            <summary>
            If they have any results, include these steamids in the results - regardless of their position.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board2.TargetSteamId">
            <summary>
            The steamid to get information about. If unset then this defaults to the current player.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board2.MaxEntries">
            <summary>
            The maximum entries to respond with.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board2.Offset">
            <summary>
            The offset to start at. If less than 0, we will start from the bottom.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board2.TotalEntries">
            <summary>
            The total number of chart entries for this board.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board2.TimePeriodDescription">
            <summary>
            If you are restructing by time period, this is the name of the period
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board2.Entries">
            <summary>
            The group of entries for this board. This is usually the entries that surround
            the TargetSteamId.
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.Rank">
            <summary>
            The rank in the board
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.Value">
            <summary>
            The value in the board
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.SteamId">
            <summary>
            The steamid of the entry
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.CountryCode">
            <summary>
            The country which this entry is from
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.DisplayName">
            <summary>
            The player's display name
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.Timestamp">
            <summary>
            The time this entry was created.
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.Data">
            <summary>
            Data associated with this entry
            </summary>
        </member>
        <member name="F:Sandbox.Services.Messaging.incoming">
            <summary>
            Store the messages from the other thread so we can process them 
            on the main thread, at an appropriate time in the loop
            </summary>
        </member>
        <member name="T:Sandbox.Services.News">
            <summary>
            News Posts
            </summary>
        </member>
        <member name="T:Sandbox.Services.Notification">
            <summary>
            Player notification
            </summary>
        </member>
        <member name="T:Sandbox.Services.Players.Overview">
            <summary>
            An overview of a player. Only available if their profile isn't set to private.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Players.Overview.AvatarJson">
            <summary>
            A json string representing how their avatar is dressed
            </summary>
        </member>
        <member name="T:Sandbox.Services.Players.Profile">
            <summary>
            Player profile
            </summary>
        </member>
        <member name="T:Sandbox.Services.Review">
            <summary>
            Package Reviews
            </summary>
        </member>
        <member name="P:Sandbox.Services.Review.Player">
            <summary>
            The player who made the review
            </summary>
        </member>
        <member name="P:Sandbox.Services.Review.Content">
            <summary>
            The actual content (text only right now)
            </summary>
        </member>
        <member name="P:Sandbox.Services.Review.Score">
            <summary>
            The score of the review
            </summary>
        </member>
        <member name="P:Sandbox.Services.Review.PlayTime">
            <summary>
            How many seconds this user played
            </summary>
        </member>
        <member name="P:Sandbox.Services.Review.Updated">
            <summary>
            Date this review was updated
            </summary>
        </member>
        <member name="T:Sandbox.Services.Screenshots">
            <summary>
            Implements Steamscreenshots
            </summary>
        </member>
        <member name="M:Sandbox.Services.Screenshots.AddScreenshotToLibrary(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32)">
            <summary>
            Writes a screenshot to the user's Steam screenshot library
            </summary>
        </member>
        <member name="T:Sandbox.Services.ServerList.Entry">
            <summary>
            This is a cleaned up version of gameserveritem_t.
            </summary>
        </member>
        <member name="T:Sandbox.Services.gameserveritem_t">
            <summary>
            Data from c++
            We skip the steamid because there's some class padding fuckery going on.
            We pass that in manually to make life easier.
            </summary>
        </member>
        <member name="T:Sandbox.Services.Stats">
            <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
            <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.FlushAsync(System.Threading.CancellationToken)">
            <summary>
            Send any pending stats to the backend. Don't wait for confirmation of ingestiom, fire and forget.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.Flush">
            <summary>
            Send any pending stats to the backend. Don't wait for confirmation of ingestiom, fire and forget.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.FlushAndWaitAsync(System.Threading.CancellationToken)">
            <summary>
            Send any pending stats to the backend, will wait until they're available for query before finishing.
            </summary>
        </member>
        <member name="F:Sandbox.Services.Stats._globalStats">
            <summary>
            Static cache of all the global stats
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.Global">
            <summary>
            Get the global stats for the calling package
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GetGlobalStats(System.String)">
            <summary>
            Get the global stats for this package
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStats.IsRefreshing">
            <summary>
            True if we're currently fetching new stats
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStats.LastRefresh">
            <summary>
            The UTC datetime when we last fetched new stats
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GlobalStats.Copy">
            <summary>
            Make a copy of this class. Allows you to store the stats from a point in time.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GlobalStats.Get(System.String)">
            <summary>
            Get a stat by name. Will return an empty stat if not found
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GlobalStats.TryGet(System.String,Sandbox.Services.Stats.GlobalStat@)">
            <summary>
            Get a stat by name, returns true if found
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GlobalStats.Refresh">
            <summary>
            Refresh these global stats - grab the latest values
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Name">
            <summary>
            The programatic name for this stat. This should probably be called Ident
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Title">
            <summary>
            The title of this stat, as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Description">
            <summary>
            The description of this stat, as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Unit">
            <summary>
            The unit of this stat as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Velocity">
            <summary>
            The change in this stat in units per hour
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Value">
            <summary>
            The current stat value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.ValueString">
            <summary>
            The current value formatted using Unit
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Players">
            <summary>
            The amount of players that have this stat
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Max">
            <summary>
            The maximum value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Min">
            <summary>
            The minimum value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Avg">
            <summary>
            The average value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Sum">
            <summary>
            The sum of all values
            </summary>
        </member>
        <member name="T:Sandbox.Services.Stats.Map">
            <summary>
            Stats for the current map
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.Map.Local">
            <summary>
            Get the stats for the local player
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.Map.Global">
            <summary>
            Get the global stats
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.Map.SetValue(System.String,System.Double,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Add a stat value for this package
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.Map.GetLocal(System.String)">
            <summary>
            Get a stat for the local player
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.Map.GetGlobal(System.String)">
            <summary>
            Get a stat for the local player
            </summary>
        </member>
        <member name="F:Sandbox.Services.Stats._playerStats">
            <summary>
            Static cache of all the global stats
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.LocalPlayer">
            <summary>
            Get the global stats for the calling package
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GetLocalPlayerStats(System.String)">
            <summary>
            Get the global stats for this package
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GetPlayerStats(System.String,System.Int64)">
            <summary>
            Get the stats for this package
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStats.IsRefreshing">
            <summary>
            True if we're currently fetching new stats
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStats.LastRefresh">
            <summary>
            The UTC datetime when we last fetched new stats
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.PlayerStats.Copy">
            <summary>
            Make a copy of this class. Allows you to store the stats from a point in time.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.PlayerStats.Get(System.String)">
            <summary>
            Get a stat by name. Will return an empty stat if not found
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.PlayerStats.TryGet(System.String,Sandbox.Services.Stats.PlayerStat@)">
            <summary>
            Get a stat by name, returns true if found
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.PlayerStats.Refresh">
            <summary>
            Refresh these global stats - grab the latest values
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.PlayerStats.Predict(System.String,System.Double)">
            <summary>
            When the stat is queued for change on the backend, we can predict its change on the front
            end, for achievements etc.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Name">
            <summary>
            The programatic name for this stat. This should probably be called Ident
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Title">
            <summary>
            The title of this stat, as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Description">
            <summary>
            The description of this stat, as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Unit">
            <summary>
            The unit of this stat as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Value">
            <summary>
            The current stat value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.ValueString">
            <summary>
            The current value formatted using Unit
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Max">
            <summary>
            The maximum value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Min">
            <summary>
            The minimum value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Avg">
            <summary>
            The average value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Sum">
            <summary>
            The sum of all values
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Last">
            <summary>
            The time of the last value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.LastValue">
            <summary>
            The last value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.First">
            <summary>
            The time of the first value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.FirstValue">
            <summary>
            The last value
            </summary>
        </member>
        <member name="T:Sandbox.Services.Ugc">
            <summary>
            Implements SteamUgc, lets us edit/create workshop items
            </summary>
        </member>
        <member name="P:Sandbox.Services.Ugc.NeedsLegalAgreement">
            <summary>
            Does this user need to sign the license agreement for their published items?
            You need to call this after submitting an item
            </summary>
        </member>
        <member name="M:Sandbox.Services.Ugc.CreateItem">
            <summary>
            Creates a Ugc item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Services.Ugc.SetItemId(System.UInt64)">
            <summary>
            Sets the current item id, so any updates are scoped to this item
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Sandbox.Services.Ugc.GetItemId">
            <summary>
            Gets the current item id
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Services.Ugc.StartUpdating">
            <summary>
            Start updating an item
            </summary>
        </member>
        <member name="M:Sandbox.Services.Ugc.SetTitle(System.String)">
            <summary>
            Sets the title of the item
            </summary>
            <param name="title"></param>
        </member>
        <member name="M:Sandbox.Services.Ugc.SetContent(System.String)">
            <summary>
            Sets the content of the item
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Sandbox.Services.Ugc.Submit">
            <summary>
            Submits an item's changes to the steam workshop
            </summary>
            <returns></returns>
        </member>
        <member name="T:Sandbox.CurrencyValue">
            <summary>
            Describes money, in a certain currency
            </summary>
        </member>
        <member name="F:Sandbox.CurrencyValue.Currency">
            <summary>
            The name of the currency
            </summary>
        </member>
        <member name="F:Sandbox.CurrencyValue.Value">
            <summary>
            The value without decimals. This is in the smallest denomination of the currency.
            </summary>
        </member>
        <member name="P:Sandbox.Standalone.Manifest">
            <summary>
            If running in standalone, contains the properties of the standalone game
            </summary>
        </member>
        <member name="P:Sandbox.Standalone.BuildDate">
            <summary>
            The date and time at which the current standalone game was built
            </summary>
        </member>
        <member name="P:Sandbox.Standalone.IsDevelopmentBuild">
            <summary>
            Is the current standalone game running in development mode?
            </summary>
        </member>
        <member name="P:Sandbox.Standalone.VersionDate">
            <summary>
            The date and time at which the current standalone game was built
            </summary>
        </member>
        <member name="P:Sandbox.Standalone.Version">
            <summary>
            Represents the current standalone game's version, specified by the developer
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.Name">
            <summary>
            What is the game's name?
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.Ident">
            <summary>
            What ident are we running under?
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.ExecutableName">
            <summary>
            Game's executable name (e.g. game.exe)
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.AppId">
            <summary>
            The Steam App ID of the game
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.BuildDate">
            <summary>
            Game's build date, automatically set when the game was exported.
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.IsVRProject">
            <summary>
            Should we automatically launch this project in VR?
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Username">
            <summary>
            Your own username
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.UserId">
            <summary>
            Your own user id
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Service">
            <summary>
            The service type (ie "Twitch")
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.IsActive">
            <summary>
            Are we connected to a service
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.GetUser(System.String)">
            <summary>
            Get user information. If no username is specified, the user returned is ourself
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.GetUserFollowing(System.String)">
            <summary>
            Get user following "Who is X following"
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.GetUserFollowers(System.String)">
            <summary>
            Get user followers "Who is following X"
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.CreatePoll(System.String,System.String,System.Int32,System.String[])">
            <summary>
            Start a poll with choices, save the poll id so you can end it later on
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.EndPoll(System.String,System.String,System.Boolean)">
            <summary>
            End a poll using a saved poll id, you can optionally archive the poll or just terminate it
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.CreatePrediction(System.String,System.String,System.Int32,System.String,System.String)">
            <summary>
            Create a prediction to bet with channel points
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.LockPrediction(System.String,System.String)">
            <summary>
            Lock a current prediction with prediction id
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.CancelPrediction(System.String,System.String)">
            <summary>
            Cancel a current prediction with prediction id
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.ResolvePrediction(System.String,System.String,System.String)">
            <summary>
            Resolve a current prediction with prediction id and choose winning outcome to pay out channel points
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.SendMessage(System.String)">
            <summary>
            Send a message to chat, optionally specify channel you want to send the message, otherwise it is sent to your own chat
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.ClearChat">
            <summary>
            Clear your own chat
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.BanUser(System.String,System.String,System.Int32)">
            <summary>
            Ban user from your chat by username, the user will no longer be able to chat.
            Optionally specify the duration, a duration of zero means perm ban
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.UnbanUser(System.String)">
            <summary>
            Unban user from your chat by username
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Game">
            <summary>
            Set the game you're playing by game id
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Language">
            <summary>
            Set the language of your stream
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Title">
            <summary>
            Set the title of your stream
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Delay">
            <summary>
            Set the delay of your stream
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.ViewerCount">
            <summary>
            Amount of concurrent viewer your stream has.
            </summary>
        </member>
        <member name="M:Sandbox.StreamPoll.End(System.Boolean)">
            <summary>
            End this poll, you can optionally archive the poll, otherwise just terminate it
            </summary>
        </member>
        <member name="M:Sandbox.StreamPrediction.Lock">
            <summary>
            Lock this prediction
            </summary>
        </member>
        <member name="M:Sandbox.StreamPrediction.Cancel">
            <summary>
            Cancel this prediction
            </summary>
        </member>
        <member name="M:Sandbox.StreamPrediction.Resolve">
            <summary>
            Resolve this prediction and choose winning outcome to pay out channel points
            </summary>
        </member>
        <member name="T:Sandbox.StreamService">
            <summary>
            Streamer integration services
            </summary>
        </member>
        <member name="P:Sandbox.StreamUser.Following">
            <summary>
            Get following "Who is following us"
            </summary>
        </member>
        <member name="P:Sandbox.StreamUser.Followers">
            <summary>
            Get followers "Who are we following"
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.Ban(System.String,System.Int32)">
            <summary>
            Ban user from your chat, the user will no longer be able to chat.
            Optionally specify the duration, a duration of zero means perm ban
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.Unban">
            <summary>
            Unban user from your chat, this allows them to chat again
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.CreateClip(System.Boolean)">
            <summary>
            Create a clip of our stream, if we're streaming
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.CreatePoll(System.String,System.Int32,System.String[])">
            <summary>
            Start a poll on our channel with multiple choices, save the poll so you can end it later on
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.CreatePrediction(System.String,System.Int32,System.String,System.String)">
            <summary>
            Create a prediction on our channel to bet with channel points
            </summary>
        </member>
        <member name="P:Sandbox.Twitch.IRCMessage.Channel">
            <summary>
            The channel the message was sent in
            </summary>
        </member>
        <member name="P:Sandbox.Twitch.IRCMessage.Message">
            <summary>
            Message itself
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage._parameters">
            <summary>
            Command parameters
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.User">
            <summary>
            The user whose message it is
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.Hostmask">
            <summary>
            Hostmask of the user
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.Command">
            <summary>
            Raw Command
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.Tags">
            <summary>
            IRCv3 tags
            </summary>
        </member>
        <member name="M:Sandbox.Twitch.IRCMessage.#ctor(System.String)">
            <summary>
            Create an INCOMPLETE IrcMessage only carrying username
            </summary>
            <param name="user"></param>
        </member>
        <member name="M:Sandbox.Twitch.IRCMessage.#ctor(Sandbox.Twitch.IRCCommand,System.String[],System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Create an IrcMessage
            </summary>
            <param name="command">IRC Command</param>
            <param name="parameters">Command params</param>
            <param name="hostmask">User</param>
            <param name="tags">IRCv3 tags</param>
        </member>
        <member name="M:Sandbox.Twitch.IRCParser.Parse(System.String)">
            <summary>
            Parses a raw IRC message into a IRCMessage.
            </summary>
        </member>
        <member name="T:Sandbox.VR.FingerValue">
            <summary>
            Accessors for <see cref="M:Sandbox.VR.VRController.GetFingerValue(Sandbox.VR.FingerValue)"/>
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.ThumbCurl">
            <summary>
            Represents the curling motion of the thumb.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.IndexCurl">
            <summary>
            Represents the curling motion of the index finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.MiddleCurl">
            <summary>
            Represents the curling motion of the middle finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.RingCurl">
            <summary>
            Represents the curling motion of the ring finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.PinkyCurl">
            <summary>
            Represents the curling motion of the pinky finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.ThumbIndexSplay">
            <summary>
            Represents the splaying motion between the thumb and index finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.IndexMiddleSplay">
            <summary>
            Represents the splaying motion between the index and middle fingers.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.MiddleRingSplay">
            <summary>
            Represents the splaying motion between the middle and ring fingers.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.RingPinkySplay">
            <summary>
            Represents the splaying motion between the ring and pinky fingers.
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRSystem.States.Shutdown">
            <summary>
            The VR system is currently shut down.
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRSystem.States.Standby">
            <summary>
            The VR system is not updating or rendering, but is ready.
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRSystem.States.PreInit">
            <summary>
            The VR system has begun to initialise. An OpenXR instance has been created.
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRSystem.States.Active">
            <summary>
            The VR system is active and updating.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRSystem.Init">
            <summary>
            Initialise the VR instance.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRSystem.Disable">
            <summary>
            Disable the VR instance.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRSystem.Shutdown">
            <summary>
            Shut down the VR instance.
            </summary>
        </member>
        <member name="T:Sandbox.VR.TrackedDevice">
            <summary>
            Describes a tracked VR device
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.Transform">
            <summary>
            This device's transform in absolute space
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.Velocity">
            <summary>
            Velocity in tracker space in inch/s
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.AngularVelocity">
            <summary>
            Angular velocity in degrees/s
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.DeviceRole">
            <summary>
            Where is this device (left hand, right hand, left ankle, chest, etc.)?
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.DeviceType">
            <summary>
            What type of device is this (HMD, controller, tracker, etc.)?
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.InputSource">
            <summary>
            The input source for this device
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.InputSourceHandle">
            <summary>
            Handle we should use internally for performance-sensitive calls
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.IsActive">
            <summary>
            Is this tracked device currently active (connected)?
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.DeviceIndex">
            <summary>
            Index we can use when referring to poses retrieved through WaitGetPose and similar functions
            </summary>
        </member>
        <member name="M:Sandbox.VR.TrackedDevice.Update">
            <summary>
            Update this tracked device's position, velocity, etc.
            </summary>
        </member>
        <member name="T:Sandbox.VR.TrackedDeviceInfo">
            <summary>
            Information about a tracked device - vendor info, serial number, battery data
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.VendorName">
            <summary>
            Which tracking system does this use (e.g. "oculus")? <br/>
            Represents the value given by <c>Prop_TrackingSystemName_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.ManufacturerName">
            <summary>
            Who manufactured this device (e.g. "Oculus")? <br />
            Represents the value given by <c>Prop_ManufacturerName_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.DisplayName">
            <summary>
            What is this device called (e.g. "Oculus Rift S (Left Controller)")? <br/>
            Represents the value given by <c>Prop_ModelNumber_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.RenderModelName">
            <summary>
            Which render model should this use (e.g. "oculus_rifts_controller_left")? <br/>
            Represents the value given by <c>Prop_RenderModelName_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.SerialNumber">
            <summary>
            What is the serial number for this device (e.g. "1WMGH---------_Controller_Left")? <br/>
            Represents the value given by <c>Prop_SerialNumber_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.BatteryPercentage">
            <summary>
            Battery percentage from 0 to 100
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.TypeString">
            <summary>
            If this is a controller, then represents the value given by <c>Prop_ControllerType_String</c>, otherwise "unknown".
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Unknown">
            <summary>
            Unknown device role
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftHand">
            <summary>
            Represents the left hand
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightHand">
            <summary>
            Represents the right hand
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Head">
            <summary>
            Represents the head
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Gamepad">
            <summary>
            Represents a gamepad
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Treadmill">
            <summary>
            Represents a treadmill
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Stylus">
            <summary>
            Represents a stylus
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftFoot">
            <summary>
            Represents the left foot
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightFoot">
            <summary>
            Represents the right foot
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftShoulder">
            <summary>
            Represents the left shoulder
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightShoulder">
            <summary>
            Represents the right shoulder
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftElbow">
            <summary>
            Represents the left elbow
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightElbow">
            <summary>
            Represents the right elbow
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftKnee">
            <summary>
            Represents the left knee
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightKnee">
            <summary>
            Represents the right knee
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftWrist">
            <summary>
            Represents the left wrist
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightWrist">
            <summary>
            Represents the right wrist
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftAnkle">
            <summary>
            Represents the left ankle
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightAnkle">
            <summary>
            Represents the right ankle
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Waist">
            <summary>
            Represents the waist
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Chest">
            <summary>
            Represents the chest
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Camera">
            <summary>
            Represents a camera - such as a base station
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Keyboard">
            <summary>
            Represents a keyboard
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Invalid">
            <summary>
            The ID was not valid.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Hmd">
            <summary>
            Head-mounted display (your headset)
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Controller">
            <summary>
            Tracked controllers
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Tracker">
            <summary>
            Generic trackers
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.BaseStation">
            <summary>
            Camera and base stations that serve as tracking reference points
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Redirect">
            <summary>
            Accessories that aren't necessarily tracked themselves, but may redirect video output from other tracked devices
            </summary>
        </member>
        <member name="T:Sandbox.VR.VROverlay">
            <summary>
            <para>VR overlays draw over the top of the 3D scene, they will not be affected by lighting,
            post processing effects or anything else in the world.<br />
            This makes them ideal for HUDs or menus, or anything else that should be local to the
            HMD or tracked devices.</para>
            
            <para>If you need something in the world, consider using WorldPanel
            and WorldInput instead.</para>
            </summary>
        </member>
        <member name="M:Sandbox.VR.VROverlay.Dispose">
            <summary>
            Destroys this overlay.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VROverlay.Dispose(System.Boolean)">
            <summary>
            Destroys this overlay.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Visible">
            <summary>
            Shows or hides the VR overlay.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Transform">
            <summary>
            Sets the transform to absolute tracking origin
            </summary>
        </member>
        <member name="M:Sandbox.VR.VROverlay.SetTransformAbsolute(Transform)">
            <summary>
            Sets the transform to absolute tracking origin
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.SortOrder">
            <summary>
            Sets the rendering sort order for the overlay.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Width">
            <summary>
            The width of the overlay quad.
            By default overlays are rendered on a quad that is 1 meter across.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Curvature">
            <summary>
            Use to draw overlay as a curved surface. Curvature is a percentage from (0..1] where 1 is a fully closed cylinder.
            For a specific radius, curvature can be computed as: overlay.width / (2 PI r).
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Color">
            <summary>
            Sets the color tint of the overlay quad. Use 0.0 to 1.0 per channel.
            Sets the alpha of the overlay quad. Use 1.0 for 100 percent opacity to 0.0 for 0 percent opacity.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Texture">
            <summary>
            Texture that is rendered on the overlay quad.
            <see cref="T:Sandbox.TextureBuilder"/>
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.MouseScale">
            <summary>
            Sets the mouse scaling factor that is used for mouse events. 
            </summary>
        </member>
        <member name="M:Sandbox.VR.VROverlay.TriggerLaserMouseHapticVibration(System.Single,System.Single,System.Single)">
            <summary>
            Triggers a haptic event on the laser mouse controller for this overlay
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRNative">
            <summary>
            Native helpers for VR
            </summary>
            <summary>
            Native helpers for VR
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IPD">
            <summary>
            Private store for distance between user's pupils, in inches.
            Accessed and converted through <see cref="P:Sandbox.VR.VRNative.IPDMillimetres"/> and <see cref="P:Sandbox.VR.VRNative.IPDInches"/>
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IPDMillimetres">
            <summary>
            Distance between user's pupils, in millimetres
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IPDInches">
            <summary>
            Distance between user's pupils, in inches
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.RefreshRate">
            <summary>
            Headset refresh rate, in Hz
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IsDashboardVisible">
            <summary>
            Is the SteamVR dashboard currently visible?
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IsLeftHandDominant">
            <summary>
            Has the user selected that they're left hand dominant in SteamVR?
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.FullRenderTargetSize">
            <summary>
            Spans both eyes - equivalent to (eye width * 2, eye height)
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.EyeRenderTargetSize">
            <summary>
            Spans one eye
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.WorldScale">
            <summary>
            Scales the relative position between the two eyes
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRAnchor">
            <summary>
            Updates the the VR anchor based on a GameObject's transform.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRAnchor.UpdateAnchor">
            <summary>
            Update the VR anchor based on the GameObject's transform
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRHand">
            <summary>
            Updates the parameters on an <see cref="T:Sandbox.SkinnedModelRenderer"/> on this GameObject based on the skeletal data from SteamVR.
            Useful for quick hand posing based on controller input.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRHand.SkinnedModelComponent">
            <summary>
            Which <see cref="T:Sandbox.SkinnedModelRenderer"/> to use when updating this component
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRHand.HandSources">
            <summary>
            Represents a controller to use when fetching skeletal data (finger curl/splay values)
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRHand.HandSources.Left">
            <summary>
            The left controller
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRHand.HandSources.Right">
            <summary>
            The right controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRHand.HandSource">
            <summary>
            Which hand should we use to update the parameters?
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRHand.MotionRange">
            <summary>
            What motion range should we use to update the parameters?
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRModelRenderer">
            <summary>
            Renders a device-specific model for a VR device
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRModelRenderer.ModelSources">
            <summary>
            Represents a controller to use when fetching the model (which device)
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRModelRenderer.ModelSources.LeftHand">
            <summary>
            The left controller
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRModelRenderer.ModelSources.RightHand">
            <summary>
            The right controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRModelRenderer.ModelSource">
            <summary>
            Which device should we use to fetch the model?
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRModelRenderer.ModelRenderer">
            <summary>
            Which model renderer should we use as the target?
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRTrackedObject">
            <summary>
            Updates this GameObject's transform based on a given tracked object (e.g. left controller, HMD).
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRTrackedObject.PoseSources">
            <summary>
            Represents tracked devices to use when updating
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.PoseSources.Head">
            <summary>
            Retrieve data from the head-mounted display
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.PoseSources.LeftHand">
            <summary>
            Retrieve data from the left controller
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.PoseSources.RightHand">
            <summary>
            Retrieve data from the right controller
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRTrackedObject.TrackingTypes">
            <summary>
            Represents transform values to update
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.None">
            <summary>
            Don't update the position or the rotation
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.Rotation">
            <summary>
            Update the rotation only
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.Position">
            <summary>
            Update the rotation only
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.All">
            <summary>
            Update both the position and rotation
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRTrackedObject.PoseSource">
            <summary>
            Which tracked object should we use to update the transform?
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRTrackedObject.TrackingType">
            <summary>
            Which parts of the transform should be updated? (eg. rotation, position)
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRTrackedObject.UseRelativeTransform">
            <summary>
            If this is checked, then the transform used will be relative to the VR anchor (rather than an absolute world position).
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRTrackedObject.GetTransform">
            <summary>
            Get the appropriate VR transform for the specified <see cref="P:Sandbox.VR.VRTrackedObject.PoseSource"/>
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRTrackedObject.UpdatePose">
            <summary>
            Set the GameObject's transform based on the <see cref="P:Sandbox.VR.VRTrackedObject.PoseSource"/> and <see cref="P:Sandbox.VR.VRTrackedObject.TrackingType"/>
            </summary>
        </member>
        <member name="T:Sandbox.VR.AnalogInput">
            <summary>
            Represents a VR analog input action (e.g. trigger)
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput.Value">
            <summary>
            The current value of this input, from 0 to 1.
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput.Delta">
            <summary>
            How much <see cref="P:Sandbox.VR.AnalogInput.Value"/> has changed since the last update, from 0 to 1.
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput.Active">
            <summary>
            Whether or not this action is currently accessible (if false, then <see cref="P:Sandbox.VR.AnalogInput.Value"/> will always be 0 and will never change).
            </summary>
        </member>
        <member name="M:Sandbox.VR.AnalogInput.op_Implicit(Sandbox.VR.AnalogInput)~System.Single">
            <summary>
            Implicitly returns <see cref="P:Sandbox.VR.AnalogInput.Value"/> as a <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="T:Sandbox.VR.AnalogInput2D">
            <summary>
            Represents a two-dimensional VR analog input action (e.g. joysticks)
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput2D.Value">
            <summary>
            The current value of this input, with both axes ranging from 0 to 1.
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput2D.Delta">
            <summary>
            How much <see cref="P:Sandbox.VR.AnalogInput2D.Value"/> has changed since the last update, with both axes ranging from 0 to 1.
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput2D.Active">
            <summary>
            Whether or not this action is currently accessible (if false, then <see cref="P:Sandbox.VR.AnalogInput2D.Value"/> will always be 0 and will never change).
            </summary>
        </member>
        <member name="M:Sandbox.VR.AnalogInput2D.op_Implicit(Sandbox.VR.AnalogInput2D)~Vector2">
            <summary>
            Implicitly returns <see cref="P:Sandbox.VR.AnalogInput2D.Value"/> as a <see cref="T:Vector2"/>.
            </summary>
        </member>
        <member name="T:Sandbox.VR.DigitalInput">
            <summary>
            Represents a VR digital input action (e.g. X button)
            </summary>
        </member>
        <member name="P:Sandbox.VR.DigitalInput.IsPressed">
            <summary>
            The current value of this input - true if pressed, false if not pressed.
            </summary>
        </member>
        <member name="P:Sandbox.VR.DigitalInput.WasPressed">
            <summary>
            The previous value of this input - true if it was pressed, false if it was not pressed.
            </summary>
        </member>
        <member name="P:Sandbox.VR.DigitalInput.Delta">
            <summary>
            How much <see cref="P:Sandbox.VR.DigitalInput.IsPressed"/> has changed since the last update.
            </summary>
        </member>
        <member name="P:Sandbox.VR.DigitalInput.Active">
            <summary>
            Whether or not this action is currently accessible (if false, then <see cref="P:Sandbox.VR.DigitalInput.IsPressed"/> will always be false and will never change).
            </summary>
        </member>
        <member name="M:Sandbox.VR.DigitalInput.op_Implicit(Sandbox.VR.DigitalInput)~System.Boolean">
            <summary>
            Implicitly returns <see cref="P:Sandbox.VR.DigitalInput.IsPressed"/> as a <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.Current">
            <summary>
            The current relevant <see cref="T:Sandbox.VR.VRInput"/> instance.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.Scale">
            <summary>
            Get or set the player's scale in the world. If you set it to 2 the player will be twice as big.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.Anchor">
            <summary>
            Gets or sets where the center of the VR play area is in world space.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.ControllersAreDrawing">
            <summary>
            Returns true if SteamVR is drawing the controllers
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.IsLeftHandDominant">
            <summary>
            Returns true if the left hand is dominant
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.Head">
            <summary>
            Position and rotation of the Head Mounted Display in local space coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.LeftHand">
            <summary>
            Information about the left hand input.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.RightHand">
            <summary>
            Information about the right hand input.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.TrackedObjects">
            <summary>
            A list of available trackers.
            </summary>
        </member>
        <member name="F:Sandbox.VR.MotionRange.Hand">
            <summary>
            The default motion range. Provides hand poses that either estimate or fully represent the user's hand.
            </summary>
        </member>
        <member name="F:Sandbox.VR.MotionRange.Controller">
            <summary>
            Provides hand poses that estimate how the user's hand wraps around a controller, if they're using one.
            </summary>
        </member>
        <member name="T:Sandbox.VR.TrackedObject">
            <summary>
            Represents a physically tracked VR object with a transform
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Active">
            <summary>
            Whether or not this object is currently accessible (if false, then the transform will not update).
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Velocity">
            <summary>
            Local velocity of this object.
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.AngularVelocity">
            <summary>
            Local angular velocity of this object (degrees/s)
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Transform">
            <summary>
            The position and rotation of this tracked object in world space (based on the anchor position)
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Role">
            <summary>
            Which part of the body this tracked object represents - waist, left shoulder, etc.
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Type">
            <summary>
            What type of object this is - tracker, controller, etc.
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRController">
            <summary>
            Represents a VR controller, along with its transform, velocity, and inputs.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.IsHandTracked">
            <summary>
            Is this controller currently being represented using full hand tracking?
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.GetModel">
            <summary>
            Retrieves or creates a cached model that can be used to render this controller.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.TriggerHapticVibration(System.Single,System.Single,System.Single)">
            <summary>
            Triggers a haptic vibration event on the controller for this hand.
            </summary>
            <remarks>
            If a haptic event is already running it will be interrupted immediately.
            </remarks>
            <param name="duration">How long the haptic action should last (in seconds - can be 0 to "pulse" it)</param>
            <param name="frequency">How often the haptic motor should bounce (0 - 320 in hz. The lower end being more useful)</param>
            <param name="amplitude">How intense the haptic should be (0 - 1)</param>
        </member>
        <member name="M:Sandbox.VR.VRController.StopAllVibrations">
            <summary>
            Stop all vibration events on this controller.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.TriggerHaptics(Sandbox.HapticEffect,System.Single,System.Single,System.Single)">
            <summary>
            Trigger a vibration based on a predefined <see cref="T:Sandbox.HapticPattern"/>.
            All <see cref="T:Sandbox.HapticPattern"/>s are normalized (start at 0, peak at 1).
            </summary>
            <param name="effect">The pattern to use</param>
            <param name="lengthScale">The amount to scale the pattern's length by.</param>
            <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
            <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
        </member>
        <member name="M:Sandbox.VR.VRController.StopAllHaptics">
            <summary>
            Stops all rumble and haptic events on this controller.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.Trigger">
            <summary>
            The trigger input on this controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.Grip">
            <summary>
            The grip input on this controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.Joystick">
            <summary>
            The primary joystick input on this controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.JoystickPress">
            <summary>
            The primary joystick press on this controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.ButtonA">
            <summary>
            The primary button on this controller (Usually A, can be X for Oculus Touch)
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.ButtonB">
            <summary>
            The secondary button on this controller (Usually B, can be Y for Oculus Touch)
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.GetJoints(Sandbox.VR.MotionRange)">
            <summary>
            Returns joint data for a specific motion range.
            </summary>
            <param name="motionRange">Whether the joints returned represent a raw hand pose, or one that represents the hand wrapping around the controller.</param>
        </member>
        <member name="M:Sandbox.VR.VRController.GetFingerValue(Sandbox.VR.FingerValue)">
            <summary>
            Get the skeletal value (from 0 to 1) of a specified <see cref="T:Sandbox.VR.FingerValue"/> - includes curl and splay.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.GetFingerCurl(System.Int32)">
            <summary>
            Get the skeletal value (from 0 to 1) of a specified finger curl index.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.GetFingerSplay(System.Int32)">
            <summary>
            Get the skeletal value (from 0 to 1) of a specified finger splay index.
            </summary>
        </member>
        <member name="T:Sandbox.AnimParam`1">
            <summary>
            Anim param values contain any value for a limited set of types
            </summary>
        </member>
        <member name="P:Sandbox.AnimationGraph.IsError">
            <summary>
            Whether the animation graph is invalid, or has not yet loaded.
            </summary>
        </member>
        <member name="P:Sandbox.AnimationGraph.Name">
            <summary>
            Animation graph file name.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.#ctor(NativeEngine.HAnimationGraph,System.String)">
            <summary>
            Private constructor, use <see cref="M:Sandbox.AnimationGraph.FromNative(NativeEngine.HAnimationGraph,System.String)"/>
            </summary>
        </member>
        <member name="P:Sandbox.AnimationGraph.ParamCount">
            <summary>
            Number of parameters in this animgraph
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.GetParameterType(System.Int32)">
            <summary>
            Get value type of parameter at given index
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.GetParameterType(System.String)">
            <summary>
            Get value type of parameter with the given <paramref name="name"/>, or <see langword="null"/> if not found.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.GetParameterName(System.Int32)">
            <summary>
            Get name of parameter at given index
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.TryGetParameterIndex(System.String,System.Int32@)">
            <summary>
            Try to get parameter index at given name
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.GetParameter``1(System.String)">
            <summary>
            Get parameter at given name
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.GetParameter``1(System.Int32)">
            <summary>
            Get parameter at given index
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.Load(System.String)">
            <summary>
            Load an animation graph from given file.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.FromNative(NativeEngine.HAnimationGraph,System.String)">
            <summary>
            Try to make it so only one AnimationGraph class exists for each animation graph
            </summary>
        </member>
        <member name="T:Sandbox.Resources.EmbeddedResource">
            <summary>
            A JSON definition of an embedded resource. This is a resource that can be either standalone (in a .vtex file) or 
            embedded in a GameResource's Json data. 
            
            When it's detected in a GameResource we will create the named compiler and create the resource. When compiling the
            GameResource this can optionally create a compiled version of the resource on disk.
            
            When we compile a regular resource that contains this $compiler structure, it operates like any other compile, except
            it's totally managed by c# instead of resourcecompiler.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.EmbeddedResource.ResourceCompiler">
            <summary>
            The name of the ResourceCompiler to use
            </summary>
        </member>
        <member name="P:Sandbox.Resources.EmbeddedResource.ResourceGenerator">
            <summary>
            The name of the ResourceGenerator that created this resource. This is basically a sub-compiler.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.EmbeddedResource.TypeName">
            <summary>
            Sometimes we'll want to embed a child class of a resource
            </summary>
        </member>
        <member name="P:Sandbox.Resources.EmbeddedResource.Data">
            <summary>
            Data that is serialized/deserialized from the ResourceGenerator
            </summary>
        </member>
        <member name="P:Sandbox.Resources.EmbeddedResource.CompiledPath">
            <summary>
            If this resource has been compiled to disk then this is the path to that resource.
            This avoids the need to generate this resource again.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ResourceCompileContext.AbsolutePath">
            <summary>
            The absolute path to the resource on disk
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ResourceCompileContext.RelativePath">
            <summary>
            The path relative to the assets folder
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ResourceCompileContext.ResourceVersion">
            <summary>
            The resource version can be important
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompileContext.AddRuntimeReference(System.String)">
            <summary>
            Add a reference. This means that the resource we're compiling depends on this resource.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompileContext.AddCompileReference(System.String)">
            <summary>
            Add a reference that is needed to compile this resource, but isn't actually needed once compiled.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ResourceCompileContext.StreamingData">
            <summary>
            Get the streaming data to write to
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ResourceCompileContext.Data">
            <summary>
            Get the data to write to
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompileContext.CreateChild(System.String)">
            <summary>
            Create a child resource
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompileContext.ScanJson(System.String)">
            <summary>
            Load the json and scan it for paths or any embedded resources
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompileContext.ReadSource">
            <summary>
            Read the source, either from in memory, or from disk
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompileContext.ReadSourceAsString">
            <summary>
            Read the source, either from in memory, or from disk
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompileContext.ReadSourceAsJson">
            <summary>
            Read the source, either from in memory, or from disk
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompileContext.DataStream.Write(System.String)">
            <summary>
            Write a string with a null terminator
            </summary>
        </member>
        <member name="T:Sandbox.Resources.ResourceCompiler">
            <summary>
            Takes the "source" of a resource and creates a compiled version. The compiled version
            can create a number of child resources and store binary data.
            </summary>
            <summary>
            A collection of helper methods for making your own resource compiler.
            </summary>
        </member>
        <member name="T:Sandbox.Resources.ResourceCompiler.ResourceIdentityAttribute">
            <summary>
            Mark a ResourceCompiler. This is used to identify the compiler for a specific file extension, or compiler.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompiler.WriteToJson``1">
            <summary>
            Writes resource to a JSON file, using the ResourceGenerator to create the resource.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompiler.TryParseEmbeddedResource(System.Nullable{Sandbox.Resources.EmbeddedResource}@)">
            <summary>
            Try to parse the source as an EmbeddedResource
            Returns false if the source is not valid JSON or doesn't contain a ResourceGenerator.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompiler.CreateGeneratedResourcePath``1(Sandbox.Resources.EmbeddedResource,System.String,System.String)">
            <summary>
            Create a deterministic path for a generated resource based on the embedded resource data.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceCompiler.CompileEmbeddedResource``1(Sandbox.Resources.EmbeddedResource@,System.String,System.String,Sandbox.BaseFileSystem)">
            <summary>
            Generic method to compile an embedded resource by creating a child context.
            This handles the common pattern of creating a generator, generating a path,
            creating a child context, and setting the compiled path.
            </summary>
        </member>
        <member name="T:Sandbox.Resources.ResourceGenerator">
            <summary>
            Creates a resource from a json definition
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ResourceGenerator.Options.ForDisk">
            <summary>
            True if we're compiling this resource to write to disk
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ResourceGenerator.Options.Compiler">
            <summary>
            Will be set to the compiler that is currently compiling this resource. Or null, if we're generating in another method.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ResourceGenerator.CacheToDisk">
            <summary>
            If true then the generation will create a real resource and store it on disk.
            Use this if creating the resource takes a while, or you won't be shipping the generator
            with the game, or if it relies on data that won't be available in the shipped game.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator.Create``1(System.String)">
            <summary>
            Create a ResourceGenerator by name
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator.Create``1(Sandbox.Resources.EmbeddedResource)">
            <summary>
            Create a ResourceGenerator by name and deserialize it
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator.CreateResource(Sandbox.Resources.EmbeddedResource,Sandbox.Resources.ResourceGenerator.Options,System.Type)">
            <summary>
            Create a resource from an embedded resource with a given <see cref="T:System.Type"/>
            </summary>
            <param name="obj"></param>
            <param name="options"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator.Deserialize(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Copy properties from obj to us
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator.GetHash">
            <summary>
            Returns a hash to be used when loading/saving. We use this to determine if the resource has changed.
            By default we serialize the generator to a json string and return the CRC64 of that value. You can
            override this in your generator if you need to make it faster, or ignore some stuff.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator.FindOrCreateObjectAsync(Sandbox.Resources.ResourceGenerator.Options,System.Threading.CancellationToken)">
            <summary>
            If we generated this before, then find the current cache'd value.
            If not, then generate a new one.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator.FindOrCreateObject(Sandbox.Resources.ResourceGenerator.Options)">
            <summary>
            Find or create the resource (blocking) 
            </summary>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="T:Sandbox.Resources.ResourceGenerator`1">
            <summary>
            A resource generator targetting a specific type
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ResourceGenerator`1.UseMemoryCache">
            <summary>
            If true then the generation will avoid creating duplicate resources by checking
            hash codes of previously generated resources and re-using them if possible.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator`1.FindCached">
            <summary>
            Find a previously created of this resource
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator`1.AddToCache(`0)">
            <summary>
            Add this resource to the cache for our current hash
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator`1.FindOrCreate(Sandbox.Resources.ResourceGenerator.Options)">
            <summary>
            If we generated this before, then find the current cache'd value.
            If not, then generate a new one.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator`1.FindOrCreateAsync(Sandbox.Resources.ResourceGenerator.Options,System.Threading.CancellationToken)">
            <summary>
            If we generated this before, then find the current cache'd value.
            If not, then generate a new one.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator`1.Create(Sandbox.Resources.ResourceGenerator.Options)">
            <summary>
            Create the resource blocking
            </summary>
        </member>
        <member name="M:Sandbox.Resources.ResourceGenerator`1.CreateAsync(Sandbox.Resources.ResourceGenerator.Options,System.Threading.CancellationToken)">
            <summary>
            Create the resource asyncronously
            </summary>
        </member>
        <member name="M:Sandbox.Resources.TextureGenerator.CreateTexture(Sandbox.Resources.ResourceGenerator.Options,System.Threading.CancellationToken)">
            <summary>
            Find an existing texture for this
            </summary>
        </member>
        <member name="M:Sandbox.Resources.TextureGenerator.Create(Sandbox.Resources.ResourceGenerator.Options)">
            <summary>
            Create a texture. Will replace a placeholder texture, which will turn into the generated texture later, if it's not immediately available.
            </summary>
        </member>
        <member name="M:Sandbox.Resources.TextureGenerator.CreateAsync(Sandbox.Resources.ResourceGenerator.Options,System.Threading.CancellationToken)">
            <summary>
            Create a texture. Will wait until the texture is fully loaded and return when done.
            </summary>
        </member>
        <member name="T:Sandbox.Resources.ColorTextureGenerator">
            <summary>
            Generate a texture which is just a single color
            </summary>
        </member>
        <member name="T:Sandbox.Resources.ImageFileGenerator">
            <summary>
            Load images from disk and convert them to textures
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.FilePath">
            <summary>
            The path to the image file, relative to any other assets in the project.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.MaxSize">
            <summary>
            The maximum size of the image in pixels. If the imported image is larger than this (after cropping), it will be downscaled to fit.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.ConvertHeightToNormals">
            <summary>
            When enabled, the output texture will be a normal map generated from the heightmap of the image.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.NormalScale">
            <summary>
            The scale of the normal map when using <see cref="P:Sandbox.Resources.ImageFileGenerator.ConvertHeightToNormals"/>. If negative, the normal map will be inverted.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Rotate">
            <summary>
            How much to rotate the image by, in degrees. This is applied after cropping and padding.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.FlipVertical">
            <summary>
            Whether or not to flip the image vertically. This is done after everything else has been applied.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.FlipHorizontal">
            <summary>
            Whether or not to flip the image horizontally. This is done after everything else has been applied.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Cropping">
            <summary>
            How many pixels from each edge to crop from the image. If negative values are used, the image will be expanded instead of cropped.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Padding">
            <summary>
            How many pixels of padding from each edge. After the image has been cropped,
            padding is added without affecting the size of the image (scaling the original image down to fit padded margins).
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.InvertColor">
            <summary>
            Whether or not to invert the colors of the image.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Tint">
            <summary>
            The color the image should be tinted. This effectively multiplies the color of each pixel by this color (including alpha).
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Blur">
            <summary>
            The intensity of the blur effect. If 0, no blur is applied.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Sharpen">
            <summary>
            The intensity of the sharpen effect. If 0, no sharpening is applied.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Brightness">
            <summary>
            The brightness of the image.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Contrast">
            <summary>
            The contrast of the image.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Saturation">
            <summary>
            The saturation of the image.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Hue">
            <summary>
            How much to adjust the hue of the image, in degrees. If 0, no hue adjustment is applied.
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.Colorize">
            <summary>
            When enabled, every pixel in the image will be re-colored to the <see cref="P:Sandbox.Resources.ImageFileGenerator.TargetColor"/> (interpolated by the alpha).
            </summary>
        </member>
        <member name="P:Sandbox.Resources.ImageFileGenerator.TargetColor">
            <summary>
            When <see cref="P:Sandbox.Resources.ImageFileGenerator.Colorize"/> is enabled, this is the target color that every pixel in the image will be re-colored to.
            </summary>
        </member>
        <member name="T:Sandbox.Resources.VTexWriter">
            <summary>
            The VTex format is:
            
            1. Header (width, depth etc)
            2. Extra data blocks
            3. Streaming Data (encoded textures)
            	- smallest mip 
            	- mip
            	- mip
            	- main texture
            
            </summary>
        </member>
        <member name="M:Sandbox.Resources.VTexWriter.CalculateFormat">
            <summary>
            Given what we know, work out the best texture
            </summary>
        </member>
        <member name="T:Sandbox.DecalDefinition">
            <summary>
            A decal which can be applied to objects and surfaces.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.ColorTexture">
            <summary>
            The color map to use for the decal including transparency which masks the decal.
            This must be set for other textures to use the decal mask.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.NormalTexture">
            <summary>
            The normal texture map to use for the decal.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.RoughMetalOcclusionTexture">
            <summary>
            The Roughness/Metal/Ambient Occlusion texture map to use for the decal, stored in the respective RGB channels.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.HeightTexture">
            <summary>
            The height texture to use for parallax mapping.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.ParallaxStrength">
            <summary>
            Strength of the parallax effect.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.Tint">
            <summary>
            Tints the color of the decal's albedo and can be used to adjust the overall opacity of the decal.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.ColorMix">
            <summary>
            Controls the opacity of the decal's color texture without reducing the impact of the normal or rmo texture.
            Set to 0 to create a normal/rmo only decal masked by the color textures alpha.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.Width">
            <summary>
            Width of the decal.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.Height">
            <summary>
            Height of the decal.
            </summary>
        </member>
        <member name="T:Sandbox.GameResource">
            <summary>
            Assets defined in C# and created through tools.
            You can define your own <a href="https://sbox.game/dev/doc/assetsresources/custom-assets/">Custom Asset Types</a>.
            </summary>
        </member>
        <member name="P:Sandbox.GameResource.ProcessSerializedObject">
            <summary>
            Allows tools to post process the serialized json object
            </summary>
        </member>
        <member name="F:Sandbox.GameResource._jsonHash">
            <summary>
            The last saved compiled hash for this file.
            </summary>
        </member>
        <member name="P:Sandbox.GameResource.LastSavedSourceHash">
            <summary>
            The last saved uncompiled hash for this file. We use this to detect external changes in the editor, it's never serialized.
            </summary>
        </member>
        <member name="P:Sandbox.GameResource.ActionGraphCache">
            <summary>
            Re-use ActionGraph instances when deserializing this resource.
            </summary>
        </member>
        <member name="P:Sandbox.GameResource.HasUnsavedChanges">
            <summary>
            True if this resource has changed but the changes aren't written to disk
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.StateHasChanged">
            <summary>
            Should be called after the resource has been edited by the inspector
            </summary>
        </member>
        <member name="F:Sandbox.GameResource._awaitingLoad">
            <summary>
            True if we're waiting for our load to complete
            </summary>
        </member>
        <member name="P:Sandbox.GameResource.IsPromise">
            <summary>
            True if we're a promise, waiting to finalize the load
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.GetReferencedPackages">
            <summary>
            Get a list of packages that are needed to load this asset
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.PostLoad">
            <summary>
            Called when the asset is first loaded from disk.
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.PostReload">
            <summary>
            Called when the asset is recompiled/reloaded from disk.
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.GetPromise(System.Type,System.String)">
            <summary>
            Creates an instance of this type that will get loaded into later. This allows us to
            have resources that reference other resources that aren't loaded yet (or are missing).
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.Register(System.String)">
            <summary>
            Makes sure all properties are derived properly from filename, and then registered to ResourceLibrary
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.Load``1(System.String)">
            <summary>
            Loads a game resource from given file.
            </summary>
        </member>
        <member name="P:Sandbox.GameResource.ActionGraphTargetType">
            <summary>
            Target type used for any action graphs contained in this resource.
            Defaults to this resource's type.
            </summary>
        </member>
        <member name="P:Sandbox.GameResource.ActionGraphTarget">
            <summary>
            Target instance used for any action graphs contained in this resource.
            Defaults to this resource itself.
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.PushSerializationScope">
            <summary>
            Pushes a context in which action graphs belonging to this resource can be serialized or deserialized.
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.Serialize">
            <summary>
            Serialize the current state to a JsonObject
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.JsonUpgrade(System.Text.Json.Nodes.JsonObject)">
            <summary>
            called to upgrade a bunch of json to the latest version
            </summary>
            <param name="node"></param>
        </member>
        <member name="P:Sandbox.GameResource.ResourceVersion">
            <summary>
            The version of the component. Used by <see cref="T:Sandbox.JsonUpgrader"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.Deserialize(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Deserialize values from a JsonObject
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.OnJsonSerialize(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Called after we serialize, allowing you to store any extra or modify the output.
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.OnDestroy">
            <summary>
            Called when this resource is being unloaded.
            Clean up any resources owned by this instance here.
            </summary>
        </member>
        <member name="T:Sandbox.AssetTypeAttribute">
            <summary>
            Should be applied to a class that inherits from <see cref="T:Sandbox.GameResource"/>.
            Makes the class able to be stored as an asset on disk.
            </summary>
        </member>
        <member name="P:Sandbox.AssetTypeAttribute.TargetType">
            <summary>
            This gets filled in by the TypeLibrary when the class is registered, it shouldn't be changed manually.
            </summary>
        </member>
        <member name="P:Sandbox.AssetTypeAttribute.Name">
            <summary>
            The title of this game resource.
            </summary>
        </member>
        <member name="P:Sandbox.AssetTypeAttribute.Extension">
            <summary>
            File extension for this game resource.
            </summary>
        </member>
        <member name="P:Sandbox.AssetTypeAttribute.Category">
            <summary>
            Category of this game resource, for grouping in UI.
            </summary>
        </member>
        <member name="P:Sandbox.AssetTypeAttribute.Flags">
            <summary>
            Flags for this asset type.
            </summary>
        </member>
        <member name="T:Sandbox.AssetTypeFlags">
            <summary>
            Flags for <see cref="T:Sandbox.AssetTypeAttribute"/>
            </summary>
        </member>
        <member name="F:Sandbox.AssetTypeFlags.NoEmbedding">
            <summary>
            If set then this resource cannot be embedded. This means that in the editor
            it can only really exist as an asset file on disk, not inside another asset.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.Icon">
            <summary>
            Icon to be used for this asset
            Can be an absolute path of a PNG
            Or a <a href="https://fonts.google.com/icons">material icon</a> for this game resource's thumbnail.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.IconBgColor">
            <summary>
            Background color for this resource's thumbnail.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.IconFgColor">
            <summary>
            Foreground color (icon color) for this resource's thumbnail.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.CanEmbed">
            <summary>
            Can this GameResource be an embedded resource?
            Allows the ability to edit a resource inline instead of saving it to a specific file.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.Description">
            <summary>
            Description of this game resource. This is obsolete, we'll use the xml summary description.
            </summary>
        </member>
        <member name="T:Sandbox.Material">
            <summary>
            A material. Uses several <see cref="T:Sandbox.Texture"/>s and a <see cref="P:Sandbox.Material.Shader"/> with specific settings for more interesting visual effects.
            </summary>
        </member>
        <member name="P:Sandbox.Material.Name">
            <summary>
            Name (or path) of the material.
            </summary>
        </member>
        <member name="P:Sandbox.Material.Attributes">
            <summary>
            Access to all of the attributes of this material.
            </summary>
        </member>
        <member name="M:Sandbox.Material.Create(System.String,System.String,System.Boolean)">
            <summary>
            Create a new empty material at runtime.
            </summary>
            <param name="materialName">Name of the new material.</param>
            <param name="shader">Shader that the new material will use.</param>
            <param name="anonymous">If false, material can be found by name.</param>
            <returns>The new material.</returns>
        </member>
        <member name="M:Sandbox.Material.FromShader(Sandbox.Shader)">
            <summary>
            Get an empty material based on the specified shader. This will cache the material so that subsequent calls
            will return the same material.
            </summary>
        </member>
        <member name="M:Sandbox.Material.FromShader(System.String)">
            <summary>
            Get an empty material based on the specified shader. This will cache the material so that subsequent calls
            will return the same material.
            </summary>
        </member>
        <member name="M:Sandbox.Material.#ctor(NativeEngine.IMaterial,System.String)">
            <summary>
            Private constructor, use <see cref="M:Sandbox.Material.FromNative(NativeEngine.IMaterial,System.String)"/>
            </summary>
            <param name="native"></param>
            <param name="name"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Sandbox.Material.CreateCopy">
            <summary>
            Create a copy of this material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Vector4)">
            <summary>
            Overrides/Sets an Vector4 within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Sandbox.Texture)">
            <summary>
            Override/Sets texture parameter (Color, Normal, etc)
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Color)">
            <summary>
            Overrides/Sets an color within the material as a color value within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Vector3)">
            <summary>
            Overrides/Sets an Vector3 within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Vector2)">
            <summary>
            Overrides/Sets an Vector2 within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,System.Single)">
            <summary>
            Overrides/Sets an float within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,System.Int32)">
            <summary>
            Overrides/Sets an int within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,System.Boolean)">
            <summary>
            Overrides/Sets an bool within the material
            </summary>
        </member>
        <member name="P:Sandbox.Material.ShaderName">
            <summary>
            Gets the underlying shader name for this material.
            </summary>
        </member>
        <member name="P:Sandbox.Material.Shader">
            <summary>
            Gets the material's shader
            </summary>
        </member>
        <member name="P:Sandbox.Material.Flags">
            <summary>
            Access flags on this material, which usually hint about the contents. These are generally added by 
            the shader procedurally - but developers can add these in material editor too.
            </summary>
        </member>
        <member name="M:Sandbox.Material.Load(System.String)">
            <summary>
            Load a material from disk. Has internal cache.
            </summary>
            <param name="filename">The filepath to load the material from.</param>
            <returns>The loaded material, or null</returns>
        </member>
        <member name="M:Sandbox.Material.LoadAsync(System.String)">
            <summary>
            Load a material from disk. Has internal cache.
            </summary>
            <param name="filename">The filepath to load the material from.</param>
            <returns>The loaded material, or null</returns>
        </member>
        <member name="M:Sandbox.Material.FromNative(NativeEngine.IMaterial,System.String)">
            <summary>
            Try to make it so only one Material class exists for each material
            </summary>
        </member>
        <member name="T:Sandbox.Material.UI">
            <summary>
            Static materials for UI rendering purposes.
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.Basic">
            <summary>
            As basic 2D drawing material. Supports Texture and vertex color.
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.Box">
            <summary>
            CSS Box rendering
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.BoxShadow">
            <summary>
            CSS Box Shadow rendering
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.Text">
            <summary>
            CSS Text Rendering
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.BorderWrap">
            <summary>
            For filter: border-wrap( ... );
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.DropShadow">
            <summary>
            For filter: drop-shadow( ... );
            </summary>
        </member>
        <member name="T:Sandbox.MeshPrimitiveType">
            <summary>
            Possible primitive types of a <see cref="T:Sandbox.Mesh"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Mesh">
             <summary>
             A <a href="https://en.wikipedia.org/wiki/Polygon_mesh">mesh</a> is a basic version of a <see cref="T:Sandbox.Model"/>,
             containing a set of vertices and indices which make up faces that make up a shape.
            
             <para>A set of meshes can be used to create a <see cref="T:Sandbox.Model"/> via the <see cref="T:Sandbox.ModelBuilder"/> class.</para>
             </summary>
        </member>
        <member name="P:Sandbox.Mesh.IsValid">
            <inheritdoc cref="P:Sandbox.IValid.IsValid"/>
        </member>
        <member name="P:Sandbox.Mesh.PrimitiveType">
            <summary>
            Sets the primitive type for this mesh.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.Material">
            <summary>
            Sets material for this mesh.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.Bounds">
            <summary>
            Sets AABB bounds for this mesh.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.UvDensity">
            <summary>
            Used to calculate texture size for texture streaming.
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexRange(System.Int32,System.Int32)">
            <summary>
            Set how many vertices this mesh draws (if there's no index buffer)
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexRange(System.Int32,System.Int32)">
            <summary>
            Set how many indices this mesh draws
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateBuffers(Sandbox.VertexBuffer,System.Boolean)">
            <summary>
            Create vertex and index buffers.
            </summary>
            <param name="vb">Input vertex buffer. If it is indexed (<see cref="P:Sandbox.VertexBuffer.Indexed"/>), then index buffer will also be created.</param>
            <param name="calculateBounds">Whether to recalculate bounds from the vertex buffer.</param>
        </member>
        <member name="M:Sandbox.Mesh.TriangulatePolygon(System.Span{Vector3})">
            <summary>
            Triangulate a polygon made up of points, returns triangle indices into the list of vertices.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.HasIndexBuffer">
            <summary>
            Whether this mesh has an index buffer.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.IndexCount">
            <summary>
            Number of indices this mesh has.
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer">
            <summary>
            Create an empty index buffer, it can be resized later
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Span{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Span{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferSize(System.Int32)">
            <summary>
            Resize the index buffer.
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.HasVertexBuffer">
            <summary>
            Whether this mesh has a vertex buffer.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.VertexCount">
            <summary>
            Number of vertices this mesh has.
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(Sandbox.VertexAttribute[])">
            <summary>
            Create an empty vertex buffer, it can be resized later
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Collections.Generic.List{``0})">
            <summary>
            Create a vertex buffer with a number of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Span{``0})">
            <summary>
            Create a vertex buffer with a number of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Span{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferSize(System.Int32)">
            <summary>
            Resize the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.#ctor">
            <summary>
            Create an empty index buffer, it can be resized later
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.#ctor(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.#ctor(System.Int32,System.Span{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.SetData(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.SetData(System.Span{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.SetSize(System.Int32)">
            <summary>
            Resize the index buffer.
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.Lock(Sandbox.IndexBufferHandle.LockHandler)">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.Lock(System.Int32,Sandbox.IndexBufferHandle.LockHandler)">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.Lock(System.Int32,System.Int32,Sandbox.IndexBufferHandle.LockHandler)">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.SetSize(System.Int32)">
            <summary>
            Resize the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.SetData``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.SetData``1(System.Span{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.Lock``1(Sandbox.VertexBufferHandle.LockHandler{``0})">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.Lock``1(System.Int32,Sandbox.VertexBufferHandle.LockHandler{``0})">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.Lock``1(System.Int32,System.Int32,Sandbox.VertexBufferHandle.LockHandler{``0})">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.#ctor(Sandbox.VertexAttribute[])">
            <summary>
            Create an empty vertex buffer, it can be resized later
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.#ctor(System.Int32,Sandbox.VertexAttribute[],System.Collections.Generic.List{`0})">
            <summary>
            Create a vertex buffer with a number of vertices
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.#ctor(System.Int32,Sandbox.VertexAttribute[],System.Span{`0})">
            <summary>
            Create a vertex buffer with a number of vertices
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.SetSize(System.Int32)">
            <summary>
            Resize the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.SetData(System.Collections.Generic.List{`0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.SetData(System.Span{`0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.Lock(Sandbox.VertexBufferHandle{`0}.LockHandler)">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.Lock(System.Int32,Sandbox.VertexBufferHandle{`0}.LockHandler)">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.Lock(System.Int32,System.Int32,Sandbox.VertexBufferHandle{`0}.LockHandler)">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="T:Sandbox.BoneCollection">
            <summary>
            A collection of bones. This could be from a model, or an entity
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Root">
            <summary>
            Root bone of the model.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.AllBones">
            <summary>
            List of all bones of our object.
            </summary>
        </member>
        <member name="M:Sandbox.BoneCollection.HasBone(System.String)">
            <summary>
            Whether the model or entity has a given bone by name.
            </summary>
        </member>
        <member name="M:Sandbox.BoneCollection.GetBone(System.String)">
            <summary>
            Retrieve a bone by name.
            </summary>
        </member>
        <member name="T:Sandbox.BoneCollection.Bone">
            <summary>
            A bone in a <see cref="T:Sandbox.BoneCollection"/>.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.Index">
            <summary>
            Numerical index of this bone.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.Name">
            <summary>
            Name of this bone.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.Parent">
            <summary>
            The parent bone.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.LocalTransform">
            <summary>
            Transform on this bone, relative to the root bone.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.HasChildren">
            <summary>
            Whether this bone has any child bones.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.Children">
            <summary>
            List of all bones that descend from this bone.
            </summary>
        </member>
        <member name="M:Sandbox.BoneCollection.Bone.IsNamed(System.String)">
            <summary>
            Whether this bone has given name or not.
            </summary>
        </member>
        <member name="T:Sandbox.Model">
            <summary>
            A model.
            </summary>
        </member>
        <member name="P:Sandbox.Model.AnimationCount">
            <summary>
            Number of animations this model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetAnimationName(System.Int32)">
            <summary>
            Returns name of an animation at given animation index.
            </summary>
            <param name="animationIndex">Animation index to get name of, starting at 0.</param>
            <returns>Name of the animation.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,AnimationCount-1]</exception>
        </member>
        <member name="P:Sandbox.Model.AnimGraph">
            <summary>
            Get the animgraph this model uses.
            </summary>
        </member>
        <member name="P:Sandbox.Model.Attachments">
            <summary>
            Access to bones of this model.
            </summary>
        </member>
        <member name="P:Sandbox.Model.AttachmentCount">
            <summary>
            Returns amount of attachment points this model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetAttachment(System.String)">
            <summary>
            Retrieves attachment transform based on given attachment name.
            </summary>
            <param name="name">Name of the attachment to retrieve transform of.</param>
            <returns>The attachment transform, or null if attachment by given name is not found.</returns>
        </member>
        <member name="M:Sandbox.Model.GetAttachment(System.Int32)">
            <summary>
            Retrieves attachment transform based on given attachment index.
            </summary>
            <param name="index">>Index of the attachment to look up, starting at 0.</param>
            <returns>The attachment transform.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,AttachmentCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetAttachmentName(System.Int32)">
            <summary>
            Returns name of an attachment at given index.
            </summary>
            <param name="index">Index of the attachment to look up, starting at 0.</param>
            <returns>The name of the attachment at given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,AttachmentCount-1]</exception>
        </member>
        <member name="T:Sandbox.Model.BodyGroupMaskAttribute">
            <summary>
            Used to mark properties as a body group mask, so the correct editor can be used
            </summary>
        </member>
        <member name="P:Sandbox.Model.Bounds">
            <summary>
            Total bounds of all the meshes.
            </summary>
        </member>
        <member name="P:Sandbox.Model.PhysicsBounds">
            <summary>
            Total bounds of all the physics shapes.
            </summary>
        </member>
        <member name="P:Sandbox.Model.RenderBounds">
            <summary>
            Render view bounds.
            </summary>
        </member>
        <member name="M:Sandbox.Model.#ctor(NativeEngine.IModel,System.String,System.Boolean)">
            <summary>
            Private constructor, use <see cref="M:Sandbox.Model.FromNative(NativeEngine.IModel,System.Boolean,System.String)"/>
            </summary>
        </member>
        <member name="M:Sandbox.Model.OnReloaded">
            <summary>
            Called when the resource is reloaded. We should clear any cached values.
            </summary>
        </member>
        <member name="P:Sandbox.Model.IsError">
            <summary>
            Whether this model is an error model or invalid or not.
            </summary>
        </member>
        <member name="P:Sandbox.Model.Name">
            <summary>
            Name of the model, usually being its file path.
            </summary>
        </member>
        <member name="P:Sandbox.Model.IsProcedural">
            <summary>
            Whether this model is procedural, i.e. it was created at runtime via <see cref="M:Sandbox.ModelBuilder.Create"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Model.MeshCount">
            <summary>
            Total number of meshes this model is made out of.
            </summary>
        </member>
        <member name="P:Sandbox.Model.Trace">
            <summary>
            Trace against the triangles in this mesh
            </summary>
        </member>
        <member name="P:Sandbox.Model.CommonData.Health">
            <summary>
            If the prop is destructable this is its start health
            </summary>
        </member>
        <member name="P:Sandbox.Model.CommonData.Flammable">
            <summary>
            Should this prop explode when destroyed? If so, this is the radius of the damage from it.
            </summary>
        </member>
        <member name="P:Sandbox.Model.CommonData.Explosive">
            <summary>
            Should this prop explode when destroyed? If so, this is the radius of the damage from it.
            </summary>
        </member>
        <member name="P:Sandbox.Model.CommonData.ExplosionRadius">
            <summary>
            Should this prop explode when destroyed? If so, this is the radius of the damage from it.
            </summary>
        </member>
        <member name="P:Sandbox.Model.CommonData.ExplosionDamage">
            <summary>
            Should this prop explode when destroyed? If so, this is the radius of the damage from it.
            </summary>
        </member>
        <member name="P:Sandbox.Model.CommonData.ExplosionForce">
            <summary>
            Should this prop explode when destroyed? If so, this is the physics push force from it.
            </summary>
        </member>
        <member name="M:Sandbox.Model.TryGetData``1(``0@)">
            <summary>
            Tries to extract data from model based on the given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
            <param name="data">The extracted data, or default on failure.</param>
            <returns>true if data was extracted successfully, false otherwise.</returns>
        </member>
        <member name="M:Sandbox.Model.TryGetData(System.Type,System.Object@)">
            <summary>
            Tries to extract data from model based on the given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
            <param name="data">The extracted data, or default on failure.</param>
            <param name="t">The class with <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.</param>
            <returns>true if data was extracted successfully, false otherwise.</returns>
        </member>
        <member name="M:Sandbox.Model.HasData``1">
            <summary>
            Tests if this model has generic data based on given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            This will be faster than testing this via GetData<![CDATA[<>]]>()
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetData``1">
            <summary>
            Extracts data from model based on the given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetBreakCommands">
            <summary>
            Internal function used to get a list of break commands the model has.
            </summary>
        </member>
        <member name="P:Sandbox.Model.HitboxSet">
            <summary>
            Access to default hitbox set of this model
            </summary>
        </member>
        <member name="M:Sandbox.Model.Load(System.String)">
            <summary>
            Load a model by file path.
            </summary>
            <param name="filename">The file path to load as a model.</param>
            <returns>The loaded model, or null</returns>
        </member>
        <member name="M:Sandbox.Model.LoadAsync(System.String)">
            <summary>
            Load a model by file path.
            </summary>
            <param name="filename">The file path to load as a model.</param>
            <returns>The loaded model, or null</returns>
        </member>
        <member name="P:Sandbox.Model.MaterialGroupCount">
            <summary>
            Number of material groups this model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetMaterialGroupName(System.Int32)">
            <summary>
            Returns name of a material group at given group index.
            </summary>
            <param name="groupIndex">Group index to get name of, starting at 0.</param>
            <returns>Name of the group.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,MaterialGroupCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetMaterialGroupIndex(System.String)">
            <summary>
            Retrieves the index of a material group given its name.
            </summary>
            <param name="groupIndex">The name of the material group.</param>
            <returns>The index of the material group, or a negative value if the group does not exist.</returns>
        </member>
        <member name="P:Sandbox.Model.Materials">
            <summary>
            Retrieves an enumerable collection of all Materials on the meshes.
            This is fast, and cached. The order of these items is the same order used in ModelRenderer.Materials etc
            </summary>
            <returns>An ImmutableArray of Materials.</returns>
        </member>
        <member name="M:Sandbox.Model.GetMaterials(System.Int32)">
            <summary>
            Retrieves an enumerable collection of Materials belonging to a specified group.
            </summary>
            <param name="groupIndex">The index of the material group. Default value is 0.</param>
            <returns>An IEnumerable of Materials in the specified group.</returns>
        </member>
        <member name="M:Sandbox.Model.GetMaterials(System.String)">
            <summary>
            Retrieves an enumerable collection of Materials belonging to a specified group.
            </summary>
            <param name="groupName">The name of the material group.</param>
            <returns>An IEnumerable of Materials in the specified group.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the provided group name does not exist.</exception>
        </member>
        <member name="T:Sandbox.Model.MaterialGroupAttribute">
            <summary>
            Used to mark a property as a material group, for the editor
            </summary>
        </member>
        <member name="T:Sandbox.Model.MaterialOverrideAttribute">
            <summary>
            Used to mark a property as a material material override dictionary, for the editor
            </summary>
        </member>
        <member name="P:Sandbox.Model.Morphs">
            <summary>
            Access to bones of this model.
            </summary>
        </member>
        <member name="P:Sandbox.Model.MorphCount">
            <summary>
            Number of morph controllers this model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetMorphName(System.Int32)">
            <summary>
            Returns name of a morph controller at given index.
            </summary>
            <param name="morph">Morph controller index to get name of, starting at 0.</param>
            <returns>Name of the morph controller at given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,MorphCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetVisemeMorph(System.String,System.Int32)">
            <summary>
            Get morph weight for viseme.
            </summary>
        </member>
        <member name="P:Sandbox.Model.SequenceNames">
            <summary>
            List of sequence names this model has.
            </summary>
        </member>
        <member name="P:Sandbox.Model.Bones">
            <summary>
            Access to bones of this model.
            </summary>
        </member>
        <member name="P:Sandbox.Model.BoneCount">
            <summary>
            Number of bones this model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetBoneName(System.Int32)">
            <summary>
            Returns name of a bone at given bone index.
            </summary>
            <param name="boneIndex">Bone index to get name of, starting at 0.</param>
            <returns>Name of the bone.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,BoneCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetBoneParent(System.Int32)">
            <summary>
            Returns the id of given bone's parent bone.
            </summary>
            <param name="boneIndex">The bone to look up parent of.</param>
            <returns>The id of the parent bone, or -1 if given bone has no parent.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,BoneCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetBoneTransform(System.Int32)">
            <summary>
            Returns transform of given bone at bind position.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,BoneCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetBoneTransform(System.String)">
            <summary>
            Returns transform of given bone at bind position.
            </summary>
        </member>
        <member name="M:Sandbox.Model.CreateBoneObjects(Sandbox.GameObject)">
            <summary>
            Creates a dictionary of bone names to game objects, where each game object is a bone object in the scene.
            </summary>
        </member>
        <member name="M:Sandbox.Model.CreateBoneObjects(Sandbox.GameObject,Sandbox.BoneCollection.Bone,System.Collections.Generic.Dictionary{Sandbox.BoneCollection.Bone,Sandbox.GameObject})">
            <summary>
            Recursively creates game objects for each bone in the hierarchy, starting from the given root bone.
            </summary>
        </member>
        <member name="M:Sandbox.Model.FromNative(NativeEngine.IModel,System.Boolean,System.String)">
            <summary>
            Cached <see cref="T:Sandbox.Model"/> instance from native, or creates
            </summary>
        </member>
        <member name="P:Sandbox.Model.Builder">
            <summary>
            Returns a static <see cref="T:Sandbox.ModelBuilder"/> instance, allowing for runtime model creation.
            </summary>
        </member>
        <member name="P:Sandbox.Model.Cube">
            <summary>
            A cube model
            </summary>
        </member>
        <member name="P:Sandbox.Model.Sphere">
            <summary>
            A sphere model
            </summary>
        </member>
        <member name="P:Sandbox.Model.Plane">
            <summary>
            A plane model
            </summary>
        </member>
        <member name="P:Sandbox.Model.Error">
            <summary>
            An error model
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetVertices">
            <summary>
            Experimental!
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetIndices">
            <summary>
            Experimental!
            </summary>
        </member>
        <member name="T:Sandbox.AnimationBuilder">
            <summary>
            Provides ability to generate animations for a <see cref="T:Sandbox.Model"/> at runtime.
            See <see cref="M:Sandbox.ModelBuilder.AddAnimation(System.String,System.Single)"/>
            </summary>
        </member>
        <member name="P:Sandbox.AnimationBuilder.Name">
            <summary>
            The name of the animation.
            </summary>
        </member>
        <member name="P:Sandbox.AnimationBuilder.FrameRate">
            <summary>
            The frames per second of the animation.
            </summary>
        </member>
        <member name="P:Sandbox.AnimationBuilder.Looping">
            <summary>
            This animation loops.
            </summary>
        </member>
        <member name="P:Sandbox.AnimationBuilder.Delta">
            <summary>
            This animation "adds" to the base result.
            </summary>
        </member>
        <member name="P:Sandbox.AnimationBuilder.DisableInterpolation">
            <summary>
            This animation disables interpolation between frames.
            </summary>
        </member>
        <member name="P:Sandbox.AnimationBuilder.FrameCount">
            <summary>
            The number of frames in the animation.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationBuilder.WithName(System.String)">
            <summary>
            Sets the name of the animation.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationBuilder.WithFrameRate(System.Single)">
            <summary>
            Sets the frames per second of the animation.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationBuilder.WithLooping(System.Boolean)">
            <summary>
            Sets whether the animation loops.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationBuilder.WithDelta(System.Boolean)">
            <summary>
            Sets whether the animation adds to the base result.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationBuilder.WithInterpolationDisabled(System.Boolean)">
            <summary>
            Sets whether interpolation between frames is disabled.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationBuilder.AddFrame(System.Span{Transform})">
            <summary>
            Add bone transforms for a frame of animation.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationBuilder.AddFrame(System.Collections.Generic.List{Transform})">
            <summary>
            Add bone transforms for a frame of animation.
            </summary>
        </member>
        <member name="T:Sandbox.ModelBuilder">
            <summary>
            Provides ability to generate <see cref="T:Sandbox.Model"/>s at runtime.
            A static instance of this class is available at <see cref="P:Sandbox.Model.Builder"/>
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddAnimation(System.String,System.Single)">
            <summary>
            Adds an animation to this model and returns a builder to construct the animation.
            </summary>
            <param name="name">The name of the animation.</param>
            <param name="frameRate">The frames per second of the animation.</param>
            <returns>An <see cref="T:Sandbox.AnimationBuilder"/> instance to construct the animation.</returns>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithMass(System.Single)">
            <summary>
            Total mass of the physics body (Default is 1000)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithSurface(System.String)">
            <summary>
            Surface property to use for collision
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithLodDistance(System.Int32,System.Single)">
            <summary>
            LOD switch distance increment for each Level of Detail (LOD) level. (Default is 50)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionBox(Vector3,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add box collision shape.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionSphere(System.Single,Vector3)">
            <summary>
            Add sphere collision shape.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionCapsule(Vector3,Vector3,System.Single)">
            <summary>
            Add capsule collision shape.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionHull(System.Collections.Generic.List{Vector3},System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add a CONVEX hull collision shape.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionHull(System.Span{Vector3},System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add a CONVEX hull collision shape.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionMesh(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
            <summary>
            Add a CONCAVE mesh collision shape. (This shape can NOT be physically simulated)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionMesh(System.Span{Vector3},System.Span{System.Int32})">
            <summary>
            Add a CONCAVE mesh collision shape. (This shape can NOT be physically simulated)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddTraceMesh(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
            <summary>
            Add trace vertices for tracing against mesh
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddTraceMesh(System.Span{Vector3},System.Span{System.Int32})">
            <summary>
            Add trace vertices for tracing against mesh
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh)">
            <summary>
            Add a mesh.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[])">
            <summary>
            Add a bunch of meshes.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh,System.Int32)">
            <summary>
            Add a mesh to a Level of Detail (LOD) group.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[],System.Int32)">
            <summary>
            Add a bunch of meshes to a Level of Detail (LOD) group.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh,System.String,System.Int32)">
            <summary>
            Add a mesh to a body group choice.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh,System.Int32,System.String,System.Int32)">
            <summary>
            Add a mesh to a Level of Detail (LOD) and a body group choice.
            </summary>
        </member>
        <member name="T:Sandbox.ModelBuilder.Bone">
            <summary>
            A bone definition for use with <see cref="T:Sandbox.ModelBuilder"/>.
            </summary>
            <param name="Name">Name of the bone.</param>
            <param name="ParentName">Name of the parent bone.</param>
            <param name="Position">Position of the bone, relative to its parent.</param>
            <param name="Rotation">Rotation of the bone, relative to its parent.</param>
        </member>
        <member name="M:Sandbox.ModelBuilder.Bone.#ctor(System.String,System.String,Vector3,Rotation)">
            <summary>
            A bone definition for use with <see cref="T:Sandbox.ModelBuilder"/>.
            </summary>
            <param name="Name">Name of the bone.</param>
            <param name="ParentName">Name of the parent bone.</param>
            <param name="Position">Position of the bone, relative to its parent.</param>
            <param name="Rotation">Rotation of the bone, relative to its parent.</param>
        </member>
        <member name="P:Sandbox.ModelBuilder.Bone.Name">
            <summary>Name of the bone.</summary>
        </member>
        <member name="P:Sandbox.ModelBuilder.Bone.ParentName">
            <summary>Name of the parent bone.</summary>
        </member>
        <member name="P:Sandbox.ModelBuilder.Bone.Position">
            <summary>Position of the bone, relative to its parent.</summary>
        </member>
        <member name="P:Sandbox.ModelBuilder.Bone.Rotation">
            <summary>Rotation of the bone, relative to its parent.</summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBone(Sandbox.ModelBuilder.Bone)">
            <summary>
            Add a bone to the skeleton via a <see cref="T:Sandbox.ModelBuilder.Bone"/> struct.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBones(Sandbox.ModelBuilder.Bone[])">
            <summary>
            Add multiple bones to the skeleton.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBone(System.String,Vector3,Rotation,System.String)">
            <summary>
            Add a bone to the skeleton.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddAttachment(System.String,Vector3,Rotation,System.String)">
            <summary>
            Add an attachment to the skeleton.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the model by
            </summary>
            <param name="name">Desired model name</param>
        </member>
        <member name="M:Sandbox.ModelBuilder.Create">
            <summary>
            Finish creation of the model.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMaterialGroup(System.String)">
            <summary>
            Add a named material group builder.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBody(System.Single,Sandbox.Surface,System.String)">
            <summary>
            Adds a new physics body to this object.
            </summary>
            <param name="mass">The mass of the body. Default is <c>0</c>.</param>
            <param name="surface">The surface properties to apply. Default is <c>default</c>.</param>
            <param name="boneName">
            Optional name of the bone this body is attached to.  
            Leave empty for non-skeletal bodies.
            </param>
            <returns>
            A new <see cref="T:Sandbox.PhysicsBodyBuilder"/> for configuring the body.
            </returns>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddHingeJoint(System.Int32,System.Int32,System.Nullable{Transform},System.Nullable{Transform},System.Boolean)">
            <summary>
            Adds a hinge joint between two bodies, allowing rotation around a single axis.
            </summary>
            <param name="body1">The index of the first body.</param>
            <param name="body2">The index of the second body.</param>
            <param name="frame1">Optional joint frame in local space of body1.</param>
            <param name="frame2">Optional joint frame in local space of body2.</param>
            <param name="collision">Whether the connected bodies can collide.</param>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBallJoint(System.Int32,System.Int32,System.Nullable{Transform},System.Nullable{Transform},System.Boolean)">
            <summary>
            Adds a ball joint between two bodies, allowing free rotation within optional swing/twist limits.
            </summary>
            <param name="body1">The index of the first body.</param>
            <param name="body2">The index of the second body.</param>
            <param name="frame1">Optional joint frame in local space of body1.</param>
            <param name="frame2">Optional joint frame in local space of body2.</param>
            <param name="collision">Whether the connected bodies can collide.</param>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddFixedJoint(System.Int32,System.Int32,System.Nullable{Transform},System.Nullable{Transform},System.Boolean)">
            <summary>
            Adds a fixed joint between two bodies, locking their relative position and orientation.
            </summary>
            <param name="body1">The index of the first body.</param>
            <param name="body2">The index of the second body.</param>
            <param name="frame1">Optional joint frame in local space of body1.</param>
            <param name="frame2">Optional joint frame in local space of body2.</param>
            <param name="collision">Whether the connected bodies can collide.</param>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddSliderJoint(System.Int32,System.Int32,System.Nullable{Transform},System.Nullable{Transform},System.Boolean)">
            <summary>
            Adds a slider joint between two bodies, allowing motion along a single axis.
            </summary>
            <param name="body1">The index of the first body.</param>
            <param name="body2">The index of the second body.</param>
            <param name="frame1">Optional joint frame in local space of body1.</param>
            <param name="frame2">Optional joint frame in local space of body2.</param>
            <param name="collision">Whether the connected bodies can collide.</param>
        </member>
        <member name="P:Sandbox.ModelAttachments.Attachment.WorldTransform">
            <summary>
            Bone transformed LocalTransform
            </summary>
        </member>
        <member name="P:Sandbox.HitboxSet.Box.Shape">
            <summary>
            Either a Sphere, Capsule or BBox
            </summary>
        </member>
        <member name="P:Sandbox.HitboxSet.Box.RandomPointInside">
            <summary>
            Get a random point inside this hitbox
            </summary>
        </member>
        <member name="P:Sandbox.HitboxSet.Box.RandomPointOnEdge">
            <summary>
            Get a random point on the edge this hitbox
            </summary>
        </member>
        <member name="P:Sandbox.MaterialGroupBuilder.Name">
            <summary>
            The name of the material group.
            </summary>
        </member>
        <member name="M:Sandbox.MaterialGroupBuilder.WithName(System.String)">
            <inheritdoc cref="P:Sandbox.MaterialGroupBuilder.Name"/>
        </member>
        <member name="M:Sandbox.MaterialGroupBuilder.AddMaterial(Sandbox.Material)">
            <summary>
            Add a material to the group.
            </summary>
        </member>
        <member name="M:Sandbox.MaterialGroupBuilder.AddMaterials(System.Span{Sandbox.Material})">
            <summary>
            Add a materials to the group.
            </summary>
        </member>
        <member name="T:Sandbox.ModelMorphs">
            <summary>
            Allows fast lookups of morph variables
            </summary>
        </member>
        <member name="M:Sandbox.ModelMorphs.GetName(System.Int32)">
            <summary>
            Get the name of a morph by its index.
            </summary>
        </member>
        <member name="M:Sandbox.ModelMorphs.GetIndex(System.String)">
            <summary>
            Get the index of a morph by its name
            </summary>
        </member>
        <member name="M:Sandbox.ModelMorphs.Dispose">
            <summary>
            Clear it so it can't be used after disposed
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroupDescription.Surfaces">
            <summary>
            Enumerate every <see cref="T:Sandbox.Surface"/> in this <see cref="T:Sandbox.Model"/> 
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroupDescription.BodyPart.HullPart.GetLines">
            <summary>
            For debug rendering
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroupDescription.BodyPart.MeshPart.GetTriangles">
            <summary>
            For debug rendering
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsBodyBuilder">
            <summary>
            Provides ability to generate a physics body for a <see cref="T:Sandbox.Model"/> at runtime.
            See <see cref="M:Sandbox.ModelBuilder.AddBody(System.Single,Sandbox.Surface,System.String)"/>
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBodyBuilder.Mass">
            <summary>
            The mass of the body in kilograms.  
            Set to <c>0</c> to calculate automatically from its shapes and density.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBodyBuilder.Surface">
            <summary>
            The surface properties applied to this body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBodyBuilder.BindPose">
            <summary>
            The bind pose transform used when attaching this body to a bone.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBodyBuilder.BoneName">
            <summary>
            The name of the bone this body is attached to, or <c>null</c> if not attached.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBodyBuilder.SetMass(System.Single)">
            <inheritdoc cref="P:Sandbox.PhysicsBodyBuilder.Mass"/>
        </member>
        <member name="M:Sandbox.PhysicsBodyBuilder.SetSurface(Sandbox.Surface)">
            <inheritdoc cref="P:Sandbox.PhysicsBodyBuilder.Surface"/>
        </member>
        <member name="M:Sandbox.PhysicsBodyBuilder.SetBindPose(Transform)">
            <inheritdoc cref="P:Sandbox.PhysicsBodyBuilder.BindPose"/>
        </member>
        <member name="M:Sandbox.PhysicsBodyBuilder.SetBoneName(System.String)">
            <inheritdoc cref="P:Sandbox.PhysicsBodyBuilder.BoneName"/>
        </member>
        <member name="M:Sandbox.PhysicsBodyBuilder.AddSphere(Sandbox.Sphere,System.Nullable{Transform})">
            <summary>
            Add a sphere shape.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBodyBuilder.AddCapsule(Capsule,System.Nullable{Transform})">
            <summary>
            Add a capsule shape.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsBodyBuilder.SimplifyMethod">
            <summary>
            The method used to simplify a hull.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.SimplifyMethod.QEM">
            <summary>Quadratic Error Metric  prioritizes preserving shape accuracy.</summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.SimplifyMethod.IVR">
            <summary>Iterative Vertex Removal  removes vertices gradually.</summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.SimplifyMethod.None">
            <summary>No simplification  use the exact points provided.</summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.SimplifyMethod.IFR">
            <summary>Iterative Face Removal  removes faces to reduce complexity.</summary>
        </member>
        <member name="T:Sandbox.PhysicsBodyBuilder.HullSimplify">
            <summary>
            Settings for simplifying a hull shape.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.HullSimplify.AngleTolerance">
            <summary>Maximum allowed angle change between faces, in degrees.</summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.HullSimplify.DistanceTolerance">
            <summary>Maximum distance a vertex can be moved during simplification.</summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.HullSimplify.MaxFaces">
            <summary>Maximum number of faces allowed after simplification.</summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.HullSimplify.MaxEdges">
            <summary>Maximum number of edges allowed after simplification.</summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.HullSimplify.MaxVerts">
            <summary>Maximum number of vertices allowed after simplification.</summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyBuilder.HullSimplify.Method">
            <summary>The simplification method to use.</summary>
        </member>
        <member name="M:Sandbox.PhysicsBodyBuilder.AddHull(System.Span{Vector3},System.Nullable{Transform},System.Nullable{Sandbox.PhysicsBodyBuilder.HullSimplify})">
            <summary>
            Adds a convex hull shape to this body.
            </summary>
            <param name="points">The points making up the hull.</param>
            <param name="transform">Optional local transform of the hull relative to the body.</param>
            <param name="simplify">Optional settings to reduce the complexity of the hull.</param>
            <exception cref="T:System.ArgumentException">Thrown if less than 3 points are provided.</exception>
        </member>
        <member name="M:Sandbox.PhysicsBodyBuilder.AddMesh(System.Span{Vector3},System.Span{System.UInt32},System.Span{System.Byte})">
            <summary>
            Adds a triangle mesh shape to this body.
            </summary>
            <param name="vertices">The mesh vertex positions.</param>
            <param name="indices">
            The mesh indices, grouped in triples to form triangles.  
            Must be a multiple of 3.
            </param>
            <param name="materials">
            Optional per-vertex material IDs.  
            Length must match <paramref name="vertices"/> count or be empty.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown if the mesh has fewer than 3 vertices,  
            if indices are not a multiple of 3,  
            or if material count does not match vertex count.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if any index refers to a vertex that does not exist.
            </exception>
        </member>
        <member name="T:Sandbox.PhysicsJointBuilder">
            <summary>
            Provides ability to generate a physics joint for a <see cref="T:Sandbox.Model"/> at runtime.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJointBuilder.Body1">
            <summary>
            The index of the first body connected by the joint.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJointBuilder.Body2">
            <summary>
            The index of the second body connected by the joint.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJointBuilder.Frame1">
            <summary>
            The joint frame in the local space of <see cref="P:Sandbox.PhysicsJointBuilder.Body1"/>.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJointBuilder.Frame2">
            <summary>
            The joint frame in the local space of <see cref="P:Sandbox.PhysicsJointBuilder.Body2"/>.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJointBuilder.EnableCollision">
            <summary>
            Whether the connected bodies can collide with each other.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJointBuilder.LinearStrength">
            <summary>
            The maximum linear force the joint can withstand before breaking.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJointBuilder.AngularStrength">
            <summary>
            The maximum angular force/torque the joint can withstand before breaking.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJointBuilderExtensions.WithBody1``1(``0,System.Int32)">
            <inheritdoc cref="P:Sandbox.PhysicsJointBuilder.Body1"/>
        </member>
        <member name="M:Sandbox.PhysicsJointBuilderExtensions.WithBody2``1(``0,System.Int32)">
            <inheritdoc cref="P:Sandbox.PhysicsJointBuilder.Body2"/>
        </member>
        <member name="M:Sandbox.PhysicsJointBuilderExtensions.WithFrame1``1(``0,Transform)">
            <inheritdoc cref="P:Sandbox.PhysicsJointBuilder.Frame1"/>
        </member>
        <member name="M:Sandbox.PhysicsJointBuilderExtensions.WithFrame2``1(``0,Transform)">
            <inheritdoc cref="P:Sandbox.PhysicsJointBuilder.Frame2"/>
        </member>
        <member name="M:Sandbox.PhysicsJointBuilderExtensions.WithCollision``1(``0,System.Boolean)">
            <inheritdoc cref="P:Sandbox.PhysicsJointBuilder.EnableCollision"/>
        </member>
        <member name="M:Sandbox.PhysicsJointBuilderExtensions.WithLinearStrength``1(``0,System.Single)">
            <inheritdoc cref="P:Sandbox.PhysicsJointBuilder.LinearStrength"/>
        </member>
        <member name="M:Sandbox.PhysicsJointBuilderExtensions.WithAngularStrength``1(``0,System.Single)">
            <inheritdoc cref="P:Sandbox.PhysicsJointBuilder.AngularStrength"/>
        </member>
        <member name="T:Sandbox.HingeJointBuilder">
            <summary>
            Provides ability to generate a hinge joint for a <see cref="T:Sandbox.Model"/> at runtime.
            </summary>
        </member>
        <member name="P:Sandbox.HingeJointBuilder.EnableTwistLimit">
            <summary>
            Whether the hinge enforces a twist angle limit.
            </summary>
        </member>
        <member name="P:Sandbox.HingeJointBuilder.TwistLimit">
            <summary>
            The minimum and maximum allowed twist angles (degrees).
            </summary>
        </member>
        <member name="P:Sandbox.HingeJointBuilder.EnableMotor">
            <summary>
            Whether the hinge's angular motor is enabled.
            </summary>
        </member>
        <member name="P:Sandbox.HingeJointBuilder.TargetVelocity">
            <summary>
            Target angular velocity for the motor.
            </summary>
        </member>
        <member name="P:Sandbox.HingeJointBuilder.MaxTorque">
            <summary>
            Maximum torque the motor may apply.
            </summary>
        </member>
        <member name="M:Sandbox.HingeJointBuilder.WithTwistLimit(System.Single,System.Single)">
            <inheritdoc cref="P:Sandbox.HingeJointBuilder.TwistLimit"/>
        </member>
        <member name="M:Sandbox.HingeJointBuilder.WithTargetVelocity(Vector3)">
            <inheritdoc cref="P:Sandbox.HingeJointBuilder.TargetVelocity"/>
        </member>
        <member name="M:Sandbox.HingeJointBuilder.WithMaxTorque(System.Single)">
            <inheritdoc cref="P:Sandbox.HingeJointBuilder.MaxTorque"/>
        </member>
        <member name="T:Sandbox.BallJointBuilder">
            <summary>
            Provides ability to generate a ball joint for a <see cref="T:Sandbox.Model"/> at runtime.
            </summary>
        </member>
        <member name="P:Sandbox.BallJointBuilder.EnableSwingLimit">
            <summary>
            Whether the joint enforces a swing angle limit.
            </summary>
        </member>
        <member name="P:Sandbox.BallJointBuilder.EnableTwistLimit">
            <summary>
            Whether the joint enforces a twist angle limit.
            </summary>
        </member>
        <member name="P:Sandbox.BallJointBuilder.SwingLimit">
            <summary>
            Maximum allowed swing angle in degrees.
            </summary>
        </member>
        <member name="P:Sandbox.BallJointBuilder.TwistLimit">
            <summary>
            Minimum and maximum allowed twist angles in degrees.
            </summary>
        </member>
        <member name="M:Sandbox.BallJointBuilder.WithSwingLimit(System.Single)">
            <inheritdoc cref="P:Sandbox.BallJointBuilder.SwingLimit"/>
        </member>
        <member name="M:Sandbox.BallJointBuilder.WithTwistLimit(System.Single,System.Single)">
            <inheritdoc cref="P:Sandbox.BallJointBuilder.TwistLimit"/>
        </member>
        <member name="T:Sandbox.FixedJointBuilder">
            <summary>
            Provides ability to generate a fixed joint for a <see cref="T:Sandbox.Model"/> at runtime.
            </summary>
        </member>
        <member name="P:Sandbox.FixedJointBuilder.LinearFrequency">
            <summary>
            The frequency of the joint's linear spring in hertz.
            Higher values make the joint stiffer in translation.
            </summary>
        </member>
        <member name="P:Sandbox.FixedJointBuilder.LinearDamping">
            <summary>
            The damping ratio for the joint's linear spring.
            Higher values reduce oscillation in translation.
            </summary>
        </member>
        <member name="P:Sandbox.FixedJointBuilder.AngularFrequency">
            <summary>
            The frequency of the joint's angular spring in hertz.
            Higher values make the joint stiffer in rotation.
            </summary>
        </member>
        <member name="P:Sandbox.FixedJointBuilder.AngularDamping">
            <summary>
            The damping ratio for the joint's angular spring.
            Higher values reduce oscillation in rotation.
            </summary>
        </member>
        <member name="M:Sandbox.FixedJointBuilder.WithLinearFrequency(System.Single)">
            <inheritdoc cref="P:Sandbox.FixedJointBuilder.LinearFrequency"/>
        </member>
        <member name="M:Sandbox.FixedJointBuilder.WithLinearDamping(System.Single)">
            <inheritdoc cref="P:Sandbox.FixedJointBuilder.LinearDamping"/>
        </member>
        <member name="M:Sandbox.FixedJointBuilder.WithAngularFrequency(System.Single)">
            <inheritdoc cref="P:Sandbox.FixedJointBuilder.AngularFrequency"/>
        </member>
        <member name="M:Sandbox.FixedJointBuilder.WithAngularDamping(System.Single)">
            <inheritdoc cref="P:Sandbox.FixedJointBuilder.AngularDamping"/>
        </member>
        <member name="T:Sandbox.SliderJointBuilder">
            <summary>
            Provides ability to generate a slider joint for a <see cref="T:Sandbox.Model"/> at runtime.
            </summary>
        </member>
        <member name="P:Sandbox.SliderJointBuilder.EnableLimit">
            <summary>
            Whether the joint enforces a translation limit along its axis.
            </summary>
        </member>
        <member name="P:Sandbox.SliderJointBuilder.Limit">
            <summary>
            The minimum and maximum allowed translation along the joint axis.
            </summary>
        </member>
        <member name="M:Sandbox.SliderJointBuilder.WithLimit(System.Single,System.Single)">
            <inheritdoc cref="P:Sandbox.SliderJointBuilder.Limit"/>
        </member>
        <member name="T:Sandbox.ParticleSnapshot">
            <summary>
            A particle snapshot that can be created procedurally.
            Contains a set of vertices that particle effects can address.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleSnapshot.Vertex">
            <summary>
            A vertex to update a particle snapshot with.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSnapshot.#ctor">
            <summary>
            Create new empty procedural particle snapshot.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSnapshot.Update(System.Span{Sandbox.ParticleSnapshot.Vertex})">
            <summary>
            Update this snapshot with a list of vertices.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleSystem">
            <summary>
            A particle effect system that allows for complex visual effects, such as
            explosions, muzzle flashes, impact effects, etc.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSystem.IsError">
            <summary>
            Whether the particle system is invalid, or has not yet loaded.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSystem.Name">
            <summary>
            Particle system file name.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSystem.Bounds">
            <summary>
            Static bounding box of the resource.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSystem.ChildCount">
            <summary>
            How many child particle systems do we have
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSystem.GetChild(System.Int32)">
            <summary>
            Returns child particle at given index.
            </summary>
            <param name="index">Index of child particle system, starting at 0.</param>
            <returns>Particle system</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,ChildCount-1]</exception>
        </member>
        <member name="M:Sandbox.ParticleSystem.Load(System.String)">
            <summary>
            Loads a particle system from given file.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSystem.LoadAsync(System.String)">
            <summary>
            Load a particle system by file path.
            </summary>
            <param name="filename">The file path to load as a particle system.</param>
            <returns>The loaded particle system, or null</returns>
        </member>
        <member name="T:Sandbox.Resource">
            <summary>
            A resource loaded in the engine, such as a <see cref="T:Sandbox.Model"/> or <see cref="T:Sandbox.Material"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Resource.GetAssetTypeIcon(System.Int32,System.Int32)">
            <summary>
            Get the icon for this type of asset. This is an icon that is shown in the editor.
            </summary>
        </member>
        <member name="M:Sandbox.Resource.CreateAssetTypeIcon(System.Int32,System.Int32)">
            <summary>
            Create an icon for this type of asset. This is an icon that is shown in the editor.
            </summary>
        </member>
        <member name="M:Sandbox.Resource.CreateSimpleAssetTypeIcon(System.String,System.Int32,System.Int32,System.Nullable{Color},System.Nullable{Color})">
            <summary>
            Create a simple icon using an icon. This is used by default for asset types.
            </summary>
        </member>
        <member name="P:Sandbox.Resource.ResourceId">
            <summary>
            ID of this resource,
            </summary>
        </member>
        <member name="P:Sandbox.Resource.ResourcePath">
            <summary>
            Path to this resource.
            </summary>
        </member>
        <member name="P:Sandbox.Resource.ResourceName">
            <summary>
            File name of the resource without the extension.
            </summary>
        </member>
        <member name="P:Sandbox.Resource.Manifest">
            <summary>
            This is what loads the resource. While this is alive the resource will be loaded.
            </summary>
        </member>
        <member name="P:Sandbox.Resource.HasUnsavedChanges">
            <summary>
            True if this resource has been changed but the changes aren't written to disk
            </summary>
        </member>
        <member name="M:Sandbox.Resource.SetIdFromResourcePath(System.String)">
            <summary>
            Sets the ResourcePath, ResourceName and ResourceId from a resource path
            </summary>
        </member>
        <member name="M:Sandbox.Resource.Load(System.Type,System.String)">
            <summary>
            Accessor for loading native resources, not great, doesn't need to handle GameResource
            </summary>
        </member>
        <member name="M:Sandbox.Resource.OnReloaded">
            <summary>
            Called by OnResourceReloaded when a resource has been reloaded
            </summary>
        </member>
        <member name="M:Sandbox.Resource.StateHasChanged">
            <summary>
            Should be called after the resource has been edited by the inspector
            </summary>
        </member>
        <member name="P:Sandbox.Resource.EmbeddedResource">
            <summary>
            Embedded data for this resource
            </summary>
        </member>
        <member name="M:Sandbox.Resource.Sandbox#IJsonConvert#JsonRead(System.Text.Json.Utf8JsonReader@,System.Type)">
            <summary>
            Read the resource from a JSON element. This is usually a string, describing the path to the resource
            </summary>
        </member>
        <member name="M:Sandbox.Resource.Sandbox#IJsonConvert#JsonWrite(System.Object,System.Text.Json.Utf8JsonWriter)">
            <summary>
            Write the resource reference to a json element. This is usually a string, describing the path to the resource
            </summary>
        </member>
        <member name="M:Sandbox.Resource.LoadFromPath(System.Type,System.String)">
            <summary>
            Load a resource from a path with improved deferred loading support
            </summary>
        </member>
        <member name="M:Sandbox.Resource.LoadJsonReference(System.Type,System.Text.Json.Utf8JsonReader@)">
            <summary>
            Load a resource reference from JSON data.
            Handles both string paths and embedded resource objects for all resource types.
            </summary>
        </member>
        <member name="M:Sandbox.Resource.WriteJsonReference(System.Text.Json.Utf8JsonWriter)">
            <summary>
            Allows a resource type to override how it reference entry is written. This is generally
            just going to be a path to the on disk resource, but we can use this to store metadata too.
            </summary>
        </member>
        <member name="M:Sandbox.Resource.ConfigurePublishing(Sandbox.ResourcePublishContext)">
            <summary>
            When publishing an asset we'll call into this method to allow the resource to configure how it wants to be published.
            This allows your resource to make bespoke decisions to configure publishing based on its content.
            </summary>
        </member>
        <member name="M:Sandbox.Resource.RenderThumbnail(Sandbox.Resource.ThumbnailOptions)">
            <summary>
            Render a thumbnail for this specific resource.
            </summary>
        </member>
        <member name="T:Sandbox.ResourcePublishContext">
            <summary>
            Created by the editor when publishing a resource, passed into Resource.ConfigurePublishing. This allows
            the resource to configure how it wants to be published.
            </summary>
        </member>
        <member name="P:Sandbox.ResourcePublishContext.PublishingEnabled">
            <summary>
            Can be set to false using SetPublishingDisabled
            </summary>
        </member>
        <member name="P:Sandbox.ResourcePublishContext.ReasonForDisabling">
            <summary>
            If publishing is disabled this will be the message to display why.
            </summary>
        </member>
        <member name="M:Sandbox.ResourcePublishContext.SetPublishingDisabled(System.String)">
            <summary>
            Allows you to disable publishing for this resource, with a reason that'll be shown
            to the user.
            </summary>
        </member>
        <member name="P:Sandbox.ResourcePublishContext.CreateThumbnailFunction">
            <summary>
            A function to create a thumbnail for this resource. If not null, this will be called to create the thumbnail.
            </summary>
        </member>
        <member name="P:Sandbox.ResourcePublishContext.IncludeCode">
            <summary>
            If true we'll include the addon's code with this 
            </summary>
        </member>
        <member name="P:Sandbox.ResourcePublishContext.CanIncludeSourceFiles">
            <summary>
            If true then we'll offer an option to upload source files with this asset. This will make it easier for people
            who want to download and add it to their project, but make their own changes.
            </summary>
        </member>
        <member name="T:Sandbox.IResourceExtension">
            <summary>
            Describes a resource extension at a base level
            </summary>
        </member>
        <member name="M:Sandbox.IResourceExtension.FindAllTargetting(Sandbox.Resource)">
            <summary>
            Find all resources that are targetting a specific resource
            </summary>
        </member>
        <member name="M:Sandbox.IResourceExtension.FindAllTypes(Sandbox.Internal.TypeLibrary,System.Type)">
            <summary>
            Find all extensions that target a specific type.
            </summary>
        </member>
        <member name="T:Sandbox.ResourceExtension`1">
            <summary>
            A GameResource type that adds extended properties to another resource type. You should prefer to use
            the type with to generic arguments, and define your own type as the second argument. That way you get
            access to the helper methods.
            </summary>
        </member>
        <member name="P:Sandbox.ResourceExtension`1.ExtensionDefault">
            <summary>
            If true then this is returned when calling FindForResourceOrDefault if
            no other extension is found targetting a specific resource.
            </summary>
        </member>
        <member name="P:Sandbox.ResourceExtension`1.ExtensionTargets">
            <summary>
            Extensions can target more than one resource.
            </summary>
        </member>
        <member name="T:Sandbox.ResourceExtension`2">
            <summary>
            An extension of ResourceExtension[t], this gives special helper methods for retrieving resources targetting
            specific assets.
            </summary>
        </member>
        <member name="M:Sandbox.ResourceSystem.Get``1(System.Int32)">
            <summary>
            Get a cached resource by its hash.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="identifier">Resource hash to look up.</param>
        </member>
        <member name="M:Sandbox.ResourceSystem.Get``1(System.String)">
            <summary>
            Get a cached resource by its file path.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="filepath">File path to the resource.</param>
        </member>
        <member name="M:Sandbox.ResourceSystem.TryGet``1(System.String,``0@)">
            <summary>
            Try to get a cached resource by its file path.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="filepath">File path to the resource.</param>
            <param name="resource">The retrieved resource, if any.</param>
            <returns>True if resource was retrieved successfully.</returns>
        </member>
        <member name="M:Sandbox.ResourceSystem.GetAll``1">
            <summary>
            Get all cached resources of given type.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
        </member>
        <member name="M:Sandbox.ResourceSystem.GetAll``1(System.String,System.Boolean)">
            <summary>
            Get all cached resources of given type in a specific folder.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="filepath">The path of the folder to check.</param>
            <param name="recursive">Whether or not to check folders within the specified folder.</param>
        </member>
        <member name="M:Sandbox.ResourceSystem.ReadCompiledResourceJson(System.Span{System.Byte})">
            <summary>
            Read compiled resource as JSON from the provided buffer.
            </summary>
        </member>
        <member name="M:Sandbox.ResourceSystem.ReadCompiledResourceJson(Sandbox.BaseFileSystem,System.String)">
            <summary>
            Read compiled resource as JSON from the provided file path.
            </summary>
        </member>
        <member name="M:Sandbox.ResourceSystem.TryGetType(System.String,Sandbox.AssetTypeAttribute@)">
            <summary>
            Get the <see cref="T:Sandbox.AssetTypeAttribute"/> for a given extension.
            </summary>
        </member>
        <member name="M:Sandbox.ResourceSystem.LoadRawGameResource(System.String)">
            <summary>
            garry: why the fuck does this exist
            garry: fuck me why the fuck does this exist
            </summary>
        </member>
        <member name="M:Sandbox.ResourceSystem.LoadGameResource(Sandbox.AssetTypeAttribute,System.String,Sandbox.BaseFileSystem,System.Boolean)">
            <summary>
            Loads a Gameresource from disk. Doesn't look at cache. Registers the resource if successful.
            </summary>
        </member>
        <member name="M:Sandbox.ResourceSystem.InstallReferences(Sandbox.GameResource)">
            <summary>
            Installs all references for a GameResource 
            </summary>
        </member>
        <member name="T:Sandbox.ResourceLibrary">
            <summary>
            Keeps a library of all available <see cref="T:Sandbox.Resource"/>.
            </summary>
        </member>
        <member name="M:Sandbox.ResourceLibrary.Get``1(System.Int32)">
            <summary>
            Get a cached resource by its hash.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="identifier">Resource hash to look up.</param>
        </member>
        <member name="M:Sandbox.ResourceLibrary.Get``1(System.String)">
            <summary>
            Get a cached resource by its file path.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="filepath">File path to the resource.</param>
        </member>
        <member name="M:Sandbox.ResourceLibrary.TryGet``1(System.String,``0@)">
            <summary>
            Try to get a cached resource by its file path.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="filepath">File path to the resource.</param>
            <param name="resource">The retrieved resource, if any.</param>
            <returns>True if resource was retrieved successfully.</returns>
        </member>
        <member name="M:Sandbox.ResourceLibrary.GetAll``1">
            <summary>
            Get all cached resources of given type.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
        </member>
        <member name="M:Sandbox.ResourceLibrary.GetAll``1(System.String,System.Boolean)">
            <summary>
            Get all cached resources of given type in a specific folder.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="filepath">The path of the folder to check.</param>
            <param name="recursive">Whether or not to check folders within the specified folder.</param>
        </member>
        <member name="M:Sandbox.ResourceLibrary.LoadAsync``1(System.String)">
            <summary>
            Load a resource by its file path.
            </summary>
        </member>
        <member name="M:Sandbox.ResourceLibrary.IEventListener.OnRegister(Sandbox.GameResource)">
            <summary>
            Called when a new resource has been registered
            </summary>
        </member>
        <member name="M:Sandbox.ResourceLibrary.IEventListener.OnUnregister(Sandbox.GameResource)">
            <summary>
            Called when a previously known resource has been unregistered
            </summary>
        </member>
        <member name="M:Sandbox.ResourceLibrary.IEventListener.OnExternalChanges(Sandbox.GameResource)">
            <summary>
            Called when the source file of a known resource has been externally modified on disk
            </summary>
        </member>
        <member name="M:Sandbox.ResourceLibrary.IEventListener.OnExternalChangesPostLoad(Sandbox.GameResource)">
            <summary>
            Called when the source file of a known resource has been externally modified on disk
            and after it has been fully loaded (after post load is called)
            </summary>
        </member>
        <member name="T:Sandbox.PrefabFile">
            <summary>
            A GameObject which is saved to a file.
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.RootObject">
            <summary>
            Contains the original JSON read from File.
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.CachedScene">
            <summary>
            This is used as a reference
            </summary>
        </member>
        <member name="M:Sandbox.PrefabFile.GetScene">
            <summary>
            Get the actual scene scene
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.ShowInMenu">
            <summary>
            If true then we'll show this in the right click menu, so people can create it
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.MenuPath">
            <summary>
            If ShowInMenu is true, this is the path in the menu for this prefab
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.MenuIcon">
            <summary>
            Icon to show to the left of the option in the menu
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.DontBreakAsTemplate">
            <summary>
            If true then the prefab will not be broken when created as a template
            </summary>
        </member>
        <member name="M:Sandbox.PrefabFile.GetMetadata(System.String,System.String)">
            <summary>
            Read metadata saved using a ISceneMetadata based component, such as SceneInformation
            </summary>
        </member>
        <member name="F:Sandbox.PrefabFile._objectDictKey">
            <summary>
            If this instance is stored in <see cref="P:Sandbox.PrefabFile.ObjectsById"/>, what's the key?
            </summary>
        </member>
        <member name="M:Sandbox.PrefabFile.Register">
            <summary>
            Add this instance to <see cref="P:Sandbox.PrefabFile.ObjectsById"/>, indexed by Guid. If the Guid has changed,
            removes the old entry.
            </summary>
        </member>
        <member name="M:Sandbox.PrefabFile.Unregister">
            <summary>
            Remove this instance from <see cref="P:Sandbox.PrefabFile.ObjectsById"/>.
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.ObjectsById">
            <summary>
            We store each prefabfile in here indexed by their root object id, allowing
            us to discuss them over the network, because the net system will be able to
            look the GameObject up.
            </summary>
        </member>
        <member name="M:Sandbox.PrefabFile.FindByGuid(System.Guid)">
            <summary>
            We can look up prefabfile by their object guid
            </summary>
        </member>
        <member name="M:Sandbox.PrefabFile.Upgrader_v1(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Version 0 to 1
            - "Id" changed to "__guid"
            </summary>
        </member>
        <member name="M:Sandbox.PrefabFile.Upgrader_v2(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Version 1 to 2
            - Add "Children" and "Components" array if they don't exist
            - Add Flags if they don't exist
            </summary>
        </member>
        <member name="T:Sandbox.PrefabVariable">
            <summary>
            A prefab variable definition
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Id">
            <summary>
            A unique id for this variable. This is what it will be referred to in code.
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Title">
            <summary>
            A user friendly title for this variable
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Description">
            <summary>
            A user friendly description for this variable
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Group">
            <summary>
            An optional group for this variable to belong to
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Order">
            <summary>
            Lower numbers appear first
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Targets">
            <summary>
            Component variables that are being targetted
            </summary>
        </member>
        <member name="M:Sandbox.PrefabVariable.AddTarget(System.Guid,System.String)">
            <summary>
            Add a target property
            </summary>
        </member>
        <member name="T:Sandbox.PrefabVariable.PrefabVariableTarget">
            <summary>
            Targets a property in a component or gameobject.
            </summary>
            <param name="Id">The Id of the gameobject or component.</param>
            <param name="Property">The name of the parameter on the target.</param>
        </member>
        <member name="M:Sandbox.PrefabVariable.PrefabVariableTarget.#ctor(System.Guid,System.String)">
            <summary>
            Targets a property in a component or gameobject.
            </summary>
            <param name="Id">The Id of the gameobject or component.</param>
            <param name="Property">The name of the parameter on the target.</param>
        </member>
        <member name="P:Sandbox.PrefabVariable.PrefabVariableTarget.Id">
            <summary>The Id of the gameobject or component.</summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.PrefabVariableTarget.Property">
            <summary>The name of the parameter on the target.</summary>
        </member>
        <member name="T:Sandbox.SceneFile">
            <summary>
            A scene file contains a collection of GameObject with Components and their properties.
            </summary>
        </member>
        <member name="M:Sandbox.SceneFile.Upgrader_v1(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Version 0 to 1
            - "Id" changed to "__guid"
            </summary>
        </member>
        <member name="M:Sandbox.SceneFile.Upgrader_v2(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Version 1 to 2
            - Title and Description moved to SceneInformation metadata component
            </summary>
        </member>
        <member name="M:Sandbox.SceneFile.Upgrader_v3(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Version 2 to 3
            - Add "Children" and "Components" array if they don't exist
            - Add Flags if they don't exist
            </summary>
        </member>
        <member name="T:Sandbox.Shader">
            <summary>
            A <a href="https://en.wikipedia.org/wiki/Shader">shader</a> is a specialized and complex computer program that use
            world geometry, materials and textures to render graphics.
            </summary>
        </member>
        <member name="M:Sandbox.Shader.LoadFromCompiledUnlessOutOfDate(System.String)">
            <summary>
            Loads from the compiled resource, unless it's out of date by comparing the md5
            in which case it just returns false 
            </summary>
        </member>
        <member name="M:Sandbox.Shader.LoadFromSourceChecksums(System.String)">
            <summary>
            Loads all shader programs from the shader source file, except those that are already loaded (from above, assumably)
            </summary>
        </member>
        <member name="M:Sandbox.Shader.LoadFromSource(System.String)">
            <summary>
            Loads all shader programs from the shader source file, except those that are already loaded (from above, assumably)
            </summary>
        </member>
        <member name="M:Sandbox.Shader.FromNative(NativeEngine.CVfx,System.String)">
            <summary>
            Try to make it so only one Shader class exists for each shader
            </summary>
        </member>
        <member name="M:Sandbox.Shader.Load(System.String)">
            <summary>
            Load a shader by file path.
            </summary>
            <param name="filename">The file path to load as a shader.</param>
            <returns>The loaded shader, or null</returns>
        </member>
        <member name="T:Sandbox.Soundscape">
            <summary>
            A soundscape is used for environmental ambiance of a map by playing a set of random sounds at given intervals.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.MasterVolume">
            <summary>
            All sound volumes in this soundscape will be scaled by this value.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.LoopedSounds">
            <summary>
            Sounds that are played constantly on a loop.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSounds">
            <summary>
            Sounds that are played at intervals.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.LoopedSound.SoundFile">
            <summary>
            The sound to play. It should have the looped flag set.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.LoopedSound.Volume">
            <summary>
            Sound volume.
            </summary>
        </member>
        <member name="M:Sandbox.Soundscape.LoopedSound.ToString">
            <summary>
            If true then the sound will come from a random direction in the world
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSound.SoundFile">
            <summary>
            The sound event to play.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSound.InstanceCount">
            <summary>
            How many instances of this sting should exist.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSound.RepeatTime">
            <summary>
            How often should this sound be repeated.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSound.Distance">
            <summary>
            How far away from the camera should the sound play.
            </summary>
        </member>
        <member name="T:Sandbox.SoundData">
            <summary>
            Raw PCM sound data, kind of like a bitmap but for sounds
            </summary>
        </member>
        <member name="T:Sandbox.SoundEvent">
            <summary>
            A sound event. It can play a set of random sounds with optionally random settings such as volume and pitch.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.UI">
            <summary>
            Is this sound 2D?
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Volume">
            <summary>
            How loud the sound should be.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Pitch">
            <summary>
            The base pitch of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Decibels">
            <summary>
            How loud is this sound, affects how far away it can be heard
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.SelectionMode">
            <summary>
            Selection strategy to use when picking from multiple sounds.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Sounds">
            <summary>
            A random sound from the list will be selected to be played.
            </summary> 
        </member>
        <member name="P:Sandbox.SoundEvent.Occlusion">
            <summary>
            Allow this sound to be occluded by geometry 
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Reflections">
            <summary>
            Allow this sound to trace reflections, allowing it to be heard indirectly
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.AirAbsorption">
            <summary>
            Allow this sound to be absorbed by air
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Transmission">
            <summary>
            Allow this sound to be transmitted through geometry
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.OcclusionRadius">
            <summary>
            The radius of this sound's occlusion in inches.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.DistanceAttenuation">
            <summary>
            Should the sound fade out over distance
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Distance">
            <summary>
            How many units the sound can be heard from.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Falloff">
            <summary>
            The falloff curve for the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.DefaultMixer">
            <summary>
            Default mixer to play this sound with if one isn't provided on play.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.InputIndex">
            <summary>
            Used for selection mode
            </summary>
        </member>
        <member name="T:Sandbox.SoundFile">
            <summary>
            A sound resource.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.OnSoundReloaded">
            <summary>
            Ran when the file is reloaded/recompiled, etc.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.IsLoaded">
            <summary>
            true if sound is loaded
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.Format">
            <summary>
            Format of the audio file.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.BitsPerSample">
            <summary>
            Bits per each sample of this sound file.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.Channels">
            <summary>
            Number of channels this audio file has.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.BytesPerSample">
            <summary>
            Bytes per each sample of this sound file.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.SampleFrameSize">
            <summary>
            Size of one sample, typically this would be "sample size * channel count", but can vary on audio format.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.Rate">
            <summary>
            Sample rate of this sound file, per second.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.Duration">
            <summary>
            Duration of the sound this sound file contains, in seconds.
            </summary>
        </member>
        <member name="M:Sandbox.SoundFile.Load(System.String)">
            <summary>
            Load a new sound from disk. Includes automatic caching.
            </summary>
            <param name="filename">The file path to load the sound from.</param>
            <returns>The loaded sound file, or null if failed.</returns>
        </member>
        <member name="M:Sandbox.SoundFile.Create(System.String,System.Span{System.Byte},System.Int32,System.UInt32,System.Int32,System.UInt32,System.Single,System.Boolean)">
            <summary>
            Load from PCM.
            </summary>
        </member>
        <member name="M:Sandbox.SoundFile.FromWav(System.String,System.Span{System.Byte},System.Boolean)">
            <summary>
            Load from WAV.
            </summary>
        </member>
        <member name="M:Sandbox.SoundFile.GetSamplesAsync">
            <summary>
            Request decompressed audio samples.
            </summary>
        </member>
        <member name="T:Sandbox.Sprite">
            <summary>
            Represents a sprite resource that can be static or animated. Sprites are rendererd using the SpriteRenderer component.
            </summary>
        </member>
        <member name="T:Sandbox.Sprite.LoopMode">
            <summary>
            The different loop modes for sprite animation.
            </summary>
        </member>
        <member name="F:Sandbox.Sprite.LoopMode.None">
            <summary>
            The animation will play from start to finish and then stop.
            </summary>
        </member>
        <member name="F:Sandbox.Sprite.LoopMode.Loop">
            <summary>
            The animation will play from start to finish and then loop back to the start.
            </summary>
        </member>
        <member name="F:Sandbox.Sprite.LoopMode.PingPong">
            <summary>
            The animation will play from start to finish and then backwards from finish to start before looping.
            </summary>
        </member>
        <member name="T:Sandbox.Sprite.Frame">
            <summary>
            Describes a single animation frame
            </summary>
        </member>
        <member name="T:Sandbox.Sprite.Animation">
            <summary>
            Contains one or multiple frames that can be played in sequence.
            </summary>
        </member>
        <member name="P:Sandbox.Sprite.Animation.Name">
            <summary>
            The name of the animation. Allows you to play specific animations by name.
            </summary>
        </member>
        <member name="P:Sandbox.Sprite.Animation.FrameRate">
            <summary>
            The speed of the animation in frames per second.
            </summary>
        </member>
        <member name="P:Sandbox.Sprite.Animation.Origin">
            <summary>
            The point at which the rendered sprite is anchored from. This means scaling/rotating a sprite will do so around the origin.
            </summary>
        </member>
        <member name="P:Sandbox.Sprite.Animation.LoopMode">
            <summary>
            The loop mode of the animation. This determines what should happen when the animation reaches the final frame in playback.
            </summary>
        </member>
        <member name="P:Sandbox.Sprite.Animation.Frames">
            <summary>
            A list of frames that make up the animation. Each frame is a texture that will be displayed in sequence.
            </summary>
        </member>
        <member name="P:Sandbox.Sprite.Animation.IsAnimated">
            <summary>
            True if we have more than one frame
            </summary>
        </member>
        <member name="P:Sandbox.Sprite.Animations">
            <summary>
            A list of animations that can be played. Some animations can consist of multiple frames.
            If a sprite is static, it will only contain a single default animation.
            </summary>
        </member>
        <member name="M:Sandbox.Sprite.GetAnimationIndex(System.String)">
            <summary>
            Get the index of an animation by its name. Returns -1 if not found.
            </summary>
            <param name="name">The name of the animation</param>
        </member>
        <member name="M:Sandbox.Sprite.GetAnimation(System.Int32)">
            <summary>
            Get an animation by its index. Returns null if out of bounds.
            </summary>
            <param name="index">The index of the animation</param>
        </member>
        <member name="M:Sandbox.Sprite.GetAnimation(System.String)">
            <summary>
            Get an animation by its name. Returns null if not found.
            </summary>
            <param name="name">The name of the animation</param>
        </member>
        <member name="M:Sandbox.Sprite.FromTexture(Sandbox.Texture)">
            <summary>
            Returns a sprite with a single frame animation using the provided texture.
            </summary>
            <param name="texture">The texture to be used</param>
        </member>
        <member name="M:Sandbox.Sprite.FromTextures(System.Collections.Generic.IEnumerable{Sandbox.Texture},System.Single)">
            <summary>
            Returns a sprite with a single animation using the provided textures as frames.
            </summary>
            <param name="textures">The textures to be used for the animation</param>
            <param name="frameRate">The frame rate of the animation</param>
        </member>
        <member name="T:Sandbox.Surface">
            <summary>
            A physics surface. This is applied to each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> and controls its physical properties and physics related sounds.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.BaseSurface">
            <summary>
            Filepath of the base surface. Use <see cref="M:Sandbox.Surface.SetBaseSurface(System.String)">SetBaseSurface</see> and <see cref="M:Sandbox.Surface.GetBaseSurface">GetBaseSurface</see>.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.AudioSurface">
            <summary>
            Defines the audio properties of this surface for Steam Audio
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Description">
            <summary>
            A concise description explaining what this surface property should be used for.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Friction">
            <summary>
            Friction of this surface material.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Elasticity">
            <summary>
            Controls bounciness.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Density">
            <summary>
            Density of this surface material. This affects things like automatic mass calculation.
            Density is in kg/m^3.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Thickness">
            <summary>
            If above 0, the object is considered hollow, and its auto generated mass is affected accordingly.
            Thickness is in inches.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.RollingResistance">
            <summary>
            Controls how easily rolling shapes (sphere, capsule) roll on surfaces.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.BounceThreshold">
            <summary>
            Velocity threshold, below which objects will not bounce due to their elasticity.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.GetBaseSurface">
            <summary>
            Returns the base surface of this surface, or null if we are the default surface.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.SetBaseSurface(System.String)">
            <summary>
            Sets the base surface by name.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.FindByIndex(System.Int32)">
            <summary>
            Find a surface by its index in the array. This is the fastest way to lookup, so it's
            passed from things like Traces since the index is going to be the same. It's important to
            know that this index shouldn't be saved or networked because it could differ between loads or clients.
            Instead send the name hash and look up using that.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.FindByName(System.String)">
            <summary>
            Returns a Surface from its name, or null
            </summary>
            <param name="name">The name of a surface property to look up</param>
            <returns>The surface with given name, or null if such surface property doesn't exist</returns>
        </member>
        <member name="M:Sandbox.Surface.PlayCollisionSound(Vector3,System.Single)">
            <summary>
            Play a collision sound based on this shape's surface. Can return null if sound is invalid, or too quiet to play.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.Regular">
            <summary>
            Spawn one of these particles on impact.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.Bullet">
            <summary>
            Spawn one of these particles when hit by a bullet.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.BulletDecal">
            <summary>
            Use one of these as the bullet impact decal.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.SoftParticles">
            <summary>
            Spawn one of these particles on impact.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.SoftDecal">
            <summary>
            Use one of these as a physics impact decal.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.HardParticles">
            <summary>
            Spawn one of these particles on impact.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.HardDecal">
            <summary>
            Use one of these as a physics impact decal.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffects">
            <summary>
            Impact effects of this surface material.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.RoughnessFactor">
            <summary>
            Similar to friction but only affects whether a scrape is rough or smooth.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.RoughThreshold">
            <summary>
            Surface roughness greater than this results in rough scrapes.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.SmoothParticles">
            <summary>
            Spawn one of these particle effects during a smooth scrape.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.RoughParticles">
            <summary>
            Spawn one of these particle effects during a rough scrape.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.SmoothDecal">
            <summary>
            Use one of these particles during a smooth scrape.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.RoughDecal">
            <summary>
            Use one of these particles during a rough scrape.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffects">
            <summary>
            Scrape effects of this surface material.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.OldSoundData.FootLeft">
            <summary>
            Left footstep sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.OldSoundData.FootRight">
            <summary>
            Right footstep sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.OldSoundData.FootLaunch">
            <summary>
            Jump sound for this surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.OldSoundData.FootLand">
            <summary>
            Landing sound for this surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.OldSoundData.Bullet">
            <summary>
            Bullet impact sound for this surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.OldSoundData.ImpactHard">
            <summary>
            Hard, high velocity impact sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.OldSoundData.ImpactSoft">
            <summary>
            Soft, low velocity impact sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.OldSoundData.ScrapeRough">
            <summary>
            Rough scraping sound when scraping against another surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.OldSoundData.ScrapeSmooth">
            <summary>
            Smooth scraping sound when scraping against another surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Sounds">
            <summary>
            Sounds associated with this surface material.
            </summary>
        </member>
        <member name="T:Sandbox.Surface.SurfacePrefabCollection">
            <summary>
            Holds a dictionary of common prefabs associated with a surface
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfacePrefabCollection.BulletImpact">
            <summary>
            A prefab to spawn when this surface is hit by a bullet. The prefab should be spawned facing the same direction as the hit normal. It could include decals and particle effects. It should be parented to the surface that it hit.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfacePrefabCollection.BluntImpact">
            <summary>
            A prefab to spawn when this surface is hit by something blunt. The prefab should be spawned facing the same direction as the hit normal. It could include decals and particle effects. It should be parented to the surface that it hit.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.PrefabCollection">
            <summary>
            Common prefabs for this surface material
            </summary>
        </member>
        <member name="T:Sandbox.Surface.SurfaceSoundCollection">
            <summary>
            Holds a dictionary of common sounds associated with a surface. This allows you to pick and choose an appropriate sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.FootLeft">
            <summary>
            Left footstep sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.FootRight">
            <summary>
            Right footstep sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.FootLaunch">
            <summary>
            Jump sound for this surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.FootLand">
            <summary>
            Landing sound for this surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.Bullet">
            <summary>
            Bullet impact sound for this surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.ImpactHard">
            <summary>
            Hard, high velocity impact sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.ImpactSoft">
            <summary>
            Soft, low velocity impact sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.ScrapeRough">
            <summary>
            Rough scraping sound when scraping against another surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.ScrapeSmooth">
            <summary>
            Smooth scraping sound when scraping against another surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SurfaceSoundCollection.Break">
            <summary>
            Sound to play when an object made of this breaks
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundCollection">
            <summary>
            Sounds for this surface material
            </summary>
        </member>
        <member name="F:Sandbox.Surface.TagList">
            <summary>
            Internal accessor for the surface's tags (stored as StringToken)
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Tags">
            <summary>
            A list of tags as one string.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.HasTag(System.String)">
            <summary>
            Do we have a tag?
            </summary>
            <param name="tag"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Surface.HasAllTags(System.String[])">
            <summary>
            Do we have all the tags on this hitbox?
            </summary>
            <param name="tags"></param>
            <returns>True if all tags match, false if any tag does not match.</returns>
        </member>
        <member name="M:Sandbox.Surface.HasAnyTags(System.String[])">
            <summary>
            Do we have all the tags on this hitbox?
            </summary>
            <param name="tags"></param>
            <returns>True if any tag matches, false if all tags do not match.</returns>
        </member>
        <member name="T:Sandbox.AudioSurface">
            <summary>
            Defines acoustic properties of a surface, which defines how sound will bounce
            </summary>
        </member>
        <member name="T:Sandbox.TerrainMaterial">
            <summary>
            Description of a Terrain Material.
            </summary>
        </member>
        <member name="T:Sandbox.TerrainStorage">
            <summary>
            Stores heightmaps, control maps and materials.
            </summary>
        </member>
        <member name="P:Sandbox.TerrainStorage.TerrainSize">
            <summary>
            Uniform world size of the width and length of the terrain.
            </summary>
        </member>
        <member name="P:Sandbox.TerrainStorage.TerrainHeight">
            <summary>
            World size of the maximum height of the terrain.
            </summary>
        </member>
        <member name="T:Sandbox.TerrainStorage.TerrainMaps">
            <summary>
            Contains terrain maps that get compressed
            </summary>
        </member>
        <member name="P:Sandbox.Bitmap.Size">
            <summary>
            The width and height of the bitmap
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.#ctor(SkiaSharp.SKBitmap)">
            <summary>
            Used internally for resizing operations
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.Clear(Color)">
            <summary>
            Clears the bitmap to the specified color.
            </summary>
            <param name="color">The color to fill the bitmap with.</param>
        </member>
        <member name="M:Sandbox.Bitmap.GetPixels">
            <summary>
            Retrieves the pixel data of the bitmap as an array of colors.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.GetPixels16">
            <summary>
            Retrieves the pixel data of the bitmap as an array of colors.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.GetPixels32">
            <summary>
            Retrieves the pixel data of the bitmap as an array of colors.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.GetPixel(System.Int32,System.Int32)">
            <summary>
            Retrieves the color of a specific pixel in the bitmap.
            </summary>
            <param name="x">The x-coordinate of the pixel.</param>
            <param name="y">The y-coordinate of the pixel.</param>
            <returns>The color of the pixel at the specified coordinates.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.SetPixel(System.Int32,System.Int32,Color)">
            <summary>
            Sets the color of a specific pixel in the bitmap.
            </summary>
            <param name="x">The x-coordinate of the pixel.</param>
            <param name="y">The y-coordinate of the pixel.</param>
            <param name="color">The color to set the pixel to.</param>
        </member>
        <member name="M:Sandbox.Bitmap.GetBuffer">
            <summary>
            Low level, get a span of the bitmap data.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.GetPointer">
            <summary>
            Super low level, get a pointer to the bitmap data.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.AssertBounds(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Asserts that the specified region is within the bounds of the bitmap.
            Throws an exception if the bounds are out of range.
            </summary>
            <param name="x">The x-coordinate of the starting point.</param>
            <param name="y">The y-coordinate of the starting point.</param>
            <param name="width">The width of the region to check.</param>
            <param name="height">The height of the region to check.</param>
        </member>
        <member name="M:Sandbox.Bitmap.Clone">
            <summary>
            Copy the bitmap to a new one without any changes.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.IsOpaque">
            <summary>
            Returns true if this bitmap is completely opaque (no alpha)
            This does a pixel by pixel search, so it's not the fastest.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.DrawRect(Sandbox.Rect)">
            <summary>
            Draws a rectangle using the current pen settings.
            </summary>
            <param name="rect">The rectangle to draw.</param>
        </member>
        <member name="M:Sandbox.Bitmap.DrawRect(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws a rectangle using the current pen settings.
            </summary>
            <param name="x">The x-coordinate of the top-left corner.</param>
            <param name="y">The y-coordinate of the top-left corner.</param>
            <param name="width">The width of the rectangle.</param>
            <param name="height">The height of the rectangle.</param>
        </member>
        <member name="M:Sandbox.Bitmap.DrawRoundRect(Sandbox.Rect,Sandbox.UI.Margin)">
            <summary>
            Draws a rectangle using the current pen settings.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.DrawCircle(Vector2,System.Single)">
            <summary>
            Draws a circle using the current pen settings.
            </summary>
            <param name="center">The center of the circle.</param>
            <param name="radius">The radius of the circle.</param>
        </member>
        <member name="M:Sandbox.Bitmap.DrawCircle(System.Single,System.Single,System.Single)">
            <summary>
            Draws a circle using the current pen settings.
            </summary>
            <param name="x">The x-coordinate of the circle's center.</param>
            <param name="y">The y-coordinate of the circle's center.</param>
            <param name="radius">The radius of the circle.</param>
        </member>
        <member name="M:Sandbox.Bitmap.DrawPolygon(Vector2[])">
            <summary>
            Draws a polygon using the current pen settings.
            </summary>
            <param name="points">The points of the polygon.</param>
        </member>
        <member name="M:Sandbox.Bitmap.DrawArc(Sandbox.Rect,System.Single,System.Single)">
            <summary>
            Draws an arc using the current pen settings.
            </summary>
            <param name="rect">The bounding rectangle of the arc.</param>
            <param name="startAngle">The starting angle of the arc, in degrees.</param>
            <param name="sweepAngle">The sweep angle of the arc, in degrees.</param>
        </member>
        <member name="M:Sandbox.Bitmap.DrawArc(Sandbox.Rect,System.Single,System.Single,System.Boolean)">
            <summary>
            Draws an arc using the current pen settings, with an option to connect to the center.
            </summary>
            <param name="rect">The bounding rectangle of the arc.</param>
            <param name="startAngle">The starting angle of the arc, in degrees.</param>
            <param name="sweepAngle">The sweep angle of the arc, in degrees.</param>
            <param name="useCenter">If true, connects the arc endpoints to the center point, forming a pie shape.</param>
        </member>
        <member name="M:Sandbox.Bitmap.DrawBitmap(Sandbox.Bitmap,Sandbox.Rect)">
            <summary>
            Draws another bitmap onto this bitmap.
            </summary>
            <param name="bitmap">The bitmap to draw.</param>
            <param name="destRect">The destination rectangle for the drawn bitmap.</param>
        </member>
        <member name="M:Sandbox.Bitmap.DrawLine(Vector2,Vector2)">
            <summary>
            Draws a line using the current pen settings.
            </summary>
            <param name="start">The starting point of the line.</param>
            <param name="end">The ending point of the line.</param>
        </member>
        <member name="M:Sandbox.Bitmap.DrawLines(Vector2[])">
            <summary>
            Draws connected lines through a series of points using the current pen settings.
            </summary>
            <param name="points">The points to connect with lines.</param>
        </member>
        <member name="M:Sandbox.Bitmap.Blur(System.Single,System.Boolean)">
            <summary>
            Applies a Gaussian blur effect to the current bitmap.
            </summary>
            <param name="radius">The radius of the blur, controlling its intensity. Must be non-negative.</param>
            <param name="tileClamp">Determines the behavior at the edges of the bitmap:
            <c>true</c> to clamp the edges (default), or <c>false</c> to repeat the edges.</param>
        </member>
        <member name="M:Sandbox.Bitmap.Sharpen(System.Single,System.Boolean)">
            <summary>
            Applies a Gaussian blur effect to the current bitmap.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.Adjust(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Adjusts brightness, contrast, and saturation in one pass.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.AdjustHue(System.Single)">
            <summary>
            Adjusts the hue of the bitmap.
            </summary>
            <param name="angle">The angle to rotate the hue, in degrees (0 to 360).</param>
        </member>
        <member name="M:Sandbox.Bitmap.Colorize(Color)">
            <summary>
            Color the bitmap using this color, respect alpha
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.Tint(Color)">
            <summary>
            Tint the bitmap using this color, respect alpha
            </summary>
            <param name="color"></param>
        </member>
        <member name="M:Sandbox.Bitmap.InsertPadding(Sandbox.UI.Margin)">
            <summary>
            Shrink the image by adding padding all around - without resizing the bitmap
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.Posterize(System.Int32)">
            <summary>
            Applies a posterize effect to the bitmap.
            </summary>
            <param name="levels">The number of color levels to reduce to (e.g., 2, 4, 8).</param>
        </member>
        <member name="M:Sandbox.Bitmap.HeightmapToNormalMap(System.Single)">
            <summary>
            Converts a heightmap to a normal map using parallel processing.
            </summary>
            <param name="strength">The strength of the normal map effect (default is 1.0).</param>
            <returns>The generated normal map as an SKBitmap.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.GetHeight(SkiaSharp.SKColor[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the height value from the pixel array, clamped to the edges.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.InvertColor">
            <summary>
            Inverts the colors of the bitmap while preserving alpha.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.CreateFromBytes(System.Byte[])">
            <summary>
            Loads a bitmap from the specified byte array.
            </summary>
            <param name="data">The byte array containing the image data.</param>
            <returns>A new <see cref="T:Sandbox.Bitmap"/> instance.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.IsIes(System.Byte[])">
            <summary>
            Return true if this data is a Ies file
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.CreateFromPsdBytes(System.Byte[])">
            <summary>
            Creates a Bitmap instance from PSD file data.
            </summary>
            <param name="data">Byte array containing the PSD file data.</param>
            <returns>A Bitmap instance if successful, or null if the data is not valid PSD.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.IsPsd(System.Byte[])">
            <summary>
            Checks if the provided byte array is a valid PSD file.
            </summary>
            <param name="data">Byte array to check.</param>
            <returns>True if the data is a PSD file, otherwise false.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.CreateFromSvgString(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{Vector2},System.Nullable{Vector2},System.Nullable{System.Single})">
            <summary>
            Create a bitmap from an SVG, with optional size
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.IsTga(System.Byte[])">
            <summary>
            Return true if this data is a Tga file
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.SetAntialias(System.Boolean)">
            <summary>
            Sets the pen for drawing with a solid color and stroke style.
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.SetBlendMode(Sandbox.BlendMode)">
            <summary>
            Sets the pen to use a specific blend mode.
            </summary>
            <param name="blendMode">The blend mode to apply.</param>
        </member>
        <member name="M:Sandbox.Bitmap.SetPen(Color,System.Single)">
            <summary>
            Sets the pen for drawing with a solid color and stroke style.
            </summary>
            <param name="color">The color of the pen.</param>
            <param name="width">The width of the pen in pixels.</param>
        </member>
        <member name="M:Sandbox.Bitmap.SetDashedPen(Color,System.Single,System.Single[])">
            <summary>
            Sets the pen for drawing dashed or dotted lines.
            </summary>
            <param name="color">The color of the pen.</param>
            <param name="width">The width of the pen in pixels.</param>
            <param name="dashPattern">An array defining the dash pattern (e.g., [10, 5] for 10px dash, 5px gap).</param>
        </member>
        <member name="M:Sandbox.Bitmap.SetFill(Color)">
            <summary>
            Sets the pen for drawing filled shapes with a solid color.
            </summary>
            <param name="color">The color to fill the shapes with.</param>
        </member>
        <member name="M:Sandbox.Bitmap.SetLinearGradient(Vector2,Vector2,Sandbox.Gradient)">
            <summary>
            Sets the pen for drawing with a linear gradient.
            </summary>
            <param name="start">the gradient's start point.</param>
            <param name="end">the gradient's end point.</param>
            <param name="gradient">The color of the gradient.</param>
        </member>
        <member name="M:Sandbox.Bitmap.SetRadialGradient(Vector2,System.Single,Sandbox.Gradient)">
            <summary>
            Sets the pen for drawing with a radial gradient.
            </summary>
            <param name="center">The gradient's center.</param>
            <param name="radius">The radius of the gradient.</param>
            <param name="gradient">The color of the gradient.</param>
        </member>
        <member name="M:Sandbox.Bitmap.ToJpg(System.Int32)">
            <summary>
            Exports the bitmap as a JPEG byte array with the specified quality.
            </summary>
            <param name="quality">The quality of the JPEG, between 0 and 100.</param>
            <returns>A byte array containing the JPEG image data.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.ToPng">
            <summary>
            Exports the bitmap as a PNG byte array.
            </summary>
            <returns>A byte array containing the PNG image data.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.ToBmp">
            <summary>
            Exports the bitmap as a BMP byte array.
            </summary>
            <returns>A byte array containing the BMP image data.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.ToWebP(System.Int32)">
            <summary>
            Exports the bitmap as an HDR WebP byte array with the specified quality.
            </summary>
            <param name="quality">The quality of the WebP image, between 0 and 100.</param>
            <returns>A byte array containing the WebP HDR image data.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.Encode(SkiaSharp.SKEncodedImageFormat,System.Int32)">
            <summary>
            Exports the bitmap to the specified image format with optional quality.
            </summary>
            <param name="format">The image format (e.g., PNG, JPEG, BMP).</param>
            <param name="quality">The quality of the image, used for formats like JPEG.</param>
            <returns>A byte array containing the image data.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.ToFormat(Sandbox.ImageFormat)">
            <summary>
            Exports the bitmap to the specified engine format
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.DrawText(Sandbox.TextRendering.Scope,Sandbox.Rect,Sandbox.TextFlag)">
            <summary>
            Draws text onto this bitmap
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.ToTexture(System.Boolean)">
            <summary>
            Try to create a texture from this bitmap
            </summary>
        </member>
        <member name="M:Sandbox.Bitmap.Rotate(System.Single)">
            <summary>
            Rotates the bitmap by the specified angle.
            </summary>
            <param name="degrees">The angle in degrees to rotate the bitmap.</param>
            <returns>A new <see cref="T:Sandbox.Bitmap"/> instance with the rotated image.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.Resize(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Resizes the bitmap to the specified dimensions and returns a new bitmap.
            </summary>
            <param name="newWidth">The new width of the bitmap.</param>
            <param name="newHeight">The new height of the bitmap.</param>
            <param name="smooth">Resample smoothly. If false this will be nearest neighbour.</param>
            <returns>A new <see cref="T:Sandbox.Bitmap"/> instance with the specified dimensions.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.FlipVertical">
            <summary>
            Flips the bitmap vertically.
            </summary>
            <returns>A new <see cref="T:Sandbox.Bitmap"/> instance with the flipped image.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.FlipHorizontal">
            <summary>
            Flips the bitmap horizontally.
            </summary>
            <returns>A new <see cref="T:Sandbox.Bitmap"/> instance with the flipped image.</returns>
        </member>
        <member name="M:Sandbox.Bitmap.Crop(Sandbox.Rect)">
            <summary>
            Crops the bitmap to the specified rectangle.
            </summary>
            <param name="rect">The rectangle to crop to.</param>
            <returns>A new <see cref="T:Sandbox.Bitmap"/> instance with the cropped image.</returns>
        </member>
        <member name="T:Sandbox.Texture">
            <summary>
            A texture is an image used in rendering. Can be a static texture loaded from disk, or a dynamic texture rendered to by code.
            Can also be 2D, 3D (multiple slices), or a cube texture (6 slices).
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateCustom">
            <summary>
            Begins creation of a custom texture. Finish by calling <see cref="M:Sandbox.TextureBuilder.Create(System.String,System.Boolean,System.ReadOnlySpan{System.Byte},System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Create(System.Int32,System.Int32,Sandbox.ImageFormat)">
            <summary>
            Begins creation of a custom texture. Finish by calling <see cref="M:Sandbox.Texture2DBuilder.Finish"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateVolume(System.Int32,System.Int32,System.Int32,Sandbox.ImageFormat)">
            <summary>
            Begins creation of a custom 3D texture. Finish by calling <see cref="M:Sandbox.Texture3DBuilder.Finish"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateCube(System.Int32,System.Int32,Sandbox.ImageFormat)">
            <summary>
            Begins creation of a custom cube texture. (A texture with 6 sides) Finish by calling <see cref="M:Sandbox.TextureCubeBuilder.Finish"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateArray(System.Int32,System.Int32,System.Int32,Sandbox.ImageFormat)">
            <summary>
            Begins creation of a custom texture array. Finish by calling <see cref="M:Sandbox.TextureArrayBuilder.Finish"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateRenderTarget">
            <summary>
            Begins creation of a <a href="https://en.wikipedia.org/wiki/Render_Target">render target</a>. Finish by calling <see cref="M:Sandbox.TextureBuilder.Create(System.String,System.Boolean,System.ReadOnlySpan{System.Byte},System.Int32)"/>.
            </summary>
            <returns>The texture builder to help build the render target.</returns>
        </member>
        <member name="M:Sandbox.Texture.CreateRenderTarget(System.String,Sandbox.ImageFormat,Vector2)">
            <summary>
            A convenience function to quickly create a <a href="https://en.wikipedia.org/wiki/Render_Target">render target</a>.
            </summary>
            <param name="name">A meaningless debug name for your texture.</param>
            <param name="format">The image format.</param>
            <param name="size">The size of the texture.</param>
            <returns>The newly created render target texture.</returns>
        </member>
        <member name="M:Sandbox.Texture.CreateRenderTarget(System.String,Sandbox.ImageFormat,Vector2,Sandbox.Texture)">
            <summary>
            This will create a <a href="https://en.wikipedia.org/wiki/Render_Target">render target</a> texture if <paramref name="oldTexture"/> is null or doesn't match what you've passed in. This is designed
            to be called regularly to resize your texture in response to other things changing (like the screen size, panel size etc).
            </summary>
            <param name="name">A meaningless debug name for your texture.</param>
            <param name="format">The image format.</param>
            <param name="size">The size of the texture.</param>
            <param name="oldTexture">A previously created texture.</param>
            <returns>Will return a new texture, or the <paramref name="oldTexture"/>.</returns>
        </member>
        <member name="M:Sandbox.Texture.CreateFromSvgSource(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{Color})">
            <summary>
            Create a texture from an SVG source
            </summary>
        </member>
        <member name="F:Sandbox.Texture.ParentObject">
            <summary>
            Allow the texture to keep a reference to its parent object (like a videoplayer).
            </summary>
        </member>
        <member name="F:Sandbox.Texture.IsDirty">
            <summary>
            Has the native handle changed?
            </summary>
        </member>
        <member name="P:Sandbox.Texture.IsError">
            <summary>
            Whether this texture is an error or invalid or not.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.#ctor(NativeEngine.ITexture)">
            <summary>
            Private constructor, use <see cref="M:Sandbox.Texture.FromNative(NativeEngine.ITexture)"/>
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Index">
            <summary>
            Texture index. Bit raw dog and needs a higher level abstraction.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CopyFrom(Sandbox.Texture)">
            <summary>
            Replace our strong handle with a copy of the strong handle of the passed texture
            Which means that this texture will invisibly become that texture.
            I suspect that there might be a decent way to do this in native using the resource system.
            In which case we should change all this code to use that way instead of doing this.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Width">
            <summary>
            Width of the texture in pixels.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Height">
            <summary>
            Height of the texture in pixels.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Depth">
            <summary>
            Depth of a 3D texture in pixels, or slice count for 2D texture arrays, or 6 for slices of cubemap.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Mips">
            <summary>
            Number of <a href="https://en.wikipedia.org/wiki/Mipmap">mip maps</a> this texture has.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Size">
            <summary>
            Returns a Vector2 representing the size of the texture (width, height)
            </summary>
        </member>
        <member name="P:Sandbox.Texture.IsLoaded">
            <summary>
            Whether this texture has finished loading or not.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.ImageFormat">
            <summary>
            Image format of this texture.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.LastUsed">
            <summary>
            Returns how many frames ago this texture was last used by the renderer
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Dispose">
            <summary>
            Will release the handle for this texture. If the texture isn't referenced by anything
            else it'll be released properly. This will happen anyway because it's called in the destructor.
            By calling it manually you're just telling the engine you're done with this texture right now
            instead of waiting for the garbage collector.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.SequenceData">
            <summary>
            If this texture is a sprite sheet, will return information about the sheet, which
            is generally used in the shader. You don't really need to think about the contents.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.SequenceCount">
            <summary>
            The count of sequences in this texture, if any. The rest of the sequence data is encoded into the texture itself.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.GetSequenceFrameCount(System.Int32)">
            <summary>
            Get the frame count for this sequence
            </summary>
        </member>
        <member name="M:Sandbox.Texture.GetSequenceLength(System.Int32)">
            <summary>
            Get the total length of this seqence
            </summary>
        </member>
        <member name="M:Sandbox.Texture.UpdateSheetInfo">
            <summary>
            TODO: Fill this out, build a structure of Sequence[] for people to access
            Then make it so we can actually preview them
            </summary>
        </member>
        <member name="M:Sandbox.Texture.MarkUsed(System.Int32)">
            <summary>
            Tells texture streaming this texture is being used.
            This is usually automatic, but useful for bindless pipelines.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.ReplacementAsync(System.Threading.Tasks.Task{Sandbox.Texture})">
            <summary>
            Mark this texture as loading, create a texture in a task, replace this texture with it, mark it as loaded.
            This is for situations where you create a placeholder texture then replace it with the real texture later.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Load(Sandbox.BaseFileSystem,System.String,System.Boolean)">
            <summary>
            Try to load a texture from given filesystem, by filename.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.LoadFromFileSystem(System.String,Sandbox.BaseFileSystem,System.Boolean)">
            <summary>
            Try to load a texture from given filesystem, by filename.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.LoadInternal(Sandbox.BaseFileSystem,System.String,System.Boolean)">
            <summary>
            All the helpers should flow through this to actually load
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Load(System.String,System.Boolean)">
            <summary>
            Try to load a texture.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.LoadAvatar(System.Int64,System.Int32)">
            <summary>
            Load avatar image of a Steam user (with a certain size if supplied).
            </summary>
            <param name="steamid">The SteamID of the user to load the avatar of.</param>
            <param name="size">The size of the avatar (Can be 32, 64, or 128. Defaults to 64 and rounds input to nearest of the three).</param>
            <returns>The avatar texture</returns>
        </member>
        <member name="M:Sandbox.Texture.LoadAvatar(System.String,System.Int32)">
            <inheritdoc cref="M:Sandbox.Texture.LoadAvatar(System.Int64,System.Int32)"/>
        </member>
        <member name="M:Sandbox.Texture.LoadAsync(Sandbox.BaseFileSystem,System.String,System.Boolean)">
            <summary>
            Load a texture asynchronously. Will return when the texture is loaded and valid.
            This is useful when loading textures from the web.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.LoadAsync(System.String,System.Boolean)">
            <summary>
            Load a texture asynchronously. Will return when the texture is loaded and valid.
            This is useful when loading textures from the web, or without any big loading hitches.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.LoadFromFileSystemAsync(System.String,Sandbox.BaseFileSystem,System.Boolean)">
            <summary>
            Load a texture asynchronously. Will return when the texture is loaded and valid.
            This is useful when loading textures from the web, or without any big loading hitches.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Find(System.String)">
            <summary>
            Try to get an already loaded texture.
            </summary>
            <param name="filepath">The filename of the texture.</param>
            <returns>The already loaded texture, or null if it was not yet loaded.</returns>
        </member>
        <member name="M:Sandbox.Texture.GetPixels(System.Int32)">
            <summary>
            Reads pixel colors from the texture at the specified mip level
            </summary>
        </member>
        <member name="M:Sandbox.Texture.GetPixels``1(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},System.Int32,System.Int32,System.Span{``0},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Reads a 2D range of pixel values from the texture at the specified mip level, writing to <paramref name="dstData"/>.
            This reads one slice from a 2D texture array or 3D texture volume.
            </summary>
            <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32"/>, <see cref="T:System.Single"/>, <see cref="T:System.UInt32"/> or <see cref="T:System.Byte"/>)</typeparam>
            <param name="srcRect">Pixel region to read.</param>
            <param name="slice">For 2D texture arrays or 3D texture volumes, which slice to read from.</param>
            <param name="mip">Mip level to read from.</param>
            <param name="dstData">Array to write to, starting at index 0 for the first read pixel.</param>
            <param name="dstFormat">Pixel format to use when writing to <paramref name="dstData"/>. We only support some common formats for now.</param>
            <param name="dstSize">Dimensions of destination pixel array. Matches <paramref name="srcRect"/> by default.</param>
        </member>
        <member name="M:Sandbox.Texture.GetPixels``1(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},System.Int32,System.Int32,System.Span{``0},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},System.Int32)">
            <summary>
            Reads a 2D range of pixel values from the texture at the specified mip level, writing to <paramref name="dstData"/>.
            This reads one slice from a 2D texture array or 3D texture volume.
            </summary>
            <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32"/>, <see cref="T:System.Single"/>, <see cref="T:System.UInt32"/> or <see cref="T:System.Byte"/>)</typeparam>
            <param name="srcRect">Pixel region to read.</param>
            <param name="slice">For 2D texture arrays or 3D texture volumes, which slice to read from.</param>
            <param name="mip">Mip level to read from.</param>
            <param name="dstData">Array to write to, starting at index 0 for the first read pixel.</param>
            <param name="dstFormat">Pixel format to use when writing to <paramref name="dstData"/>. We only support some common formats for now.</param>
            <param name="dstRect">Dimensions of destination pixel array. Matches <paramref name="srcRect"/> by default.</param>
            <param name="dstStride">Stride of the destination array, this is likely your width in pixels.</param>
        </member>
        <member name="M:Sandbox.Texture.GetPixels3D``1(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32},System.Int32,System.Span{``0},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32,System.Int32})">
            <summary>
            Reads a 3D range of pixel values from the texture at the specified mip level, writing to <paramref name="dstData"/>.
            This can be used with a 2D texture array, or a 3D volume texture.
            </summary>
            <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32"/>, <see cref="T:System.Single"/>, <see cref="T:System.UInt32"/> or <see cref="T:System.Byte"/>)</typeparam>
            <param name="srcBox">Pixel region to read.</param>
            <param name="mip">Mip level to read from.</param>
            <param name="dstData">Array to write to, starting at index 0 for the first read pixel.</param>
            <param name="dstFormat">Pixel format to use when writing to <paramref name="dstData"/>. We only support some common formats for now.</param>
            <param name="dstSize">Dimensions of destination pixel array. Matches <paramref name="srcBox"/> by default.</param>
        </member>
        <member name="M:Sandbox.Texture.GetPixel(System.Single,System.Single,System.Int32)">
            <summary>
            Reads a single pixel color.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.GetPixel3D(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Reads a single pixel color from a volume or array texture.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.GetPixelsAsync(System.Action{System.ReadOnlySpan{Color32}},System.Int32)">
            <summary>
            Asynchronously reads all pixel colors from the texture at the specified mip level.
            </summary>
            <param name="callback">Callback function that receives the pixel data when ready.</param>
            <param name="mip">Mip level to read from.</param>
            <remarks>
            This operation is asynchronous and won't block the calling thread while data is downloaded from the GPU.
            The data provided to the callback is only valid for the duration of the callback execution.
            Storing references to the Span beyond the callback's scope will result in undefined behavior.
            </remarks>
        </member>
        <member name="M:Sandbox.Texture.GetPixelsAsync``1(System.Action{System.ReadOnlySpan{``0}},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},System.Int32,System.Int32)">
            <summary>
            Asynchronously reads a 2D range of pixel values from the texture at the specified mip level.
            </summary>
            <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32"/>, <see cref="T:System.Single"/>, <see cref="T:System.UInt32"/> or <see cref="T:System.Byte"/>)</typeparam>
            <param name="callback">Callback function that receives the pixel data when ready.</param>
            <param name="dstFormat">Pixel format to use when writing to the destination buffer.</param>
            <param name="srcRect">Pixel region to read. If omitted full texture will be read.</param>
            <param name="slice">For 2D texture arrays or 3D texture volumes, which slice to read from.</param>
            <param name="mip">Mip level to read from.</param>
            <remarks>
            This operation is asynchronous and won't block the calling thread while data is downloaded from the GPU.
            The data provided to the callback is only valid for the duration of the callback execution.
            Storing references to the Span beyond the callback's scope will result in undefined behavior.
            </remarks>
        </member>
        <member name="M:Sandbox.Texture.GetPixelsAsync3D``1(System.Action{System.ReadOnlySpan{``0}},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32},System.Int32)">
            <summary>
            Asynchronously reads a 3D range of pixel values from the texture at the specified mip level.
            </summary>
            <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32"/>, <see cref="T:System.Single"/>, <see cref="T:System.UInt32"/> or <see cref="T:System.Byte"/>)</typeparam>
            <param name="callback">Callback function that receives the pixel data when ready.</param>
            <param name="dstFormat">Pixel format to use when writing to the destination buffer.</param>
            <param name="srcBox">Pixel region to read. If omitted full texture will be read.</param>
            <param name="mip">Mip level to read from.</param>
            <remarks>
            This operation is asynchronous and won't block the calling thread while data is downloaded from the GPU.
            The data provided to the callback is only valid for the duration of the callback execution.
            Storing references to the Span beyond the callback's scope will result in undefined behavior.
            </remarks>
        </member>
        <member name="M:Sandbox.Texture.GetBitmapAsync(System.Action{Sandbox.Bitmap},System.Int32)">
            <summary>
            Asynchronously reads the texture into a bitmap at the specified mip level.
            </summary>
            <param name="callback">Callback function that receives the bitmap when ready.</param>
            <param name="mip">Mip level to read from.</param>
            <remarks>
            This operation is asynchronous and won't block the calling thread while data is downloaded from the GPU.
            Unlike the other async methods, the Bitmap provided to the callback is valid beyond the callback's scope
            as it owns its memory.
            </remarks>
        </member>
        <member name="M:Sandbox.Texture.ConvertImageDataTo(System.ReadOnlySpan{System.Byte},Sandbox.ImageFormat,System.Span{System.Byte},Sandbox.ImageFormat,System.Int32,System.Int32)">
            <summary>
            Converts image data from one format to another and writes to an existing buffer.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Invalid">
            <summary>
            1x1 solid magenta colored texture.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.White">
            <summary>
            1x1 solid white opaque texture.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Black">
            <summary>
            1x1 solid black opaque texture.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Transparent">
            <summary>
            1x1 fully transparent texture.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Clear(Color)">
            <summary>
            Clear this texture with a solid color
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Update(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update this texture with given raw data.
            </summary>
            <param name="data">The raw data pixels, appropriate for this textures format.</param>
            <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="width">Width of the image contained in <paramref name="data"/>.</param>
            <param name="height">Height of the image contained in <paramref name="data"/>.</param>
        </member>
        <member name="M:Sandbox.Texture.Update``1(System.ReadOnlySpan{``0},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update this texture with given raw data.
            </summary>
            <param name="data">The raw data pixels, appropriate for this textures format.</param>
            <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="width">Width of the image contained in <paramref name="data"/>.</param>
            <param name="height">Height of the image contained in <paramref name="data"/>.</param>
        </member>
        <member name="M:Sandbox.Texture.Update(System.ReadOnlySpan{Color32},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update this texture with given raw data.
            </summary>
            <param name="data">The raw data pixels, appropriate for this textures format.</param>
            <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="width">Width of the image contained in <paramref name="data"/>.</param>
            <param name="height">Height of the image contained in <paramref name="data"/>.</param>
        </member>
        <member name="M:Sandbox.Texture.Update(Sandbox.Bitmap)">
            <summary>
            Update this texture from the bitmap
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Update3D(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update this 3D texture with given raw data.
            </summary>
            <param name="data">The raw data pixels, appropriate for this textures format.</param>
            <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="z">If updating a subsegment of the texture, this will be start coordinates on the target texture.</param>
            <param name="width">Width of the image contained in <paramref name="data"/>.</param>
            <param name="height">Height of the image contained in <paramref name="data"/>.</param>
            <param name="depth">Depth of the image contained in <paramref name="data"/>.</param>
        </member>
        <member name="M:Sandbox.Texture.Update(Color32,Sandbox.Rect)">
            <summary>
            Write a coloured rectangle to the texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Update(Color32,System.Single,System.Single)">
            <summary>
            Write a coloured pixel to the texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithSemiStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithDynamicUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithGPUOnlyUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithUAVBinding">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMips">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Nullable{System.Int32})"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMips(System.Int32)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Nullable{System.Int32})"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithFormat(Sandbox.ImageFormat)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithScreenFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithDepthFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample2X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample4X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample6X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample8X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample16X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithScreenMultiSample">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData(System.Byte[])">
            <inheritdoc cref="M:Sandbox.Texture2DBuilder.WithData(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data.
            </summary>
            <param name="data">Texture data.</param>
            <param name="dataLength">How big our texture data is.</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData``1(System.ReadOnlySpan{``0})">
            <summary>
            Initialize texture with pre-existing texture data.
            </summary>
            <typeparam name="T">Texture data type</typeparam>
            <param name="data">Texture data</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Use Multi-Sample Anti Aliasing (MSAA) of given sample count.
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size.
            </summary>
            <param name="width">Width in pixel.</param>
            <param name="height">Height in pixels.</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithSize(Vector2)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width and Height in pixels</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithSemiStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithDynamicUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithGPUOnlyUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithUAVBinding">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMips(System.Int32)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Nullable{System.Int32})"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithFormat(Sandbox.ImageFormat)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithScreenFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithDepthFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample2X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample4X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample6X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample8X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample16X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithScreenMultiSample">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithSize(System.Int32,System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
            <param name="depth">Depth in pixels</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithSize(Vector3)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width, Height and Depth in pixels</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithSemiStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithDynamicUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithGPUOnlyUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithUAVBinding">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMips(System.Int32)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Nullable{System.Int32})"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithFormat(Sandbox.ImageFormat)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithScreenFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithDepthFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample2X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample4X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample6X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample8X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample16X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithScreenMultiSample">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithCount(System.Int32)">
            <summary>
            Create texture array with this many textures
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithInitialColor(Color@)">
            <summary>
            Once the texture is created it will be cleared to this color
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithStaticUsage">
            <summary>
            Provides a hint to the GPU that this texture will not be modified.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithSemiStaticUsage">
            <summary>
            Provides a hint to the GPU that this texture will only be updated sometimes.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithDynamicUsage">
            <summary>
            Provides a hint to the GPU that this texture will be updated regularly. (almost every frame)
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithGPUOnlyUsage">
            <summary>
            Specify the texture to ONLY be used on the GPU on not allow CPU access.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample2X">
            <summary>
            Sets the texture to use 2x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample4X">
            <summary>
            Sets the texture to use 4x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample6X">
            <summary>
            Sets the texture to use 6x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample8X">
            <summary>
            Sets the texture to use 8x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample16X">
            <summary>
            Sets the texture to use 16x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithScreenMultiSample">
            <summary>
            Sets the texture to use the same multisampling as whatever the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)">
            <summary>
            The internal texture format to use.
            </summary>
            <param name="format">Texture format</param>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithScreenFormat">
            <summary>
            Sets the internal texture format to use the same format as the screen/frame buffer.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithDepthFormat">
            <summary>
            Uses the same depth format as what the screen/framebuffer uses.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMips(System.Nullable{System.Int32})">
            <summary>
            Generate amount of mip levels.
            </summary>
            <param name="mips">How many mips should be generated for this texture</param>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.Create(System.String,System.Boolean,System.ReadOnlySpan{System.Byte},System.Int32)">
            <summary>
            Finish creating the texture.
            </summary>
            <param name="name">Name for the new texture.</param>
            <param name="anonymous">Whether this texture is anonymous.</param>
            <param name="data">Raw color data in correct format for the texture.</param>
            <param name="dataLength">Length of the <paramref name="data"/>.</param>
            <returns>The created texture.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the texture size is invalid, i.e. less then or equal to 0 on either axis.</exception>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithSemiStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithDynamicUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithGPUOnlyUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithUAVBinding">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMips(System.Int32)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Nullable{System.Int32})"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithFormat(Sandbox.ImageFormat)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithScreenFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithDepthFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample2X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample4X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample6X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample8X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample16X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithScreenMultiSample">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithArrayCount(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithSize(Vector2)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width and Height in pixels</param>
        </member>
        <member name="T:Sandbox.TextureLoader.Avatar">
            <summary>
            Facilitates loading of Steam user avatars.
            </summary>
        </member>
        <member name="F:Sandbox.TextureLoader.ImageUrl.Loaded">
            <summary>
            For textures loaded from the web we want to keep them around a bit longer
            </summary>
        </member>
        <member name="F:Sandbox.VertexBuffer.Vertex">
            <summary>
            List of all vertices in this buffer.
            </summary>
        </member>
        <member name="F:Sandbox.VertexBuffer.Index">
            <summary>
            All indices associated with the vertices of this buffer
            </summary>
        </member>
        <member name="P:Sandbox.VertexBuffer.Indexed">
            <summary>
            Whether this vertex buffer has any indexes. This is set by <see cref="M:Sandbox.VertexBuffer.Init(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.Clear">
            <summary>
            Clear all vertices and indices, and resets <see cref="F:Sandbox.VertexBuffer.Default"/>.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.Init(System.Boolean)">
            <summary>
            Clear the buffer and set whether it will have indices.
            </summary>
            <param name="useIndexBuffer">Whether this buffer will have indices. Affects <see cref="P:Sandbox.VertexBuffer.Indexed"/>.</param>
        </member>
        <member name="M:Sandbox.VertexBuffer.Add(Sandbox.Vertex)">
            <summary>
            Add a vertex
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddIndex(System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count., 1 is Vertex.Count -1
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when <see cref="P:Sandbox.VertexBuffer.Indexed"/> is false.</exception>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddTriangleIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add a triangle by indices. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when <see cref="P:Sandbox.VertexBuffer.Indexed"/> is false.</exception>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddRawIndex(System.Int32)">
            <summary>
            Add an index. This is NOT relative to the top of the vertex buffer.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when <see cref="P:Sandbox.VertexBuffer.Indexed"/> is false.</exception>
        </member>
        <member name="M:Sandbox.VertexBuffer.Draw(Sandbox.Material,Sandbox.RenderAttributes)">
            <summary>
            Draw this mesh using Material
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.SceneRefGizmo">
            <summary>
            Handles drawing lines representing ActionGraph references between objects / components in the scene.
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.ActionGraphResource">
            <summary>
            Some game logic implemented using visual scripting
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.ActionsInvoker">
            <summary>
            A component which allows you to use action in all the usual functions.
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.IActionComponent">
            <summary>
            A component that only provides actions to implement with an Action Graph.
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.SimpleActionComponent">
            <summary>
            These should not exist
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphs.SimpleActionComponent.Action">
            <summary>
            ActionGraph to run when the relevant event occurs.
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.AwakeActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnAwake"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.StartActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnStart"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.EnabledActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnEnabled"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.DisabledActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnDisabled"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.UpdateActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnUpdate"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.FixedUpdateActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnFixedUpdate"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.DestroyActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnDestroy"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.CollisionActionComponent">
            <summary>
            Reacts to collisions.
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphs.CollisionActionComponent.CollisionStart">
            <inheritdoc cref="M:Sandbox.Component.ICollisionListener.OnCollisionStart(Sandbox.Collision)"/>
        </member>
        <member name="P:Sandbox.ActionGraphs.CollisionActionComponent.CollisionUpdate">
            <inheritdoc cref="M:Sandbox.Component.ICollisionListener.OnCollisionUpdate(Sandbox.Collision)"/>
        </member>
        <member name="P:Sandbox.ActionGraphs.CollisionActionComponent.CollisionStop">
            <inheritdoc cref="M:Sandbox.Component.ICollisionListener.OnCollisionStop(Sandbox.CollisionStop)"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.TriggerActionComponent">
            <summary>
            Reacts to collider triggers.
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphs.TriggerActionComponent.TriggerEnter">
            <inheritdoc cref="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.Collider)"/>
        </member>
        <member name="P:Sandbox.ActionGraphs.TriggerActionComponent.TriggerExit">
            <inheritdoc cref="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.Collider)"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.RandomNodes.Color(System.Single,System.Single)">
            <summary>
            Returns a color with a random hue.
            </summary>
            <param name="saturation">Saturation of the generated color, from 0 to 1.</param>
            <param name="lightness">Lightness of the generated color, from 0 to 1.</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.SoundFile(Sandbox.SoundFile)">
            <summary>
            A sound resource.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.SoundEvent(Sandbox.SoundEvent)">
            <summary>
            A sound event. It can play a set of random sounds with optionally random settings such as volume and pitch.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.Model(Sandbox.Model)">
            <summary>
            A model.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.Material(Sandbox.Material)">
            <summary>
            A material. Uses several Textures and a Shader with specific settings for more interesting visual effects.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.Prefab(Sandbox.PrefabFile)">
            <summary>
            A prefab.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.GameResource``1(``0)">
            <summary>
            An asset defined in C# and created through tools.
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphs.RunSceneEventNodeDefinition.TargetInput">
            <summary>
            Optional target <see cref="T:Sandbox.GameObject"/> to post this event to.
            Only components within this target and its descendants will receive the event.
            If not provided, the whole <see cref="T:Sandbox.Scene"/> will be used.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.SceneNodes.PlaySound(Sandbox.GameObject,Sandbox.SoundEvent)">
            <summary>
            Plays a sound at the position of the target object.
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphs.SceneNodes.Trace">
            <inheritdoc cref="P:Sandbox.Scene.Trace"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.SceneNodes.NetworkSpawn(Sandbox.GameObject,Sandbox.Connection)">
            <inheritdoc cref="M:Sandbox.GameObject.NetworkSpawn(Sandbox.Connection)"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.SceneNodes.IsOwner(Sandbox.GameObject)">
            <summary>
            True if we are the owner of the GameObject
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.ISerializationOptionProvider">
            <summary>
            A <see cref="T:Facepunch.ActionGraphs.ISourceLocation"/> that provides <see cref="T:Facepunch.ActionGraphs.SerializationOptions"/>.
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.MapSourceLocation">
            <summary>
            Source location for action graphs that belong to a Hammer map. This is used for stack
            traces, and for knowing which map to save when editing a graph.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.MapSourceLocation.Get(System.String)">
            <summary>
            Gets a <see cref="T:Sandbox.ActionGraphs.MapSourceLocation"/> from a path name.
            </summary>
            <param name="mapPathName">Project-relative map path ending with ".vmap" or ".vpk".</param>
        </member>
        <member name="T:Sandbox.ActionGraphs.GameResourceSourceLocation">
            <summary>
            Source location for action graphs that belong to a <see cref="T:Sandbox.GameResource"/>.
            These can include scenes and prefabs, or custom resources. This is used for stack
            traces, and for knowing which asset to save when editing a graph.
            </summary>
            <param name="Resource">Resource that contains action graphs.</param>
        </member>
        <member name="M:Sandbox.ActionGraphs.GameResourceSourceLocation.#ctor(Sandbox.GameResource)">
            <summary>
            Source location for action graphs that belong to a <see cref="T:Sandbox.GameResource"/>.
            These can include scenes and prefabs, or custom resources. This is used for stack
            traces, and for knowing which asset to save when editing a graph.
            </summary>
            <param name="Resource">Resource that contains action graphs.</param>
        </member>
        <member name="P:Sandbox.ActionGraphs.GameResourceSourceLocation.Resource">
            <summary>Resource that contains action graphs.</summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.TimeNodes.Delay(System.Single,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            A task that does nothing for a given amount of time in seconds. This will continue even if the
            object containing this graph is destroyed, you probably want <see cref="T:Sandbox.GameObject"/>  Time  Delay instead.
            </summary>
            <param name="seconds">Time to wait in seconds.</param>
            <param name="ct">Token for cancelling the delay.</param>
        </member>
        <member name="M:Sandbox.ActionGraphs.TimeNodes.Delay(Sandbox.GameObject,System.Single,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            A task that does nothing for a given amount of time in seconds, and cancels automatically if the target <see cref="T:Sandbox.GameObject"/>
            is destroyed.
            </summary>
            <param name="target">Cancel the delay if this object is destroyed.</param>
            <param name="seconds">Time to wait in seconds.</param>
            <param name="ct">Token for cancelling the delay.</param>
        </member>
        <member name="M:Sandbox.ActionGraphs.TimeNodes.Delta">
            <inheritdoc cref="P:Sandbox.Time.Delta"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.TimeNodes.Now">
            <inheritdoc cref="P:Sandbox.Time.Now"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.As``2(``0)">
            <summary>
            Tests if the given input is of the given type, otherwise returns null.
            </summary>
            <typeparam name="TIn">Input type.</typeparam>
            <typeparam name="TValue">Type to test for.</typeparam>
            <param name="input">Input value to test the type of.</param>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.IsNull(System.Object)">
            <summary>
            Tests if the given input is null or invalid.
            </summary>
            <param name="input">Input value to test for null.</param>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.IsNotNull(System.Object)">
            <summary>
            Tests if the given input is not null and not invalid.
            </summary>
            <param name="input">Input value to test for null.</param>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.SystemToString``1(``0)">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.SystemToString``1(``0,System.String)">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.SystemGetHashCode``1(``0)">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:Sandbox.EditorHandleAttribute">
            <summary>
            When applied to a component, the editor will draw a selectable handle sprite for the gameobject in scene
            </summary>
        </member>
        <member name="T:Sandbox.AudioListener">
            <summary>
            If this exists and is enabled in a scene, then the client will hear from this point rather than
            from the cameras point of view.
            </summary>
        </member>
        <member name="P:Sandbox.AudioListener.UseCameraDirection">
            <summary>
            If true, while the audio listener position will be used, the rotation element will come from the camera.
            </summary>
        </member>
        <member name="P:Sandbox.BaseSoundComponent.TargetMixer">
            <summary>
            The mixer we want this sound to play through
            </summary>
        </member>
        <member name="T:Sandbox.DspVolumeGameSystem">
            <summary>
            Apply DSP to mixer when listener is inside a DspVolume
            </summary>
        </member>
        <member name="T:Sandbox.LipSync">
            <summary>
            Drive morphs with lipsync from sounds.
            </summary>
        </member>
        <member name="T:Sandbox.SoundBoxComponent">
            <summary>
            Plays a sound within a box.
            </summary>
        </member>
        <member name="T:Sandbox.SoundPointComponent">
            <summary>
            Plays a sound at a point in the world.
            </summary>
        </member>
        <member name="P:Sandbox.SoundPointComponent.Sandbox#Component#ITemporaryEffect#IsActive">
            <summary>
            Return true if the sound is playing
            </summary>
        </member>
        <member name="T:Sandbox.SoundscapeTrigger">
            <summary>
            Plays a soundscape when the listener enters the trigger area.
            </summary>
        </member>
        <member name="F:Sandbox.SoundscapeTrigger.TriggerType.Point">
            <summary>
            Can be heard from anywhere.
            </summary>
        </member>
        <member name="F:Sandbox.SoundscapeTrigger.TriggerType.Sphere">
            <summary>
            Can be heard within a radius.
            </summary>
        </member>
        <member name="F:Sandbox.SoundscapeTrigger.TriggerType.Box">
            <summary>
            Can be heard within the bounds of a box.
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.Type">
            <summary>
            Determines when/where the soundscape can be heard.
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.TargetMixer">
            <summary>
            Ths mixer that the soundscape will play on.
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.StayActiveOnExit">
            <summary>
            When true the soundscape will keep playing after exiting the area, and will
            only stop playing once another soundscape takes over.
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.Radius">
            <summary>
            The radius of the Soundscape when <see cref="P:Sandbox.SoundscapeTrigger.Type"/> is set to <see cref="F:Sandbox.SoundscapeTrigger.TriggerType.Sphere"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.BoxSize">
            <summary>
            The size of the Soundscape when <see cref="P:Sandbox.SoundscapeTrigger.Type"/> is set to <see cref="F:Sandbox.SoundscapeTrigger.TriggerType.Box"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SoundscapeTrigger.TestListenerPosition(Vector3)">
            <summary>
            Return true if they should hear this soundscape when in this position
            </summary>
        </member>
        <member name="M:Sandbox.SoundscapeTrigger.StartSoundscape(Sandbox.Soundscape)">
            <summary>
            Load and start this soundscape..
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.PlayingSound.IsDead">
            <summary>
            True if this sound has finished, can be removed
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.PlayingSound.Finished">
            <summary>
            Gets set when it's time to fade this out
            </summary>
        </member>
        <member name="F:Sandbox.SoundscapeTrigger.LoopedSoundEntry.currentVolume">
            <summary>
            We store the current volume so we can seamlessly fade in and out
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.LoopedSoundEntry.IsDead">
            <summary>
            Consider us dead if the soundscape system thinks we're finished and our volume is low
            </summary>
        </member>
        <member name="M:Sandbox.SoundscapeTrigger.LoopedSoundEntry.TryUpdateFrom(Sandbox.Soundscape.LoopedSound,System.Single,System.Single)">
            <summary>
            If we're using the same sound file as this incoming sound, and we're on our way out.. then
            let it replace us instead. This is much nicer.
            </summary>
        </member>
        <member name="T:Sandbox.Voice">
            <summary>
            Records and transmits voice/microphone input to other players.
            </summary>
        </member>
        <member name="P:Sandbox.Voice.LastPlayed">
            <summary>
            How long has it been since this sound played?
            </summary>
        </member>
        <member name="P:Sandbox.Voice.LaughterScore">
            <summary>
            Laughter score for the current audio frame, between 0 and 1
            </summary>
        </member>
        <member name="P:Sandbox.Voice.VoiceMixer">
            <inheritdoc cref="P:Sandbox.SoundHandle.TargetMixer"/>
        </member>
        <member name="P:Sandbox.Voice.Distance">
            <inheritdoc cref="P:Sandbox.SoundHandle.Distance"/>
        </member>
        <member name="P:Sandbox.Voice.Falloff">
            <inheritdoc cref="P:Sandbox.SoundHandle.Falloff"/>
        </member>
        <member name="P:Sandbox.Voice.Visemes">
            <summary>
            A list of 15 lipsync viseme weights. Requires <see cref="T:Sandbox.LipSync"/> to be enabled.
            </summary>
        </member>
        <member name="P:Sandbox.Voice.IsListening">
            <summary>
            Returns true if the mic is listening. Even if it's listening, it might
            not be playing - because it will only record and transmit if it can hear sound.
            </summary>
        </member>
        <member name="P:Sandbox.Voice.Amplitude">
            <summary>
            Measure of audio loudness.
            </summary>
        </member>
        <member name="M:Sandbox.Voice.ExcludeFilter">
            <summary>
            Exclude these connection from hearing our voice.
            </summary>
        </member>
        <member name="M:Sandbox.Voice.ShouldHearVoice(Sandbox.Connection)">
            <summary>
            Whether we want to hear voice from a particular connection.
            </summary>
        </member>
        <member name="T:Sandbox.CameraComponent">
            <summary>
            Every scene should have at least one Camera.
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.AddCommandList(Sandbox.Rendering.CommandList,Sandbox.Rendering.Stage,System.Int32)">
            <summary>
            Add a command list to the render
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.RemoveCommandList(Sandbox.Rendering.CommandList,Sandbox.Rendering.Stage)">
            <summary>
            Remove an entry 
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.RemoveCommandList(Sandbox.Rendering.CommandList)">
            <summary>
            Remove an entry 
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.ClearCommandLists(Sandbox.Rendering.Stage)">
            <summary>
            Remove all entries in this stage
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.ClearCommandLists">
            <summary>
            Remove all entries in this stage
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.ExecuteCommandLists(Sandbox.Rendering.Stage)">
            <summary>
            Called during the render pipeline. Currently this is rendered on the main thread, but ideally, one day, this will all be threaded.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.ClearFlags">
            <summary>
            The clear flags for this camera.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.BackgroundColor">
            <summary>
            The background color of this camera's view if there's no 2D Sky in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.IsMainCamera">
            <summary>
            Returns true if this is the main game camera.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.FovAxis">
            <summary>
            The axis to use for the field of view.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.FieldOfView">
            <summary>
            The field of view of this camera.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.ZNear">
            <summary>
            The camera's near clip plane distance. This is the closest distance this camera will be able to render.
            A good value for this is about 5. Below 5 and particularly below 1 you're going to start to see
            a lot of artifacts like z-fighting.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.ZFar">
            <summary>
            The camera's far clip plane distance. This is the furthest distance this camera will be able to render.
            This value totally depends on the game you're making. Shorter the better, sensible ranges would be
            between about 1000 and 30000, but if you want it to be further out you can balance that out by making
            ZNear larger.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.Priority">
            <summary>
            The priority of this camera. Dictates which camera gets rendered on top of another. Higher means it'll be rendered on top.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.Orthographic">
            <summary>
            Whether or not to use orthographic projection instead of perspective.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.OrthographicHeight">
            <summary>
            The orthographic size for this camera while <see cref="P:Sandbox.CameraComponent.Orthographic"/> is set to true.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.TargetEye">
            <inheritdoc cref="P:Sandbox.SceneCamera.TargetEye"/>
        </member>
        <member name="P:Sandbox.CameraComponent.RenderTags">
            <summary>
            A list of tags that will be checked to include specific game objects when rendering this camera.
            If none are set, it will include everything.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.RenderExcludeTags">
            <summary>
            A list of tags that will be checked to exclude specific game objects when rendering this camera.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.Viewport">
            <summary>
            The size of the camera represented on the screen. Normalized between 0 and 1.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.RenderTarget">
            <summary>
            The texture to draw this camera to.
            Requires <see cref="M:Sandbox.Texture.CreateRenderTarget"/>
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.SceneCamera">
            <summary>
            Accessor for getting this Camera Component's SceneCamera
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.UpdateSceneCamera(Sandbox.SceneCamera,System.Boolean)">
            <summary>
            Update a SceneCamera with the settings from this component
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.UpdateSceneCameraUI(Sandbox.SceneCamera)">
            <summary>
            Update the SceneCamera UI with the settings from this component
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.AddHookAfterTransparent(System.String,System.Int32,System.Action{Sandbox.SceneCamera})">
            <summary>
            Obsolete 09/06/2025
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.AddHookBeforeOverlay(System.String,System.Int32,System.Action{Sandbox.SceneCamera})">
            <summary>
            Obsolete 09/06/2025
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.AddToRenderList(SwapChainHandle_t,System.Nullable{Vector2})">
            <summary>
            This should only be called when creating render lists!!
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.ScreenRect">
            <summary>
            The size of the viewport, in screen coordinates
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.BBoxToScreenPixels(BBox,System.Boolean@)">
            <summary>
            Given a BBox in world space, will return the screen space rect that totally contains the box.
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.ScreenToWorld(Vector2)">
            <inheritdoc cref="M:Sandbox.SceneCamera.ToWorld(Vector2)"/>
        </member>
        <member name="M:Sandbox.CameraComponent.GetFrustum">
            <summary>
            Returns the view frustum of the current screen rect.
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.GetFrustum(Sandbox.Rect)">
            <inheritdoc cref="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect)" />
        </member>
        <member name="M:Sandbox.CameraComponent.GetFrustum(Sandbox.Rect,Vector3)">
            <inheritdoc cref="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect,Vector3)" />
        </member>
        <member name="M:Sandbox.CameraComponent.RenderToTexture(Sandbox.Texture,Sandbox.Rendering.ViewSetup@)">
            <summary>
            Render scene to a texture from this camera's point of view
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.CustomProjectionMatrix">
            <summary>
            Allows specifying a custom projection matrix for this camera
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.CustomSize">
            <summary>
            Allows specifying a custom aspect ratio for this camera.
            By default the camera size is screen size or render target size.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.ProjectionMatrix">
            <summary>
            Get frustum projection matrix.
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.CalculateObliqueMatrix(Sandbox.Plane)">
            <summary>
            Calculates a projection matrix with an oblique clip-plane defined in world space.
            </summary>
        </member>
        <member name="F:Sandbox.CameraComponent.Axis.Horizontal">
            <summary>
            Fits the view within the x-axis.
            </summary>
        </member>
        <member name="F:Sandbox.CameraComponent.Axis.Vertical">
            <summary>
            Fits the view within the y-axis.
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.RenderToBitmap(Sandbox.Bitmap)">
            <summary>
            Render this camera to the target bitmap.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.Hud">
            <summary>
            Allows drawing on the camera. This is drawn before the post processing.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.Overlay">
            <summary>
            Used to draw to the screen. This is drawn on top of everything, so is good for debug overlays etc.
            </summary>
        </member>
        <member name="T:Sandbox.CubemapFog">
            <summary>
            Applies a cubemap fog effect to the camera
            </summary>
        </member>
        <member name="T:Sandbox.Tonemapping">
            <summary>
            Applies a tonemapping effect to the camera.
            </summary>
        </member>
        <member name="T:Sandbox.Tonemapping.TonemappingMode">
            <summary>
            Options to select a tonemapping algorithm to use for color grading.
            </summary>
        </member>
        <member name="F:Sandbox.Tonemapping.TonemappingMode.HableFilmic">
            <summary>
            John Hable's filmic tonemapping algorithm.
            Matches the default curve Source 2 uses based on Uncharted 2.
            </summary>
        </member>
        <member name="F:Sandbox.Tonemapping.TonemappingMode.ACES">
            <summary>
            The most realistic tonemapper at handling bright light, desaturating light as it becomes brighter.
            This is slightly more expensive than other options.
            </summary>
        </member>
        <member name="F:Sandbox.Tonemapping.TonemappingMode.ReinhardJodie">
            <summary>
            Reinhard's tonemapper, which is a simple and fast tonemapper.
            </summary>
        </member>
        <member name="F:Sandbox.Tonemapping.TonemappingMode.Linear">
            <summary>
            Linear tonemapper, only applies autoexposure.
            </summary>
        </member>
        <member name="F:Sandbox.Tonemapping.TonemappingMode.AgX">
            <summary>
            Default AgX implementation
            </summary>
        </member>
        <member name="P:Sandbox.Tonemapping.Mode">
            <summary>
            Which tonemapping algorithm to use for color grading.
            </summary>
        </member>
        <member name="M:Sandbox.Tonemapping.Upgrader_v3(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Remove Exposure Bias
            this doesn't make much sense since it's tied to only HableFilmic and does the same thing as ExposureCompensation
            </summary>
        </member>
        <member name="M:Sandbox.Tonemapping.Upgrader_v2(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Remap the old "Legacy" mode to HableFilmic 
            </summary>
        </member>
        <member name="T:Sandbox.CharacterController">
            <summary>
            Allows collision contrained movement without the need for a rigidbody. This is not affected by forces and will only move when you call the Move() method.
            </summary>
        </member>
        <member name="P:Sandbox.CharacterController.Bounciness">
            <summary>
            When jumping into walls, should we bounce off or just stop dead?
            </summary>
        </member>
        <member name="P:Sandbox.CharacterController.UseCollisionRules">
            <summary>
            If enabled, determine what to collide with using current project's collision rules for the <see cref="P:Sandbox.GameObject.Tags"/>
            of the containing <see cref="T:Sandbox.GameObject"/>.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.Accelerate(Vector3)">
            <summary>
            Add acceleration to the current velocity. 
            No need to scale by time delta - it will be done inside.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.ApplyFriction(System.Single,System.Single)">
            <summary>
            Apply an amount of friction to the current velocity.
            No need to scale by time delta - it will be done inside.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.TraceDirection(Vector3)">
            <summary>
            Trace the controller's current position to the specified delta
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.Punch(Vector3@)">
            <summary>
            Disconnect from ground and punch our velocity. This is useful if you want the player to jump or something.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.Move">
            <summary>
            Move a character, with this velocity
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.MoveTo(Vector3,System.Boolean)">
            <summary>
            Move from our current position to this target position, but using tracing an sliding.
            This is good for different control modes like ladders and stuff.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterControllerHelper.TraceFromTo(Vector3,Vector3)">
            <summary>
            Trace this from one position to another
            </summary>
        </member>
        <member name="M:Sandbox.CharacterControllerHelper.TryMove(System.Single)">
            <summary>
            Try to move to the position. Will return the fraction of the desired velocity that we traveled.
            Position and Velocity will be what we recommend using.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterControllerHelper.TraceMove(Vector3)">
            <summary>
            Move our position by this delta using trace. If we hit something we'll stop,
            we won't slide across it nicely like TryMove does.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterControllerHelper.TryMoveWithStep(System.Single,System.Single)">
            <summary>
            Like TryMove but will also try to step up if it hits a wall
            </summary>
        </member>
        <member name="T:Sandbox.VelocityClipPlanes">
            <summary>
            Used to store a list of planes that an object is going to hit, and then
            remove velocity from them so the object can slide over the surface without
            going through any of the planes.
            </summary>
        </member>
        <member name="P:Sandbox.VelocityClipPlanes.Max">
            <summary>
            Maximum number of planes that can be hit
            </summary>
        </member>
        <member name="P:Sandbox.VelocityClipPlanes.Count">
            <summary>
            Number of planes we're currently holding
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.TryAdd(Vector3,Vector3@,System.Single)">
            <summary>
            Try to add this plane and restrain velocity to it (and its brothers)
            </summary>
            <returns>False if we ran out of room and should stop adding planes</returns>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.TryClip(Vector3@)">
            <summary>
            Try to clip our velocity to all the planes, so we're not travelling into them
            Returns true if we clipped properly
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.MovingTowardsAnyPlane(Vector3,System.Int32)">
            <summary>
            Returns true if we're moving towards any of our planes (except for skip)
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.StartBump(Vector3)">
            <summary>
            Start a new bump. Clears planes and resets BumpVelocity
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.ClipVelocity(Vector3,Vector3,System.Single)">
            <summary>
            Clip the velocity to the normal
            </summary>
        </member>
        <member name="T:Sandbox.BoxCollider">
            <summary>
            Defines a box collider.
            </summary>
        </member>
        <member name="P:Sandbox.BoxCollider.Scale">
            <summary>
            The size of the box, from corner to corner.
            </summary>
        </member>
        <member name="P:Sandbox.BoxCollider.Center">
            <summary>
            The center of the box relative to this GameObject
            </summary>
        </member>
        <member name="T:Sandbox.CapsuleCollider">
            <summary>
            Defines a capsule collider.
            </summary>
        </member>
        <member name="P:Sandbox.CapsuleCollider.Start">
            <summary>
            Bottom point of the capsule
            </summary>
        </member>
        <member name="P:Sandbox.CapsuleCollider.End">
            <summary>
            Top point of the capsule
            </summary>
        </member>
        <member name="P:Sandbox.CapsuleCollider.Radius">
            <summary>
            Radius of the capsule
            </summary>
        </member>
        <member name="P:Sandbox.Collider.IsDynamic">
            <summary>
            Return true if this collider is using dynamic physics.
            Returns false if this is a keyframe body, or a static physics body.
            </summary>
        </member>
        <member name="P:Sandbox.Collider.Friction">
            <summary>
            Allows overriding the friction for this collider. This value 
            can exceed 1 to to give crazy grippy friction if you want it to, 
            but the normal value is between 0 and 1.
            </summary>
        </member>
        <member name="P:Sandbox.Collider.Elasticity">
            <summary>
            Allows overriding the elasticity for this collider.
            Controls how bouncy this collider is.
            </summary>
        </member>
        <member name="P:Sandbox.Collider.RollingResistance">
            <summary>
            Allows overriding the rolling resistance for this collider.
            Controls how easily rolling shapes (sphere, capsule) roll on surfaces.
            </summary>
        </member>
        <member name="P:Sandbox.Collider.SurfaceVelocity">
            <summary>
            Set the local velocity of the surface so things can slide along it, like a conveyor belt
            </summary>
        </member>
        <member name="P:Sandbox.Collider.LocalBounds">
            <summary>
            Calculated local bounds of all physics shapes in this collider.
            </summary>
        </member>
        <member name="M:Sandbox.Collider.CreatePhysicsShapes(Sandbox.PhysicsBody)">
            <summary>
            Overridable in derived component to create shapes
            </summary>
        </member>
        <member name="P:Sandbox.Collider.OnTriggerEnter">
            <summary>
            Called when a collider enters this trigger
            </summary>
        </member>
        <member name="P:Sandbox.Collider.OnTriggerExit">
            <summary>
            Called when a collider exits this trigger
            </summary>
        </member>
        <member name="P:Sandbox.Collider.OnObjectTriggerEnter">
            <summary>
            Called when a gameobject enters this trigger
            </summary>
        </member>
        <member name="P:Sandbox.Collider.OnObjectTriggerExit">
            <summary>
            Called when a gameobject exits this trigger
            </summary>
        </member>
        <member name="P:Sandbox.Collider.Touching">
            <summary>
            If we're a trigger, this will list all of the colliders that are touching us.
            If we're not a trigger, this will list all of the triggers that we are touching.
            </summary>
        </member>
        <member name="M:Sandbox.Collider.ConfigureShapes">
            <summary>
            Apply any things that we an apply after they're created
            </summary>
        </member>
        <member name="M:Sandbox.Collider.GetVelocityAtPoint(Vector3)">
            <summary>
            Get the velocity of this collider at the specific point in word coordinates.
            </summary>
        </member>
        <member name="M:Sandbox.Collider.FindClosestPoint(Vector3)">
            <summary>
            Returns the closest point to the given one between all convex shapes of this body.
            </summary>
        </member>
        <member name="M:Sandbox.Collider.GetWorldBounds">
            <summary>
            Get the world bounds of this object
            </summary>
        </member>
        <member name="P:Sandbox.Collider.Joints">
            <summary>
            If we're a keyframe collider, this is the set of joints attached to us. If we're not then this won't ever
            return anything.
            </summary>
        </member>
        <member name="M:Sandbox.Collider.UpdateKeyframeTransform">
            <summary>
            Called right before physics simulation to move the keyframebody to its new transform.
            </summary>
        </member>
        <member name="P:Sandbox.Collider.Rigidbody">
            <summary>
            If this collider is part of a Rigidbody then this will return the component
            that it's attached to. If this is null it's usually a good indication that this
            collider is either static, world geometry, or a keyframe.
            </summary>
        </member>
        <member name="P:Sandbox.Collider.PhysicsBody">
            <summary>
            Returns either the rigidbody's physics body or the keyframe's physics body.
            </summary>
        </member>
        <member name="M:Sandbox.Collider.OnRigidBodyEnabled(Sandbox.Rigidbody)">
            <summary>
            Called when a Rigidbody is enabled. It calls this on all downstream colliders. On our part, we look at who out nearest
            parent rigidbody is and add ourselves to that.
            </summary>
        </member>
        <member name="M:Sandbox.Collider.OnRigidBodyDisabled(Sandbox.Rigidbody)">
            <summary>
            An upstream rigidbody has been disabled or destroyed. We look for the nearest parent rigidbody and add ourselves to that.
            If one doesn't exist we become a kinematic collider.
            </summary>
        </member>
        <member name="T:Sandbox.CollisionEventSystem">
            <summary>
            Used to abstract the listening of collision events
            </summary>
        </member>
        <member name="T:Sandbox.HullCollider">
            <summary>
            Defines a box, cone, or cylinder hull collider.
            </summary>
        </member>
        <member name="P:Sandbox.HullCollider.Type">
            <summary>
            The type of primitive.
            </summary>
        </member>
        <member name="P:Sandbox.HullCollider.Center">
            <summary>
            The center of the primitive relative to this GameObject.
            </summary>
        </member>
        <member name="P:Sandbox.HullCollider.BoxSize">
            <summary>
            The size of the box, from corner to corner.
            </summary>
        </member>
        <member name="T:Sandbox.ModelCollider">
            <summary>
            Defines a collider based on a model.
            </summary>
        </member>
        <member name="T:Sandbox.ModelPhysics">
            <summary>
            Physics for a model. This is primarily used for ragdolls and other physics driven models, otherwise you should be using a Rigidbody.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.PhysicsRebuildCount">
            <summary>
            Number of times the physics have been rebuilt. Debugging use only.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.PhysicsDestroyCount">
            <summary>
            Number of times the physics have been rebuilt. Debugging use only.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.Model">
            <summary>
            The model used to generate physics bodies, collision shapes, and joints.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.Renderer">
            <summary>
            The renderer that receives transform updates from physics bodies.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.IgnoreRoot">
            <summary>
            If true, the root physics body will not drive this component's transform.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.RigidbodyFlags">
            <summary>
            Rigidbody flags applied to all bodies.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.Locking">
            <summary>
            Rigidbody locking applied to all bodies.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.StartAsleep">
            <summary>
            All bodies will be put to sleep on start.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.MotionEnabled">
            <summary>
            Enable to drive renderer from physics, disable to drive physics from renderer.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.Mass">
            <summary>
            Returns the total mass of every <see cref="T:Sandbox.Rigidbody"/>
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.MassCenter">
            <summary>
            Returns the local center of mass of every <see cref="T:Sandbox.Rigidbody"/>
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.PositionRendererBonesFromPhysics">
            <summary>
            Apply body transforms to renderer bones.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.PositionPhysicsFromAnimation">
            <summary>
            Move bodies to animated bone transforms for bodies that have motion disabled.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.UpdateJointScale">
            <summary>
            Adjust joint points for body scaling.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.Sleep">
            <summary>
            Put all bodies to sleep.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.CopyBonesFrom(Sandbox.SkinnedModelRenderer,System.Boolean)">
            <summary>
            Copy the bone positions and velocities from a different SkinnedModelRenderer
            </summary>
        </member>
        <member name="T:Sandbox.ModelPhysics.Body">
            <summary>
            Represents a <see cref="T:Sandbox.Rigidbody"/> attached to a specific bone with a local transform.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.Body.#ctor(Sandbox.Rigidbody,System.Int32,Transform)">
            <summary>
            Represents a <see cref="T:Sandbox.Rigidbody"/> attached to a specific bone with a local transform.
            </summary>
        </member>
        <member name="T:Sandbox.ModelPhysics.Joint">
            <summary>
            Represents a <see cref="T:Sandbox.Joint"/> between two bodies with local frames for each.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.Joint.#ctor(Sandbox.Joint,Sandbox.ModelPhysics.Body,Sandbox.ModelPhysics.Body,Transform,Transform)">
            <summary>
            Represents a <see cref="T:Sandbox.Joint"/> between two bodies with local frames for each.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.Bodies">
            <summary>
            Networked list of bodies.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.Joints">
            <summary>
            Networked list of joints.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.BodyTransforms">
            <summary>
            Networked <see cref = "T:Sandbox.Rigidbody"/> transforms.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.UpdateProxyTransforms">
            <summary>
            Sync visual transforms to physics transforms.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.SetBodyTransforms">
            <summary>
            Send body transforms.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.MoveProxyBodies">
            <summary>
            Move proxy bodies to networked body transforms.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.CreatePhysics">
            <summary>
            Create all the bodies, colliders and joints.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.DestroyPhysics">
            <summary>
            Destroy all the bodies, colliders and joints.
            </summary>
        </member>
        <member name="T:Sandbox.PlaneCollider">
            <summary>
            Defines a plane collider.
            </summary>
        </member>
        <member name="P:Sandbox.PlaneCollider.Scale">
            <summary>
            The size of the plane, from corner to corner.
            </summary>
        </member>
        <member name="P:Sandbox.PlaneCollider.Center">
            <summary>
            The center of the plane relative to this GameObject.
            </summary>
        </member>
        <member name="P:Sandbox.PlaneCollider.Normal">
            <summary>
            The normal of the plane, determining its orientation.
            </summary>
        </member>
        <member name="T:Sandbox.Rigidbody">
            <summary>
            Adds physics properties to an object. Requires a collider to be attached to the same object.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.BroadcastToColliders">
            <summary>
            Tell all the downstream colliders that we exist. This gives them a chance to re-configure themselves.
            This doesn't meant they'll become shapes on our body, it just means they have potential to. They
            really just look for their nearest parent that has a Rigidbody on it, and then that becomes their boss.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.FreeColliders">
            <summary>
            Tell all the colliders we're fucking off. Clear the list.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.OnColliderAdded(Sandbox.Collider)">
            <summary>
            Called by a collider to tell the Rigidbody that it's part of it
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.OnColliderRemoved(Sandbox.Collider)">
            <summary>
            Called by a collider to tell the Rigidbody that it's no longer part of it
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.Gravity">
            <summary>
            Is gravity enabled or not.
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.MassOverride">
            <summary>
            Override mass for this body, only when value is more than zero
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.MassCenter">
            <summary>
            Center of mass for this rigidbody in local space coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.CollisionEventsEnabled">
            <summary>
            Enable or disable touch events. If you disable the events then ICollisionListener won't get any touch events
            and you won't get things like collision sounds.
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.CollisionUpdateEventsEnabled">
            <summary>
            Like CollisionEventsEnabled but means the OnCollisionUpdate gets called when the collision persists
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.Sleeping">
            <inheritdoc cref="P:Sandbox.PhysicsBody.Sleeping"/>
        </member>
        <member name="P:Sandbox.Rigidbody.TargetTransform">
            <summary>
            Used for transforming a selected rigidbody in editor, if useful for gameplay this could be made public.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.OnLocalTransformChanged">
            <summary>
            Called whenever the local transform of this component changes. This is used to update the physics body with the new position and rotation.
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.PhysicsBody">
            <summary>
            Get the actual physics body that was created by this component. You should be careful, this
            can of course be null when the object is not enabled or the physics world is not available.
            It might also get deleted and re-created, so best use this to access, but don't store it.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.FindClosestPoint(Vector3@)">
            <summary>
            Returns the closest point to the given one between all convex shapes of this body.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.GetVelocityAtPoint(Vector3@)">
            <summary>
            Returns the world space velocity of a point of the object. This is useful for objects rotating around their own axis/origin.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyForceAt(Vector3@,Vector3@)">
            <summary>
            Applies force to this body at given position.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyForce(Vector3@)">
            <summary>
            Applies linear force to this body
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyTorque(Vector3@)">
            <summary>
            Applies angular velocity to this body.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyImpulseAt(Vector3@,Vector3@)">
            <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body at given position
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyImpulse(Vector3@)">
            <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ClearForces">
            <summary>
            Clear accumulated linear forces (<see cref="M:Sandbox.Rigidbody.ApplyForce(Vector3@)"/> and <see cref="M:Sandbox.Rigidbody.ApplyForceAt(Vector3@,Vector3@)"/>) during this physics frame that were not yet applied to the physics body.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.SmoothMove(Transform@,System.Single,System.Single)">
            <summary>
            Move body to this position in a way that cooperates with the physics system. This is quite
            good for things like grabbing and moving objects.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.SmoothMove(Vector3@,System.Single,System.Single)">
            <summary>
            Move body to this position in a way that cooperates with the physics system. This is quite
            good for things like grabbing and moving objects.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.SmoothRotate(Rotation@,System.Single,System.Single)">
            <summary>
            Rotate the body to this position in a way that cooperates with the physics system.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.UpdateBody">
            <summary>
            Updates the physics body with the current properties of this component.
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.Touching">
            <summary>
            This is a list of all of the triggers that we are touching.
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.Joints">
            <summary>
            A list of joints that we're connected to, if any.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.GetWorldBounds">
            <summary>
            Get the world bounds of this object
            </summary>
        </member>
        <member name="T:Sandbox.SphereCollider">
            <summary>
            Defines a sphere collider.
            </summary>
        </member>
        <member name="T:Sandbox.Component">
            <summary>
            A GameObject can have many components, which are the building blocks of the game.
            </summary>
        </member>
        <member name="M:Sandbox.Component.InitClone(Sandbox.Component,System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <summary>
            Runs after this clone has been created by a cloned GameObject.
            </summary>
            <param name="original">The original component that was cloned.</param>
            <param name="originalToClonedObject">During the cloning process, we build a mapping from original objects to their clone, so we will need to add ourselves to it.</param>
        </member>
        <member name="M:Sandbox.Component.PostClone(System.Collections.Generic.Dictionary{System.Object,System.Object},System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
            <summary>
            Runs after all objects of the original hierarchy have been cloned/created.
            Here we initialize the clones properties and fields with the values from the original object.
            <param name="originalToClonedObject">A mapping of original objects to their clones, used for all reference types.</param>
            <param name="originalIdToCloneId">A mapping of original GUIDs to cloned GUIDs, used for GameObject and Component references in JSON.</param>
            </summary>
        </member>
        <member name="P:Sandbox.Component.Scene">
            <summary>
            The scene this Component is in. This is a shortcut for `GameObject.Scene`.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Transform">
            <summary>
            The transform of the GameObject this component belongs to. Components don't have their own transforms
            but they can access the transform of the GameObject they belong to. This is a shortcut for `GameObject.Transform`.
            </summary>
        </member>
        <member name="P:Sandbox.Component.GameObject">
            <summary>
            The GameObject this component belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Task">
            <summary>
            Allow creating tasks that are automatically cancelled when the GameObject is destroyed.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Components">
            <summary>
            Access components on this component's GameObject
            </summary>
        </member>
        <member name="M:Sandbox.Component.InitializeComponent">
            <summary>
            Called to call Awake, once, at startup.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Enabled">
            <summary>
            <para>
            The enable state of this <see cref="T:Sandbox.Component"/>.
            </para>
            <para>
            This doesn't tell you whether the component is actually active because its parent
            <see cref="T:Sandbox.GameObject"/> might be disabled. This merely tells you what the
            component wants to be. You should use <see cref="P:Sandbox.Component.Active"/> to determine whether the
            object is truly active in the scene.
            </para>
            </summary>
        </member>
        <member name="P:Sandbox.Component.Active">
            <summary>
            True if this Component is enabled, and all of its ancestor GameObjects are enabled
            </summary>
        </member>
        <member name="P:Sandbox.Component.ShouldExecute">
            <summary>
            Should this component execute? Should OnUpdate, OnEnabled get called?
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnAwake">
            <summary>
            Called once per component
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnEnabled">
            <summary>
            Called after Awake or whenever the component switches to being enabled (because a gameobject heirachy active change, or the component changed)
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnDestroy">
            <summary>
            Called once, when the component or gameobject is destroyed
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnPreRender">
            <summary>
            When enabled, called every frame, does not get called on a dedicated server
            </summary>
        </member>
        <member name="M:Sandbox.Component.SetUpdateAction``1(System.Action@,System.Action,Sandbox.Utility.HashSetEx{Sandbox.Component})">
            <summary>
            Replaces <paramref name="currentAction"/> with <paramref name="newAction"/>, and adds / removes this component
            from the given <paramref name="updateSet"/>, depending on whether the new action is null, and this type implements
            the given <typeparamref name="TSubscriber"/> interface.
            </summary>
        </member>
        <member name="M:Sandbox.Component.Destroy">
            <summary>
            Destroy this component, if it isn't already destroyed. The component will be removed from its
            GameObject and will stop existing. You should avoid interating with the component after calling this.
            </summary>
        </member>
        <member name="M:Sandbox.Component.DestroyGameObject">
            <summary>
            Destroy the parent GameObject. This really only exists so when you're typing Destroy you realise
            that calling Destroy only destroys the Component - not the whole GameObject.
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnValidate">
            <summary>
            Called immediately after deserializing, and when a property is changed in the editor.
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnRefresh">
            <summary>
            Called immediately after being refreshed from a network snapshot.
            </summary>
        </member>
        <member name="M:Sandbox.Component.EditLog(System.String,System.Object)">
            <summary>
            Called when something on the component has been edited
            </summary>
        </member>
        <member name="P:Sandbox.Component.Tags">
            <inheritdoc cref="P:Sandbox.GameObject.Tags"/>
        </member>
        <member name="M:Sandbox.Component.OnTagsChanged">
            <summary>
            When tags have been updated
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnParentChanged(Sandbox.GameObject,Sandbox.GameObject)">
            <summary>
            The parent has changed from one parent to another
            </summary>
        </member>
        <member name="M:Sandbox.Component.Invoke(System.Single,System.Action,System.Threading.CancellationToken)">
            <summary>
            Invoke a method in x seconds. Won't be invoked if the component is no longer active.
            </summary>
        </member>
        <member name="P:Sandbox.Component.DebugOverlay">
            <summary>
            Allows drawing of temporary debug shapes and text in the scene
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnParentDestroy">
            <summary>
            The parent object is being destroyed. This is a nice place to switch to a healthier parent.
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnPropertyDirty``1(Sandbox.WrappedPropertySet{``0}@)">
            <summary>
            Called when a property is set, which will run a callback
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnDirty">
            <summary>
            Called when the component has become dirty
            </summary>
        </member>
        <member name="M:Sandbox.Component.AddComponent``1(System.Boolean)">
            <summary>
            Add a component to this GameObject
            </summary>
        </member>
        <member name="M:Sandbox.Component.GetOrAddComponent``1(System.Boolean)">
            <summary>
            Add a component to this GameObject
            </summary>
        </member>
        <member name="M:Sandbox.Component.GetComponent``1(System.Boolean)">
            <summary>
            Get a component on this GameObject
            </summary>
        </member>
        <member name="M:Sandbox.Component.GetComponents``1(System.Boolean)">
            <summary>
            Get components on this GameObject
            </summary>
        </member>
        <member name="M:Sandbox.Component.GetComponentsInChildren``1(System.Boolean,System.Boolean)">
            <summary>
            Get components on this GameObject and on descendant GameObjects
            </summary>
        </member>
        <member name="M:Sandbox.Component.GetComponentInChildren``1(System.Boolean,System.Boolean)">
            <summary>
            Get component on this GameObject or on descendant GameObjects
            </summary>
        </member>
        <member name="M:Sandbox.Component.GetComponentsInParent``1(System.Boolean,System.Boolean)">
            <summary>
            Get components on this GameObject and on ancestor GameObjects
            </summary>
        </member>
        <member name="M:Sandbox.Component.GetComponentInParent``1(System.Boolean,System.Boolean)">
            <summary>
            Get component on this GameObject and on ancestor GameObjects
            </summary>
        </member>
        <member name="M:Sandbox.Component.DrawGizmos">
            <summary>
            Called in the editor to draw things like bounding boxes etc
            </summary>
        </member>
        <member name="M:Sandbox.Component.ForceChangeId(System.Guid)">
            <summary>
            Should only be called by <see cref="M:Sandbox.GameObjectDirectory.Add(Sandbox.Component)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Component.SetDeterministicId(System.Guid)">
            <summary>
            Allows overriding the ID of this object. This should be used sparingly, and only when necessary.
            This is generally used for network reasons, to make something deterministic.
            </summary>
        </member>
        <member name="P:Sandbox.Component.LocalTransform">
            <summary>
            The local transform of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.Component.LocalPosition">
            <summary>
            The local position of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.Component.LocalRotation">
            <summary>
            The local rotation of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.Component.LocalScale">
            <summary>
            The local scale of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.Component.IsProxy">
            <summary>
            True if this is a networked object and is owned by another client. This means that we're
            not controlling this object, so shouldn't try to move it or anything.
            </summary>
        </member>
        <member name="M:Sandbox.Component.GetOrCreateInterpolatedVar``1(``0,System.String)">
            <summary>
            Get or create a new interpolated variable. This will set the current interpolated value to the
            provided one if it hasn't been created yet.
            </summary>
        </member>
        <member name="M:Sandbox.Component.CheckRequireComponent">
            <summary>
            Check all of our properties for a [RequireComponent] attribute. 
            If we find one, and the property is null, try to find one or create one.
            Runs in the editor as well as in game.
            </summary>
        </member>
        <member name="M:Sandbox.Component.DeserializeImmediately(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Deserialize this component as per <see cref="M:Sandbox.Component.Deserialize(System.Text.Json.Nodes.JsonObject)"/> but update <see cref="P:Sandbox.Component.GameObject"/> and <see cref="T:Sandbox.Component"/> property
            references immediately instead of having them deferred.
            </summary>
        </member>
        <member name="T:Sandbox.Component.JsonKeys">
            <summary>
            Json Keys used for serialization and deserialization of Components.
            Kept here so they are easier to change, and we are less susceptible to typos.
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnStart">
            <summary>
            Called once before the first Update - when enabled.
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnUpdate">
            <summary>
            When enabled, called every frame
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnFixedUpdate">
            <summary>
            When enabled, called on a fixed interval that is determined by the Scene. This
            is also the fixed interval in which the physics are ticked. Time.Delta is that
            fixed interval.
            </summary>
        </member>
        <member name="P:Sandbox.Component.ComponentVersion">
            <summary>
            The version of the component. Used by <see cref="T:Sandbox.JsonUpgrader"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Component.WorldTransform">
            <summary>
            The world transform of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.Component.WorldPosition">
            <summary>
            The world position of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.Component.WorldRotation">
            <summary>
            The world rotation of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.Component.WorldScale">
            <summary>
            The world scale of the game object.
            </summary>
        </member>
        <member name="T:Sandbox.Component.DontExecuteOnServer">
            <summary>
            A component with this interface will not run on dedicated servers.
            </summary>
        </member>
        <member name="T:Sandbox.Component.ExecuteInEditor">
            <summary>
            A component with this interface will run in the editor.
            </summary>
        </member>
        <member name="T:Sandbox.Component.ICollisionListener">
            <summary>
            A <see cref="T:Sandbox.Component"/> with this interface can react to collisions.
            </summary>
        </member>
        <member name="M:Sandbox.Component.ICollisionListener.OnCollisionStart(Sandbox.Collision)">
            <summary>
            Called when this collider/rigidbody starts touching another collider.
            </summary>
        </member>
        <member name="M:Sandbox.Component.ICollisionListener.OnCollisionUpdate(Sandbox.Collision)">
            <summary>
            Called once per physics step for every collider being touched.
            </summary>
        </member>
        <member name="M:Sandbox.Component.ICollisionListener.OnCollisionStop(Sandbox.CollisionStop)">
            <summary>
            Called when this collider/rigidbody stops touching another collider.
            </summary>
        </member>
        <member name="T:Sandbox.Component.IColorProvider">
            <summary>
            When applied to a <see cref="T:Sandbox.Component"/>, the component will be able to provide the color to use for certain UI editor elements.
            </summary>
        </member>
        <member name="T:Sandbox.Component.IDamageable">
            <summary>
            A component that can be damaged by something.
            </summary>
        </member>
        <member name="T:Sandbox.Component.IHasBounds">
            <summary>
            A component that has bounds
            </summary>
        </member>
        <member name="P:Sandbox.Component.IHasBounds.LocalBounds">
            <summary>
            Returns bounds, in local space
            </summary>
        </member>
        <member name="T:Sandbox.Component.INetworkListener">
            <summary>
            A <see cref="T:Sandbox.Component"/> with this interface can react to network events.
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkListener.AcceptConnection(Sandbox.Connection,System.String@)">
            <summary>
            Called on the host to decide whether to accept a <see cref="T:Sandbox.Connection"/>. If any <see cref="T:Sandbox.Component"/>
            that implements this returns false, the connection will be denied.
            </summary>
            <param name="channel"></param>
            <param name="reason">The reason to display to the client.</param>
        </member>
        <member name="M:Sandbox.Component.INetworkListener.OnConnected(Sandbox.Connection)">
            <summary>
            Called when someone joins the server. This will only be called for the host.
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkListener.OnDisconnected(Sandbox.Connection)">
            <summary>
            Called when someone leaves the server. This will only be called for the host.
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkListener.OnActive(Sandbox.Connection)">
            <summary>
            Called when someone is all loaded and entered the game. This will only be called for the host.
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkListener.OnBecameHost(Sandbox.Connection)">
            <summary>
            Called when the host of the game has left - and you are now the new host.
            </summary>
        </member>
        <member name="T:Sandbox.Component.INetworkSnapshot">
            <summary>
            When implemented on a <see cref="T:Sandbox.Component"/> it can read and write data to and from a network snapshot.
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkSnapshot.ReadSnapshot(Sandbox.ByteStream@)">
            <summary>
            Read data from the snapshot.
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkSnapshot.WriteSnapshot(Sandbox.ByteStream@)">
            <summary>
            Write data to the snapshot.
            </summary>
        </member>
        <member name="T:Sandbox.Component.INetworkSpawn">
            <summary>
            A <see cref="T:Sandbox.Component"/> with this interface can listen for when a GameObject
            in its ancestors has been network spawned.
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkSpawn.OnNetworkSpawn(Sandbox.Connection)">
            <summary>
            Called when this object is spawned on the network.
            </summary>
        </member>
        <member name="T:Sandbox.Component.IPressable">
            <summary>
            A component that can be pressed. Like a button. This could be by 
            a player USE'ing it, or by a player walking on it, or by an NPC.
            A call to Press should ALWAYS call release afterwards. Generally
            this is done by the player, where holding E presses the button, and
            releasing E stops pressing it. You need to handle edge cases where
            the player dies while holding etc.
            </summary>
        </member>
        <member name="T:Sandbox.Component.IPressable.Event">
            <summary>
            Describes who pressed it.
            </summary>
        </member>
        <member name="M:Sandbox.Component.IPressable.Event.#ctor(Sandbox.Component,System.Nullable{Ray})">
            <summary>
            Describes who pressed it.
            </summary>
        </member>
        <member name="M:Sandbox.Component.IPressable.Hover(Sandbox.Component.IPressable.Event)">
            <summary>
            A player has started looking at this
            </summary>
        </member>
        <member name="M:Sandbox.Component.IPressable.Look(Sandbox.Component.IPressable.Event)">
            <summary>
            A player is still looking at this. Called every frame.
            </summary>
        </member>
        <member name="M:Sandbox.Component.IPressable.Blur(Sandbox.Component.IPressable.Event)">
            <summary>
            A player has stopped looking at this
            </summary>
        </member>
        <member name="M:Sandbox.Component.IPressable.Press(Sandbox.Component.IPressable.Event)">
            <summary>
            Pressed. Returns true on success, else false.
            If it returns true then you should call Release when the
            press finishes. Not everything expects it, but some stuff will.
            </summary>
        </member>
        <member name="M:Sandbox.Component.IPressable.Pressing(Sandbox.Component.IPressable.Event)">
            <summary>
            Still being pressed. Return true to allow the press to continue, false cancel the press
            </summary>
        </member>
        <member name="M:Sandbox.Component.IPressable.Release(Sandbox.Component.IPressable.Event)">
            <summary>
            To be called when the press finishes. You should only call this
            after a successful press - ie when Press hass returned true.
            </summary>
        </member>
        <member name="M:Sandbox.Component.IPressable.CanPress(Sandbox.Component.IPressable.Event)">
            <summary>
            Return true if the press is possible right now
            </summary>
        </member>
        <member name="T:Sandbox.Component.ISceneStage">
            <summary>
            Called on update start. This is the very first thing called.
            </summary>
        </member>
        <member name="T:Sandbox.Component.ITemporaryEffect">
            <summary>
            Allows components to indicate their state in a generic way. This is useful if you have a temporary effect system in which
            you want to remove GameObjects when their effects have all finished.
            </summary>
        </member>
        <member name="P:Sandbox.Component.ITemporaryEffect.IsActive">
            <summary>
            Should return true if the effect is active in a visible way
            </summary>
        </member>
        <member name="M:Sandbox.Component.ITemporaryEffect.DisableLooping">
            <summary>
            Indicates to the target object that we want it to die. If it's looping then
            it should stop now and put itself in a state where it will eventually die.
            </summary>
        </member>
        <member name="M:Sandbox.Component.ITemporaryEffect.DisableLoopingEffects(Sandbox.GameObject)">
            <summary>
            Disable the any looping effects. This indicates to the target object that we want it to die soon.
            </summary>
        </member>
        <member name="T:Sandbox.Component.ITintable">
            <summary>
            A <see cref="T:Sandbox.Component"/> that lets you change its color.
            </summary>
        </member>
        <member name="T:Sandbox.Component.ITriggerListener">
            <summary>
            A <see cref="T:Sandbox.Component"/> with this interface can react to interactions with triggers.
            </summary>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.Collider)">
            <summary>
            Called when a collider enters the trigger.
            </summary>
            <param name="other">The collider that entered.</param>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.Collider,Sandbox.Collider)">
            <summary>
            Called when a collider enters the trigger.
            </summary>
            <param name="self">This trigger's collider.</param>
            <param name="other">The collider that entered.</param>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.Collider)">
            <summary>
            Called when a collider exits the trigger.
            </summary>
            <param name="other">The collider that exited.</param>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.Collider,Sandbox.Collider)">
            <summary>
            Called when a collider exits the trigger.
            </summary>
            <param name="self">This trigger's collider.</param>
            <param name="other">The collider that exited.</param>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.GameObject)">
            <summary>
            Called when a game object enters the trigger.
            </summary>
            <param name="other">The game object that entered.</param>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.Collider,Sandbox.GameObject)">
            <summary>
            Called when a game object enters the trigger.
            </summary>
            <param name="self">This trigger's collider.</param>
            <param name="other">The game object that entered.</param>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.GameObject)">
            <summary>
            Called when a game object exits the trigger.
            </summary>
            <param name="other">The game object that exited.</param>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.Collider,Sandbox.GameObject)">
            <summary>
            Called when a game object exits the trigger.
            </summary>
            <param name="self">This trigger's collider.</param>
            <param name="other">The game object that exited.</param>
        </member>
        <member name="T:Sandbox.CloneHelpers">
            <summary>
            Provides helper methods for cloning objects and their members.
            We use a heuristic <see cref="M:Sandbox.ReflectionQueryCache.IsTypeCloneableByCopy(System.Type)"/> to determine if a type can be cloned by copy to speed up cloning.
            If we cannot copy something and we have to "clone" we do so by serializing to and deserializing from JSON.
            However, our goal is to copy as much as possible to avoid the serialization overhead.
            </summary>
        </member>
        <member name="M:Sandbox.CloneHelpers.UpdateClonedIdsInJson(System.Text.Json.Nodes.JsonNode@,System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
            <summary>
            We want GUIDS that reference something within the original hierarchy to reference the corresponding clone in the new hierarchy.
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Hidden">
            <summary>
            Hide this component in component inspector
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.NotSaved">
            <summary>
            Don't save this component to disk
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Error">
            <summary>
            There's something wrong with this
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Loading">
            <summary>
            Loading something
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Deserializing">
            <summary>
            Is in the process of deserializing
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.NotEditable">
            <summary>
            Cannot be edited in the component inspector
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.NotNetworked">
            <summary>
            Keep local - don't network this component as part of the scene snapshot
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Refreshing">
            <summary>
            In the process of refreshing from the network
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.NotCloned">
            <summary>
            Don't serialize this component when cloning
            </summary>
        </member>
        <member name="T:Sandbox.ComponentReference">
            <summary>
            A serialized reference to a <see cref="T:Sandbox.Component"/> that can be resolved at runtime.
            Components are referenced by their <see cref="P:Sandbox.Component.Id"/>, their containing object's
            <see cref="P:Sandbox.GameObject.Id"/>, and their <see cref="P:Sandbox.TypeDescription.ClassName"/> if available.
            </summary>
        </member>
        <member name="M:Sandbox.ComponentReference.FromInstance(Sandbox.Component)">
            <summary>
            Reference a given <see cref="T:Sandbox.Component"/>.
            </summary>
        </member>
        <member name="M:Sandbox.ComponentReference.op_Explicit(Sandbox.ComponentReference)~Sandbox.GameObjectReference">
            <summary>
            Converts a <see cref="T:Sandbox.ComponentReference"/> into a <see cref="T:Sandbox.GameObjectReference"/>, referencing the object
            that contains the component.
            </summary>
        </member>
        <member name="P:Sandbox.ComponentReference.ReferenceType">
            <summary>
            Expected to be <c>"component"</c> for a component reference.
            </summary>
        </member>
        <member name="P:Sandbox.ComponentReference.ComponentId">
            <summary>
            The <see cref="P:Sandbox.Component.Id"/> of the referenced component.
            </summary>
        </member>
        <member name="P:Sandbox.ComponentReference.GameObjectId">
            <summary>
            The <see cref="P:Sandbox.GameObject.Id"/> of the object containing the referenced component.
            </summary>
        </member>
        <member name="P:Sandbox.ComponentReference.ComponentTypeName">
            <summary>
            If available, the <see cref="P:Sandbox.TypeDescription.ClassName"/> of the referenced component.
            </summary>
        </member>
        <member name="M:Sandbox.ComponentReference.ResolveComponentType(System.Type)">
            <summary>
            Attempt to resolve <see cref="P:Sandbox.ComponentReference.ComponentTypeName"/> into a <see cref="T:System.Type"/>. Returns <see langword="null"/> if not resolved.
            </summary>
            <param name="targetType">Optional base type / interface that the resolved type must derive from / implement. Defaults to <see cref="T:Sandbox.Component"/>.</param>
        </member>
        <member name="M:Sandbox.ComponentReference.Resolve">
            <summary>
            Attempt to resolve this reference in the current <see cref="P:Sandbox.Game.ActiveScene"/>. Returns <see langword="null"/> if
            the reference couldn't be resolved, and logs a warning.
            </summary>
        </member>
        <member name="M:Sandbox.ComponentReference.Resolve(Sandbox.Scene,System.Type,System.Boolean)">
            <summary>
            Attempt to resolve this reference in the given <paramref name="scene"/>. Returns <see langword="null"/> if
            the reference couldn't be resolved.
            </summary>
            <param name="scene">Scene to attempt to resolve the reference in.</param>
            <param name="targetType">Optional base type / interface that the resolved instance must derive from / implement. Defaults to <see cref="T:Sandbox.Component"/>.</param>
            <param name="warn">If true, log a warning to the console if the reference couldn't be resolved.</param>
        </member>
        <member name="T:Sandbox.BeamEffect">
            <summary>
            The BeamEffect component creates a visual beam effect in the scene, simulating a continuous line or laser-like effect.
            Unlike LineRenderer these beams can change over time, spawn multiple instances, and have various properties like color, texture, and lifetime.
            This is a useful component for creating things like laser beams, energy effects and tracers.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Scale">
            <summary>
            Thickness of the beam in world units. Controls how wide the beam appears.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.TargetPosition">
            <summary>
            World position the beam targets if no target object is set. Used as the endpoint for the beam.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.TargetGameObject">
            <summary>
            GameObject to target with the beam. If assigned, overrides TargetPosition and uses the object's world position as the endpoint.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.TargetRandom">
            <summary>
            Random offset applied to the target position for visual variation. Adds randomness to the endpoint.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.FollowPoints">
            <summary>
            If true, the beam endpoints follow their source and target positions each frame, updating dynamically.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.BeamsPerSecond">
            <summary>
            Number of beams spawned per second. Controls the spawn rate for continuous effects.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.MaxBeams">
            <summary>
            Maximum number of beams that can exist at once. Limits the total active beams.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.InitialBurst">
            <summary>
            Number of beams spawned immediately when the effect is enabled.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.BeamLifetime">
            <summary>
            Lifetime of each beam in seconds. Determines how long a beam remains before being removed or respawned.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Looped">
            <summary>
            If true, beams respawn automatically when they expire, creating a looping effect.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Texture">
            <summary>
            Texture applied to the beam. Defines the visual appearance along the beam's length.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Material">
            <summary>
            Material applied to the beam. Defines the visual appearance along the beam's length.
            The material should be based on the `line.shader`.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.TextureOffset">
            <summary>
            Offset of the texture along the beam. Shifts the texture start position.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.TextureScale">
            <summary>
            Scale of the texture along the beam. Controls how many world units each texture tile covers.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.TextureScrollSpeed">
            <summary>
            Speed at which the texture scrolls along the beam. Positive values scroll in one direction, negative in the other.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.TextureScroll">
            <summary>
            This is pretty much the same as TextureOffset - but it's seperate so you can use offset for offset, and scroll to scroll.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.BeamColor">
            <summary>
            Color gradient of the beam over its lifetime. Defines how the color changes from birth to death.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Alpha">
            <summary>
            Alpha multiplier for the beam's color. Controls transparency over the beam's lifetime.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Brightness">
            <summary>
            Brightness multiplier for the beam's color. Adjusts intensity over the beam's lifetime.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Additive">
            <summary>
            If true, the beam is rendered additively, making it appear to glow.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Shadows">
            <summary>
            If true, the beam casts shadows in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Lighting">
            <summary>
            If true, the beam is affected by scene lighting.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Opaque">
            <summary>
            If true, the beam is rendered as opaque rather than transparent.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.DepthFeather">
            <summary>
            Amount of feathering applied to the beam's depth, softening its intersection with geometry.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.TravelBetweenPoints">
            <summary>
            If true, the beam visually travels from start to end, useful for tracer effects.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.TravelLerp">
            <summary>
            Controls the interpolation of the beam's travel effect over its lifetime.
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.Sandbox#Component#ITemporaryEffect#IsActive">
            <summary>
            Returns true if there are any active beams.
            </summary>
        </member>
        <member name="M:Sandbox.BeamEffect.Sandbox#Component#ITemporaryEffect#DisableLooping">
            <summary>
            Disables automatic looping of beams, preventing them from respawning when expired.
            </summary>
        </member>
        <member name="T:Sandbox.BeamEffect.BeamInstance">
            <summary>
            Represents an individual beam instance within the effect.
            </summary>
        </member>
        <member name="F:Sandbox.BeamEffect.BeamInstance.StartPosition">
            <summary>
            Start position of the beam in world space.
            </summary>
        </member>
        <member name="F:Sandbox.BeamEffect.BeamInstance.EndPosition">
            <summary>
            End position of the beam in world space.
            </summary>
        </member>
        <member name="F:Sandbox.BeamEffect.BeamInstance.Renderer">
            <summary>
            LineRenderer component used to render the beam visually.
            </summary>
        </member>
        <member name="F:Sandbox.BeamEffect.BeamInstance.TimeBorn">
            <summary>
            Time when the beam was created (born).
            </summary>
        </member>
        <member name="F:Sandbox.BeamEffect.BeamInstance.TimeDie">
            <summary>
            Time when the beam will expire (die).
            </summary>
        </member>
        <member name="P:Sandbox.BeamEffect.BeamInstance.Delta">
            <summary>
            Returns the normalized lifetime of the beam, ranging from 0 (just born) to 1 (expired).
            </summary>
        </member>
        <member name="F:Sandbox.BeamEffect.BeamInstance.RandomSeed">
            <summary>
            Random seed used to generate consistent random values for this beam instance.
            </summary>
        </member>
        <member name="M:Sandbox.BeamEffect.BeamInstance.Destroy">
            <summary>
            Destroys the beam instance, cleaning up its resources.
            </summary>
        </member>
        <member name="M:Sandbox.BeamEffect.SpawnBeam">
            <summary>
            Spawns a new beam and adds it to the effect.
            </summary>
        </member>
        <member name="T:Sandbox.LegacyParticleSystem">
            <summary>
            Support's Source Engine's vpcf particles
            </summary>
        </member>
        <member name="T:Sandbox.Dresser">
            <summary>
            Allows easily dressing a citizen or human in clothing
            </summary>
        </member>
        <member name="F:Sandbox.Dresser.ClothingSource.Manual">
            <summary>
            Manually select the clothing to wear
            </summary>
        </member>
        <member name="F:Sandbox.Dresser.ClothingSource.LocalUser">
            <summary>
            Dress according to the local user's avatar
            </summary>
        </member>
        <member name="F:Sandbox.Dresser.ClothingSource.OwnerConnection">
            <summary>
            Dress according to the avatar of the network owner of this GameObject
            </summary>
        </member>
        <member name="P:Sandbox.Dresser.Source">
            <summary>
            Where to get the clothing from
            </summary>
        </member>
        <member name="P:Sandbox.Dresser.BodyTarget">
            <summary>
            Who are we dressing? This should be the renderer of the body of a Citizen or Human
            </summary>
        </member>
        <member name="P:Sandbox.Dresser.ApplyHeightScale">
            <summary>
            Should we change the height too?
            </summary>
        </member>
        <member name="M:Sandbox.Dresser.CancelDressing">
            <summary>
            If we're dressing in an async way - stop it.
            </summary>
        </member>
        <member name="P:Sandbox.Dresser.IsDressing">
            <summary>
            True if we're dressing, in an async way
            </summary>
        </member>
        <member name="M:Sandbox.Dresser.OnManualChange(System.Single,System.Single)">
            <summary>
            Called when Height, Age or Tint is changed
            </summary>
        </member>
        <member name="M:Sandbox.Dresser.ApplyAttributes">
            <summary>
            Applies Height, Age and Tint.
            </summary>
        </member>
        <member name="T:Sandbox.FireDamage">
            <summary>
            Applies fire damage to any IDamageable in our Root object. 
            Damage is tagged "fire" and "burn"
            </summary>
        </member>
        <member name="F:Sandbox.FireDamage.DamagePerSecond">
            <summary>
            How much damage to apply per second
            </summary>
        </member>
        <member name="T:Sandbox.Gib">
            <summary>
            A gib is a prop that is treated slightly different. It will fade out after a certain amount of time.
            </summary>
        </member>
        <member name="T:Sandbox.ManualHitbox">
            <summary>
            A hitbox that can be placed manually on a GameObject, instead of coming from a model
            </summary>
        </member>
        <member name="P:Sandbox.ManualHitbox.Target">
            <summary>
            The target GameObject to report in trace hits. If this is unset we'll default to the gameobject on which this component is.
            </summary>
        </member>
        <member name="M:Sandbox.ManualHitbox.OnTagsChanged">
            <summary>
            Tags have been updated
            </summary>
        </member>
        <member name="T:Sandbox.ModelHitboxes">
            <summary>
            Hitboxes from a model
            </summary>
        </member>
        <member name="P:Sandbox.ModelHitboxes.Renderer">
            <summary>
            The target SkinnedModelRenderer that holds the model/skeleton you want to 
            take the hitboxes from.
            </summary>
        </member>
        <member name="P:Sandbox.ModelHitboxes.Target">
            <summary>
            The target GameObject to report in trace hits. If this is unset we'll defaault to the gameobject on which this component is.
            </summary>
        </member>
        <member name="M:Sandbox.ModelHitboxes.OnTagsChanged">
            <summary>
            The gameobject tags have changed, update collision tags on the target objects
            </summary>
        </member>
        <member name="T:Sandbox.Movement.MoveModeLadder">
            <summary>
            The character is climbing up a ladder
            </summary>
        </member>
        <member name="P:Sandbox.Movement.MoveModeLadder.ClimbableTags">
            <summary>
            A list of tags we can climb up - when they're on triggers
            </summary>
        </member>
        <member name="P:Sandbox.Movement.MoveModeLadder.ClimbingObject">
            <summary>
            The GameObject we're climbing. This will usually be a ladder trigger.
            </summary>
        </member>
        <member name="P:Sandbox.Movement.MoveModeLadder.ClimbingRotation">
            <summary>
            When climbing, this is the rotation of the wall/ladder you're climbing, where
            Forward is the direction to look at the ladder, and Up is the direction to climb.
            </summary>
        </member>
        <member name="T:Sandbox.Movement.MoveMode">
            <summary>
            A move mode for this character
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.UpdateAnimator(Sandbox.SkinnedModelRenderer)">
            <summary>
            Update the animator which is available at Controller.Renderer.
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.OnUpdateAnimatorVelocity(Sandbox.SkinnedModelRenderer)">
            <summary>
            <para>
            Sets animation parameters on <paramref name="renderer"/> based on the current
            <see cref="P:Sandbox.PlayerController.Velocity"/> and <see cref="P:Sandbox.PlayerController.WishVelocity"/>.
            </para>
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.OnUpdateAnimatorState(Sandbox.SkinnedModelRenderer)">
            <summary>
            Sets animation parameters on <paramref name="renderer"/> describing the movement style, like
            swimming, falling, or ducking.
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.OnUpdateAnimatorLookDirection(Sandbox.SkinnedModelRenderer)">
            <summary>
            Set animation parameters on <paramref name="renderer"/> to look towards <see cref="P:Sandbox.PlayerController.EyeAngles"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.OnRotateRenderBody(Sandbox.SkinnedModelRenderer)">
            <summary>
            Updates the <see cref="P:Sandbox.Component.WorldRotation"/> of <paramref name="renderer"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.Score(Sandbox.PlayerController)">
            <summary>
            Highest number becomes the new control mode
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.PrePhysicsStep">
            <summary>
            Called before the physics step is run
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.PostPhysicsStep">
            <summary>
            Called after the physics step is run
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.OnModeBegin">
            <summary>
            This mode has just started
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.OnModeEnd(Sandbox.Movement.MoveMode)">
            <summary>
            This mode has stopped. We're swapping to another move mode.
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.TrySteppingUp(System.Single)">
            <summary>
            If we're approaching a step, step up if possible
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.StickToGround(System.Single)">
            <summary>
            If we're on the ground, make sure we stay there by falling to the ground
            </summary>
        </member>
        <member name="M:Sandbox.Movement.MoveMode.UpdateMove(Rotation,Vector3)">
            <summary>
            Read inputs, return WishVelocity
            </summary>
        </member>
        <member name="T:Sandbox.Movement.MoveModeSwim">
            <summary>
            The character is swimming
            </summary>
        </member>
        <member name="P:Sandbox.Movement.MoveModeSwim.WaterLevel">
            <summary>
            Will will update this based on how much you're in a "water" tagged trigger
            </summary>
        </member>
        <member name="T:Sandbox.Movement.MoveModeWalk">
            <summary>
            The character is walking
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.Renderer">
            <summary>
            The body will usually be a child object with SkinnedModelRenderer
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.ShowCreateBodyRenderer">
            <summary>
            If true we'll show the "create body" button
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.AimStrengthEyes">
            <summary>
            How strongly to look in the eye direction with our eyes
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.AimStrengthHead">
            <summary>
            How strongly to turn in the eye direction with our head
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.AimStrengthBody">
            <summary>
            How strongly to turn in the eye direction with our body
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.UpdateAnimation(Sandbox.SkinnedModelRenderer)">
            <summary>
            Update the animation for this renderer. This will update the body rotation etc too.
            </summary>
        </member>
        <member name="F:Sandbox.PlayerController._skin">
            <summary>
            This is used to keep a distance away from surfaces. For exmaple, when grounding, we'll
            be a skin distance away from the ground.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.BrakePower">
            <summary>
            We will apply extra friction when we're on the ground and our desired velocity is
            lower than our current velocity, so we will slow down.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.AirFriction">
            <summary>
            How much friction to add when we're in the air. This will slow you down unless you have a wish
            velocity.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.Velocity">
            <summary>
            Our actual physical velocity minus our ground velocity
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.GroundVelocity">
            <summary>
            The velocity that the ground underneath us is moving
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.IsClimbing">
            <summary>
            Set to true when entering a climbing <see cref="T:Sandbox.Movement.MoveMode"/>.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.IsSwimming">
            <summary>
            Set to true when entering a swimming <see cref="T:Sandbox.Movement.MoveMode"/>.
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.Jump(Vector3)">
            <summary>
            Adds velocity in a special way. First we subtract any opposite velocity (ie, falling) then 
            we add the velocity, but we clamp it to that direction. This means that if you jump when you're running
            up a platform, you don't get extra jump power.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.EyeAngles">
            <summary>
            The direction we're looking.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.EyePosition">
            <summary>
            The player's eye position, in first person mode
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.EyeTransform">
            <summary>
            The player's eye position, in first person mode
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.IsDucking">
            <summary>
            True if this player is ducking
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.Headroom">
            <summary>
            The distance from the top of the head to to closest ceiling
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.EnsureComponentsCreated">
            <summary>
            Make sure the body and our components are created
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.UpdateBody">
            <summary>
            Update the body dimensions, and change the physical properties based on the current state
            </summary>
        </member>
        <member name="T:Sandbox.PlayerController.IEvents">
            <summary>
            Events from the PlayerController
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.IEvents.OnEyeAngles(Angles@)">
            <summary>
            Our eye angles are changing. Allows you to change the sensitivity, or stomp all together.
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.IEvents.PostCameraSetup(Sandbox.CameraComponent)">
            <summary>
            Called after we've set the camera up
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.IEvents.OnJumped">
            <summary>
            The player has just jumped
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.IEvents.OnLanded(System.Single,Vector3)">
            <summary>
            The player has landed on the ground, after falling this distance.
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.IEvents.GetUsableComponent(Sandbox.GameObject)">
            <summary>
            Used by the Using system to find components we can interact with.
            By default we can only interact with IPressable components.
            Return a component if we can use it, or else return null.
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.IEvents.StartPressing(Sandbox.Component)">
            <summary>
            We have started using something (use was pressed)
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.IEvents.StopPressing(Sandbox.Component)">
            <summary>
            We have started using something (use was pressed)
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.IEvents.FailPressing">
            <summary>
            We pressed USE but it did nothing
            </summary>
        </member>
        <member name="F:Sandbox.PlayerController.DebugFootsteps">
            <summary>
            Draw debug overlay on footsteps
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.PlayFootstepSound(Vector3,System.Single,System.Int32)">
            <summary>
            Play a footstep sound at the given world position. Will only play if the player has a GroundSurface.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.GroundObject">
            <summary>
            The object we're standing on. Null if we're standing on nothing.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.GroundComponent">
            <summary>
            The collider component we're standing on. Null if we're standing nothing
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.GroundSurface">
            <summary>
            If we're stnding on a surface this is it
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.GroundFriction">
            <summary>
            The friction property of the ground we're standing on.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.GroundIsDynamic">
            <summary>
            Are we standing on a surface that is physically dynamic
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.TimeSinceGrounded">
            <summary>
            Amount of time since this character was last on the ground
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.TimeSinceUngrounded">
            <summary>
            Amount of time since this character was last not on the ground
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.PreventGrounding(System.Single)">
            <summary>
            Prevent being grounded for a number of seconds
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.Reground(System.Single)">
            <summary>
            Lift player up and place a skin level above the ground
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.AccelerationTime">
            <summary>
            Amount of seconds it takes to get from your current speed to your requuested speed, if higher
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.DeaccelerationTime">
            <summary>
            Amount of seconds it takes to get from your current speed to your requuested speed, if lower
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.AltMoveButton">
            <summary>
            The button that the player will press to use to run
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.RunByDefault">
            <summary>
            If true then the player will run by default, and holding AltMoveButton will switch to walk
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.EnablePressing">
            <summary>
            Allows to player to interact with things by "use"ing them. 
            Usually by pressing the "use" button.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.UseButton">
            <summary>
            The button that the player will press to use things
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.ReachLength">
            <summary>
            How far from the eye can the player reach to use things
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.UseLookControls">
            <summary>
            When true we'll move the camera around using the mouse
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.LookSensitivity">
            <summary>
            Allows modifying the eye angle sensitivity. Note that player preference sensitivity is already automatically applied, this is just extra.
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.UpdateDucking(System.Boolean)">
            <summary>
            Called during FixedUpdate when UseInputControls is enmabled. Will duck if requested.
            If not, and we're ducked, will unduck if there is room
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.Hovered">
            <summary>
            The object we're currently looking at
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.Pressed">
            <summary>
            The object we're currently using by holding down USE
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.UpdateLookAt">
            <summary>
            Called in Update when Using is enabled
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.UpdatePressed">
            <summary>
            Called every frame to update our pressed object
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.UpdateHovered">
            <summary>
            Called every frame to update our hovered status, unless it's being pressed
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.StopPressing">
            <summary>
            Stop pressing. Pressed will become null.
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.StartPressing(Sandbox.Component)">
            <summary>
            Start pressing a target component. This is called automatically when Use is pressed.
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.SwitchHovered(Sandbox.Component)">
            <summary>
            Called every frame with the component we're looking at - even if it's null
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.TryGetLookedAt">
            <summary>
            Get the best component we're looking at. We don't just return any old component, by default
            we only return components that implement IPressable. Components can implement GetUsableComponent
            to search and provide better alternatives.
            </summary>
        </member>
        <member name="P:Sandbox.PlayerController.StepDebug">
            <summary>
            Enable debug overlays for this character
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.TryStep(System.Single)">
            <summary>
            Try to step up. Will trace forward, then up, then across, then down.
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.RestoreStep">
            <summary>
            If we stepped up on the previous step, we suck our position back to the previous position after the physics step
            to avoid adding double velocity. This is technically wrong but doens't seem to cause any harm right now
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.BodyBox(System.Single,System.Single)">
            <summary>
            Return an aabb representing the body
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.TraceBody(Vector3,Vector3,System.Single,System.Single)">
            <summary>
            Trace the aabb body from one position to another and return the result
            </summary>
        </member>
        <member name="M:Sandbox.PlayerController.CreateRagdoll(System.String)">
            <summary>
            Create a ragdoll gameobject version of our render body.
            </summary>
        </member>
        <member name="T:Sandbox.Prop">
            <summary>
            A prop is defined by its model. The model can define its health and what happens when it breaks.
            This component is designed to be easy to use - since you only need to define the model. Although you can 
            access the procedural (hidden) components, they aren't saved, so it's a waste of time.
            </summary>
        </member>
        <member name="P:Sandbox.Prop.IsStatic">
            <summary>
            If the prop is static - it won't have dynamic physics. This is usually used for things that
            you want to be breakable but don't move. Like fences and stuff.
            </summary>
        </member>
        <member name="P:Sandbox.Prop.StartAsleep">
            <summary>
            Physics will be asleep until it's woken up.
            </summary>
        </member>
        <member name="P:Sandbox.Prop.IsFlammable">
            <summary>
            True is this prop can be set on fire.
            </summary>
        </member>
        <member name="M:Sandbox.Prop.Break">
            <summary>
            Delete this component and split into the procedural components that this prop created.
            </summary>
        </member>
        <member name="T:Sandbox.RadiusDamage">
            <summary>
            Applies damage in a radius, with physics force, and optional occlusion
            </summary>
        </member>
        <member name="P:Sandbox.RadiusDamage.Radius">
            <summary>
            Should the world shield victims from damage?
            </summary>
        </member>
        <member name="P:Sandbox.RadiusDamage.PhysicsForceScale">
            <summary>
            How much physics force should be applied on explosion?
            </summary>
        </member>
        <member name="P:Sandbox.RadiusDamage.DamageOnEnabled">
            <summary>
            If enabled we'll apply damage once as soon as enabled
            </summary>
        </member>
        <member name="P:Sandbox.RadiusDamage.Occlusion">
            <summary>
            Should the world shield victims from damage?
            </summary>
        </member>
        <member name="P:Sandbox.RadiusDamage.DamageAmount">
            <summary>
            The amount of damage inflicted
            </summary>
        </member>
        <member name="P:Sandbox.RadiusDamage.DamageTags">
            <summary>
            Tags to apply to the damage
            </summary>
        </member>
        <member name="P:Sandbox.RadiusDamage.Attacker">
            <summary>
            Who should we credit with this attack?
            </summary>
        </member>
        <member name="M:Sandbox.RadiusDamage.Apply">
            <summary>
            Apply the damage now
            </summary>
        </member>
        <member name="T:Sandbox.SpawnPoint">
            <summary>
            Dictates where players will spawn when they join the game when using a NetworkHelper.
            </summary>
        </member>
        <member name="T:Sandbox.TriggerHurt">
            <summary>
            Deals damage to objects inside
            </summary>
        </member>
        <member name="P:Sandbox.TriggerHurt.DamageTags">
            <summary>
            If not empty, the target must have one of these tags
            </summary>
        </member>
        <member name="P:Sandbox.TriggerHurt.Damage">
            <summary>
            How much damage to apply
            </summary>
        </member>
        <member name="P:Sandbox.TriggerHurt.Rate">
            <summary>
            The delay between applying the damage
            </summary>
        </member>
        <member name="P:Sandbox.TriggerHurt.Include">
            <summary>
            If not empty, the target must have one of these tags
            </summary>
        </member>
        <member name="P:Sandbox.TriggerHurt.Exclude">
            <summary>
            If not empty, the target must not have one of these tags
            </summary>
        </member>
        <member name="T:Sandbox.BallJoint">
            <summary>
            Fix two objects together but can rotate - like a shoulder.
            </summary>
        </member>
        <member name="F:Sandbox.BallJoint.MotorMode.Disabled">
            <summary>
            The motor is disabled and only friction is applied.
            </summary>
        </member>
        <member name="F:Sandbox.BallJoint.MotorMode.TargetRotation">
            <summary>
            The motor drives the joint towards a target rotation using frequency and damping.
            </summary>
        </member>
        <member name="F:Sandbox.BallJoint.MotorMode.TargetVelocity">
            <summary>
            The motor drives the joint with a target angular velocity and maximum torque.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.Motor">
            <summary>
            Motor mode
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.SwingLimitEnabled">
            <summary>
            Enables or disables the swing limit.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.SwingLimit">
            <summary>
            The minimum and maximum swing angles allowed by the joint in degrees.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.TwistLimitEnabled">
            <summary>
            Enables or disables the twist limit.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.TwistLimit">
            <summary>
            The minimum and maximum twist angles allowed by the joint in degrees.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.Friction">
            <summary>
            Joint friction.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.TargetRotation">
            <summary>
            Target angle of motor.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.Frequency">
            <summary>
            Frequency of motor.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.DampingRatio">
            <summary>
            Damping of motor.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.TargetVelocity">
            <summary>
            Target angular velocity of the motor.
            </summary>
        </member>
        <member name="P:Sandbox.BallJoint.MaxTorque">
            <summary>
            Maximum torque the motor can apply when in velocity mode.
            </summary>
        </member>
        <member name="T:Sandbox.FixedJoint">
            <summary>
            Weld two physics objects together
            </summary>
        </member>
        <member name="T:Sandbox.HingeJoint">
            <summary>
            Create a hinged connection between two physics objects. Like a door hinge or a wheel.
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.MinAngle">
            <summary>
            Minimum angle it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.MaxAngle">
            <summary>
            Maximum angle it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.Motor">
            <summary>
            Motor mode
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.Friction">
            <summary>
            Hinge friction
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.TargetAngle">
            <summary>
            Target angle of motor
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.Frequency">
            <summary>
            Frequency of motor
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.DampingRatio">
            <summary>
            Damping of motor
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.TargetVelocity">
            <summary>
            Target velocity of motor
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.MaxTorque">
            <summary>
            Max torque of motor
            </summary>
        </member>
        <member name="F:Sandbox.Joint.AttachmentMode.Auto">
            <summary>
            Local frames are calculated automatically using this component transform and connected body transform.
            </summary>
        </member>
        <member name="F:Sandbox.Joint.AttachmentMode.LocalFrames">
            <summary>
            Local frames are set manually. See <see cref="P:Sandbox.Joint.LocalFrame1"/>, <see cref="P:Sandbox.Joint.LocalFrame2"/>
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Attachment">
            <summary>
            Are local frames calculated automatically or set manually. See <see cref="P:Sandbox.Joint.LocalFrame1"/>, <see cref="P:Sandbox.Joint.LocalFrame2"/>
            </summary>
        </member>
        <member name="P:Sandbox.Joint.LocalFrame1">
            <summary>
            Only used on joint creation. See <see cref="F:Sandbox.Joint.AttachmentMode.LocalFrames"/>
            </summary>
        </member>
        <member name="P:Sandbox.Joint.LocalFrame2">
            <summary>
            Only used on joint creation. See <see cref="F:Sandbox.Joint.AttachmentMode.LocalFrames"/>
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Body">
            <summary>
            Game object to find the body to attach this joint to.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.EnableCollision">
            <summary>
            Enable or disable collision between the two bodies.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.StartBroken">
            <summary>
            Is the joint broken on start.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.BreakForce">
            <summary>
            Strength of the linear constraint. If it takes any more energy than this, it'll break.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.BreakTorque">
            <summary>
            Strength of the angular constraint. If it takes any more energy than this, it'll break.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.OnBreak">
            <summary>
            Called when the joint breaks.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.LinearStress">
            <summary>
            Current linear stress applied to the joint.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.AngularStress">
            <summary>
            Current angular stress applied to the joint.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.IsBroken">
            <summary>
            Is the joint currently broken and inactive.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Body1">
            <summary>
            The source physics body this joint is attached to.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Object1">
            <summary>
            The source GameObject we're connected to
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Body2">
            <summary>
            The target physics body this joint is constraining.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Object2">
            <summary>
            The target GameObject we're connected to
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Point1">
            <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Joint.Body1"/>
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Point2">
            <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Joint.Body2"/>
            </summary>
        </member>
        <member name="M:Sandbox.Joint.CreateJoint(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint)">
            <summary>
            Joint type implementation.
            </summary>
        </member>
        <member name="T:Sandbox.SliderJoint">
            <summary>
            Restrict an object to one axis, relative to another object. Like a drawer opening.
            </summary>
        </member>
        <member name="P:Sandbox.SliderJoint.MaxLength">
            <summary>
            Maximum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.SliderJoint.MinLength">
            <summary>
            Minimum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.SliderJoint.Friction">
            <summary>
            Slider friction
            </summary>
        </member>
        <member name="T:Sandbox.SpringJoint">
            <summary>
            Try to keep an object a set distance away from another object. Like a spring connecting two objects.
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.Frequency">
            <summary>
            The stiffness of the spring
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.Damping">
            <summary>
            The damping ratio of the spring, usually between 0 and 1
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.MinLength">
            <summary>
            Minimum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.MaxLength">
            <summary>
            Maximum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.RestLength">
            <summary>
            Length of the spring at rest.
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.ForceMode">
            <summary>
            Determines which way the spring applies force.
            Pull = only when stretched,
            Push = only when compressed,
            Both = acts in both directions.
            </summary>
        </member>
        <member name="T:Sandbox.AmbientLight">
            <summary>
            Adds an ambient light to the scene, applied globally.
            </summary>
        </member>
        <member name="P:Sandbox.AmbientLight.Color">
            <summary>
            Ambient light color outside of all light probes.
            </summary>
        </member>
        <member name="T:Sandbox.DirectionalLight">
            <summary>
            A directional light that casts shadows, like the sun.
            </summary>
        </member>
        <member name="P:Sandbox.DirectionalLight.SkyColor">
            <summary>
            Color of the ambient sky color
            This is kept for long term support, the recommended way to do this is with an Ambient Light component.
            </summary>
        </member>
        <member name="T:Sandbox.EnvmapProbe">
            <summary>
            A cubemap probe that captures the environment around it.
            </summary>
        </member>
        <member name="P:Sandbox.EnvmapProbe.Texture">
            <summary>
            If this is set, the EnvmapProbe will use a custom cubemap texture instead of render dynamically
            </summary>
        </member>
        <member name="P:Sandbox.EnvmapProbe.NeedsInvertedAxis">
            <summary>
            Cubemaps in Source 2 have an inverted Y axis, for rendering them dynamically it uses correct axis
            We used to invert-Y but since we are rendering directly to cubemaps (and can't manipulate Y projection matrix
            without breaking culling ), we invert the matrix of the cubemap being drawn
            </summary>
        </member>
        <member name="M:Sandbox.EnvmapProbe.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our tags
            </summary>
        </member>
        <member name="P:Sandbox.EnvmapProbe.Resolution">
            <summary>
            Resolution of the cubemap texture
            </summary>
        </member>
        <member name="P:Sandbox.EnvmapProbe.MaxDistance">
            <summary>
            Only update dynamically if we're this close to it
            </summary>
        </member>
        <member name="P:Sandbox.EnvmapProbe.MultiBounce">
            <summary>
            Minimum amount of reflection bounces to render when first enabled before settling, at cost of extra performance on load
            Often times you don't need this
            </summary>
        </member>
        <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.OnEnabled">
            <summary>
            Update once, when the cubemap is enabled
            </summary>
        </member>
        <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.EveryFrame">
            <summary>
            Update every frame (slow, not recommended)
            </summary>
        </member>
        <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.FrameInterval">
            <summary>
            Update every x frames
            </summary>
        </member>
        <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.TimeInterval">
            <summary>
            Update on a time based interval
            </summary>
        </member>
        <member name="P:Sandbox.Light.LightColor">
            <summary>
            The main color of the light
            </summary>
        </member>
        <member name="P:Sandbox.Light.Shadows">
            <summary>
            Should this light cast shadows?
            </summary>
        </member>
        <member name="M:Sandbox.Light.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our light's tags
            </summary>
        </member>
        <member name="T:Sandbox.PointLight">
            <summary>
            Emits light in all directions from a point in space.
            </summary>
        </member>
        <member name="T:Sandbox.SpotLight">
            <summary>
            Emits light in a specific direction in a cone shape.
            </summary>
        </member>
        <member name="T:Sandbox.HammerMesh">
            <summary>
            Added automatically by Hammer to GameObjects that have a map mesh tied to them.
            When a map is compiled the Model property is populated by the generated model.
            </summary>
        </member>
        <member name="P:Sandbox.HammerMesh.Model">
            <summary>
            Gets populated at compile time, will be valid when loading from compiled map
            </summary>
        </member>
        <member name="P:Sandbox.HammerMesh.SurfaceVelocity">
            <summary>
            Set the local velocity of the surface so things can slide along it, like a conveyor belt
            </summary>
        </member>
        <member name="P:Sandbox.HammerMesh.OnTriggerEnter">
            <summary>
            Called when a collider enters this trigger
            </summary>
        </member>
        <member name="P:Sandbox.HammerMesh.OnTriggerExit">
            <summary>
            Called when a collider exits this trigger
            </summary>
        </member>
        <member name="T:Sandbox.MapInstance">
            <summary>
            Allows you to load a map into the Scene. This can be either a vpk or a scene map.
            </summary>
        </member>
        <member name="P:Sandbox.MapInstance.IsLoaded">
            <summary>
            True if the map is loaded
            </summary>
        </member>
        <member name="P:Sandbox.MapInstance.OnMapLoaded">
            <summary>
            Called when the map has successfully loaded
            </summary>
        </member>
        <member name="P:Sandbox.MapInstance.OnMapUnloaded">
            <summary>
            Called when the map has been unloaded
            </summary>
        </member>
        <member name="P:Sandbox.MapInstance.Bounds">
            <summary>
            Get the world bounds of the map
            </summary>
        </member>
        <member name="M:Sandbox.MapInstance.UnloadMap">
            <summary>
            Unload the current map.
            </summary>
        </member>
        <member name="M:Sandbox.MapInstance.UpdateDirtyReflections">
            <summary>
            Make sure all cubemaps placed on scene are up-to-date when we
            load/unload a map instance.
            </summary>
        </member>
        <member name="M:Sandbox.MapInstance.OnCreateObject(Sandbox.GameObject,Sandbox.MapLoader.ObjectEntry)">
            <summary>
            Override this to add components to a map object.
            Only called for map objects that are not implemented.
            </summary>
        </member>
        <member name="T:Sandbox.SkyboxMapLoader">
            <summary>
            Loader for a 3D skybox which updates the values on the parent sceneworld
            </summary>
        </member>
        <member name="T:Sandbox.MeshComponent">
            <summary>
            An editable polygon mesh with collision
            </summary>
        </member>
        <member name="T:Sandbox.PolygonMesh">
            <summary>
            An editable mesh made up of polygons, triangulated into a model
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.IsDirty">
            <summary>
            Has there been changes to the mesh that need rebuilding?
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.Transform">
            <summary>
            Where is the mesh in worldspace.
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.CleanupUnusedMaterials">
            <summary>
            Called on serialize, goes through and cleans up any unused materials, and remaps material indices
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.VertexHandles">
            <summary>
            All of the vertex handles being used
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.FaceHandles">
            <summary>
            All of the face handles being used
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.HalfEdgeHandles">
            <summary>
            All of the half edge handles being used
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.AddVertex(Vector3)">
            <summary>
            Add a vertex to the topology
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.AddVertices(Vector3[])">
            <summary>
            Add multiple vertices to the topology
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.AddFace(HalfEdgeMesh.VertexHandle[])">
            <summary>
            Connect these vertices to make a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.CalculateBounds">
            <summary>
            Calculate bounds of all vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.CalculateBounds(Transform)">
            <summary>
            Calculate bounds of all transformed vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.Scale(Vector3)">
            <summary>
            Scale all vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetFaceMaterial(HalfEdgeMesh.FaceHandle,Sandbox.Material)">
            <summary>
            Assign a material to a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetFaceMaterial(HalfEdgeMesh.FaceHandle,System.String)">
            <summary>
            Assign a material to a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetFaceMaterial(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get a material a face is using
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetEdgeSmoothing(HalfEdgeMesh.HalfEdgeHandle)">
            <summary>
            Get the smoothing of this edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetEdgeSmoothing(HalfEdgeMesh.HalfEdgeHandle,Sandbox.PolygonMesh.EdgeSmoothMode)">
            <summary>
            Set the smoothing of this edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.TriangleToFace(System.Int32)">
            <summary>
            Convert a triangle index to a face handle
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.ExtrudeFaces(HalfEdgeMesh.FaceHandle[],System.Collections.Generic.List{HalfEdgeMesh.FaceHandle}@,System.Collections.Generic.List{HalfEdgeMesh.FaceHandle}@,Vector3)">
            <summary>
            Extrude multiple faces along an offset
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.DetachFaces(HalfEdgeMesh.FaceHandle[],System.Collections.Generic.List{HalfEdgeMesh.FaceHandle}@)">
            <summary>
            Detatch multiple faces
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.CreateFaceInEdgeLoop(HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.FaceHandle@)">
            <summary>
            Add a face filling in the open edge loop specified by the provided edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetHalfEdgeFace(HalfEdgeMesh.HalfEdgeHandle)">
            <summary>
            Get the face connected to this half edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.IsEdgeOpen(HalfEdgeMesh.HalfEdgeHandle)">
            <summary>
            Determine if the specified edge is open (only has one connected face)
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.FindEdgeRing(HalfEdgeMesh.HalfEdgeHandle,System.Collections.Generic.List{HalfEdgeMesh.HalfEdgeHandle}@)">
            <summary>
            Find all of the edges in the ring with the specified edge. An edge ring is the set of edges that
            are connected by a loop of faces.
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.BridgeEdges(HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.FaceHandle@)">
            <summary>
            Bridge two edges (create a face connecting them). The edges must both be open and belong to
            different faces.
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.ConnectEdges(System.Collections.Generic.IReadOnlyList{HalfEdgeMesh.HalfEdgeHandle},System.Collections.Generic.List{HalfEdgeMesh.HalfEdgeHandle}@)">
            <summary>
            Connect the specified edges by adding a vertex to their mid point of each edge and then 
            connecting the vertices.
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetEdgeLine(HalfEdgeMesh.HalfEdgeHandle)">
            <summary>
            Get start and end points of an edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetEdgeVertices(HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.VertexHandle@,HalfEdgeMesh.VertexHandle@)">
            <summary>
            Get the two vertices of this half edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetVertexPosition(HalfEdgeMesh.VertexHandle,Vector3)">
            <summary>
            Set the position of a vertex
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetVertexPosition(HalfEdgeMesh.VertexHandle)">
            <summary>
            Get the position of a vertex
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetVertexPosition(HalfEdgeMesh.VertexHandle,Transform,Vector3@)">
            <summary>
            Get the position of a vertex
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetVertexPositions">
            <summary>
            Get the positions of all vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetFaceCenter(HalfEdgeMesh.FaceHandle)">
            <summary>
            Calculate the center point of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetEdges">
            <summary>
            Get the start and end points of all edges
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.ApplyTransform(Transform)">
            <summary>
            Transform all the vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetFaceEdges(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get all edge handles of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetFaceVertices(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get all vertex handles of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetTextureOffset(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get texture offset of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetTextureOffset(HalfEdgeMesh.FaceHandle,Vector2)">
            <summary>
            Set texture offset of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetTextureScale(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get texture scale of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetTextureScale(HalfEdgeMesh.FaceHandle,Vector2)">
            <summary>
            Set texture scale of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.TextureAlignToGrid(Transform,HalfEdgeMesh.FaceHandle)">
            <summary>
            Align face texture properties to grid
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.TextureAlignToFace(Transform,HalfEdgeMesh.FaceHandle)">
            <summary>
            Align face texture properties to face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetFaceTextureCoords(HalfEdgeMesh.FaceHandle,System.Collections.Generic.IReadOnlyList{Vector2})">
            <summary>
            Set face texture coords
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetFaceTextureParameters(HalfEdgeMesh.FaceHandle,Vector2,Vector3,Vector3)">
            <summary>
            Set face texture properties
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.TextureAlignToGrid(Transform)">
            <summary>
            Align all face texture properties to grid
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.RemoveFaces(System.Collections.Generic.IEnumerable{HalfEdgeMesh.FaceHandle})">
            <summary>
            Remove these faces
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.RemoveVertices(System.Collections.Generic.IEnumerable{HalfEdgeMesh.VertexHandle})">
            <summary>
            Remove these vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.RemoveEdges(System.Collections.Generic.IEnumerable{HalfEdgeMesh.HalfEdgeHandle})">
            <summary>
            Remove these edges
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.Rebuild">
            <summary>
            Triangulate the polygons into a model
            </summary>
        </member>
        <member name="T:Sandbox.MissingComponent">
            <summary>
            This is added when a component is missing. It will store the json data of the missing component, so we don't lose any data.
            </summary>
        </member>
        <member name="M:Sandbox.MissingComponent.GetJson">
            <summary>
            Get the Json data that was deserialized
            </summary>
        </member>
        <member name="T:Sandbox.NavMeshAgent">
            <summary>
            An agent that can navigate the navmesh defined in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.Acceleration">
            <summary>
            The maximum acceleration a agent can have. This is how fast the agent can change its velocity.
            If you want snappy movement this should be as high or higher than <see cref = "P:Sandbox.NavMeshAgent.MaxSpeed"/>.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.UpdatePosition">
            <summary>
            Set the Position of the GameObject to the agent position every frame. You can turn this off and handle it yourself by using the AgentPosition property.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.UpdateRotation">
            <summary>
            This will simply face the direction it is moving. It is not configurable on purpose, so you should really turn this off and be doing this yourself if you need it to do anything specific.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.AgentPosition">
            <summary>
            Updated  with the agent's position, even if UpdatePosition is false
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.SetAgentPosition(Vector3)">
            <summary>
            If you want to move the agent from one position to another
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.MoveTo(Vector3)">
            <summary>
            Navigate to the position
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.SetPath(Sandbox.Navigation.NavMeshPath)">
            <summary>
            Assigns a precalculated path for the agent to follow.
            The agent will attempt to follow the path, but may adjust its movement to avoid obstacles or other agents.
            If the path becomes invalid during navigation, it may be recalculated completely.
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.Stop">
            <summary>
            Stop moving, or whatever we're doing
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.CompleteLinkTraversal">
            <summary>
            Finish link traversal, must be called after traversing a link if AutoTraverseLinks is false.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.LinkEnter">
            <summary>
            Emitted when the agent enters a link.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.LinkExit">
            <summary>
            Emitted when the agent exits a link.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.IsTraversingLink">
            <summary>
            Returns true if the agent is currently traversing a link.
            </summary>
        </member>
        <member name="T:Sandbox.NavMeshAgent.LinkTraversalData">
            <summary>
            Holds information about the current link the agent is traversing.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.LinkTraversalData.LinkEnterPosition">
            <summary>
            The start position of the traversal.
            Depending on the direction traversing,
            this is either LinkComponent.WorldStartPositionOnNavMesh or LinkComponent.WorldEndPositionOnNavMesh.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.LinkTraversalData.LinkExitPosition">
            <summary>
            The end position of the traversal. Where the agent should exit.
            Depending on the direction traversing,
            this is either LinkComponent.WorldStartPositionOnNavMesh or LinkComponent.WorldEndPositionOnNavMesh.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.LinkTraversalData.AgentInitialPosition">
            <summary>
            The position at which the agent entered the link.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.LinkTraversalData.LinkComponent">
            <summary>
            The Link component that the agent is traversing.
            May be null if the agent is traversing a link created without a NavMeshLink component.
            </summary>
        </member>
        <member name="F:Sandbox.NavMeshAgent.CurrentLinkTraversal">
            <summary>
            Information about the current link traversal.
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.FindPhysicsGroundZ(Vector3)">
            <summary>
            We are tracing in the following interval (scale not accurate)
                x
                |
                |     We start a certain distance above the agents capsules center
                |
                | 
                |
             -------
             |  |  | 
             |  x  | -- Agent Capsule Center
             |  |  |
             -------
                |
                |
             ~~~~~~~ -- Potential ground
                |
                |
                |
                x      We trace down the same distance
                     
            In case of multiple hits we prefer the once closest to the agent's capsule center
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.GetLookAhead(System.Single)">
            <summary>
            Get a point on the current path, distance away from here. This is a simplified path so 
            only includes the first few corners.
            </summary>
        </member>
        <member name="T:Sandbox.NavMeshArea">
            <summary>
            An area that influences the NavMesh generation.
            Areas can be used to block off parts of the NavMesh.
            Static areas have almost no performance overhead.
            Moving areas at runtime will have an impact on performance if done excessively.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshArea.LinkedCollider">
            <summary>
            The collider this area's shape is based on.
            In almost every case, you will want to use a trigger collider for this.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshArea.IsBlocker">
            <summary>
            Whether navmesh generation in this area will be completly disabled. 
            </summary>
        </member>
        <member name="T:Sandbox.NavMeshLink">
            <summary>
            NavigationLinks connect navigation mesh polygons for pathfinding and enable shortcuts like ladders, jumps, or teleports.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshLink.LocalStartPosition">
            <summary>
            Start position relative to the game object's position.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshLink.LocalEndPosition">
            <summary>
            End position relative to the game object's position.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshLink.WorldStartPositionOnNavmesh">
            <summary>
            Start position in world space snapped to the navmesh.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshLink.WorldEndPositionOnNavmesh">
            <summary>
            End position in world space snapped to the navmesh.
            </summary>
        </member>
        <member name="F:Sandbox.NavMeshLink.IsBiDirectional">
            <summary>
            Whether this link can be traverse bi-directional or only start towards end.
            </summary>
        </member>
        <member name="F:Sandbox.NavMeshLink.ConnectionRadius">
            <summary>
            Radius that will be searched at the start and end positions for a connection to the navmesh.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshLink.LinkEntered">
            <summary>
            Emitted when an agent enters the link.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshLink.LinkExited">
            <summary>
            Emitted when an agent exits the link.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshLink.WorldStartPosition">
            <summary>
            Start position in world space.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshLink.WorldEndPosition">
            <summary>
            End position in world space.
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshLink.OnLinkEntered(Sandbox.NavMeshAgent)">
            <summary>
            Called when an agent enters the link.
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshLink.OnLinkExited(Sandbox.NavMeshAgent)">
            <summary>
            Called when an agent exits the link.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleAttractor">
            <summary>
            Attract particles to a GameObject in the scene
            </summary>
        </member>
        <member name="T:Sandbox.ParticleController">
            <summary>
            Particles can have extra controllers that can modify the particles every frame.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleController.ParticleEffect">
            <summary>
            The particle we're controlling
            </summary>
        </member>
        <member name="M:Sandbox.ParticleController.OnBeforeStep(System.Single)">
            <summary>
            Called before the particle step
            </summary>
        </member>
        <member name="M:Sandbox.ParticleController.OnAfterStep(System.Single)">
            <summary>
            Called after the particle step
            </summary>
        </member>
        <member name="M:Sandbox.ParticleController.OnParticleStep(Sandbox.Particle,System.Single)">
            <summary>
            Called for each particle during the particle step. This is super threaded
            so you better watch out.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleBoxEmitter">
            <summary>
            Emits particles within a box shape.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleConeEmitter">
            <summary>
            Emits particles within/along a cone shape.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleConeEmitter.VelocityRandom">
            <summary>
            Randomize the direction of the initial velocity. 0 = no randomization, 1 = full randomization.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleConeEmitter.CenterBias">
            <summary>
            When distributing should we bias the center of the cone
            </summary>
        </member>
        <member name="P:Sandbox.ParticleConeEmitter.CenterBiasVelocity">
            <summary>
            Should particles near the center have more velocity
            </summary>
        </member>
        <member name="P:Sandbox.ParticleConeEmitter.VelocityMultiplier">
            <summary>
            Multiply velocity by this
            </summary>
        </member>
        <member name="T:Sandbox.ParticleEmitter">
            <summary>
            Creates particles. Should be attached to a <see cref="T:Sandbox.ParticleEffect"/>.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.Burst">
            <summary>
            How many particles to emit, in a burst
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.Rate">
            <summary>
            How many particles to emit over time
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.RateOverDistance">
            <summary>
            How many particles to emit per 100 units moved
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.Delta">
            <summary>
            0-1, the life time of the emitter
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.IsBursting">
            <summary>
            True if we're doing a burst
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.EmitRandom">
            <summary>
            0-1, a random number to be used for this loop of the emitter
            </summary>
        </member>
        <member name="M:Sandbox.ParticleEmitter.GetBurstCount">
            <summary>
            Allows child emitters to override how many particles are in a burst
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.ParticleEmitter.GetRateCount">
            <summary>
            Allows child emitters to override how many particles are in a rate
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sandbox.ParticleEmitter.Sandbox#Component#ITemporaryEffect#IsActive">
            <summary>
            Return true if we haven't finished emitting
            </summary>
        </member>
        <member name="T:Sandbox.ParticleModelEmitter">
            <summary>
            Emits particles in a model
            </summary>
        </member>
        <member name="T:Sandbox.ParticleRingEmitter">
            <summary>
            Emits particles in a ring. The ring can be flat or have a tube-like quality.
            
            Velocity can either be added from the center of the ring, or from the ring itself.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleSphereEmitter">
            <summary>
            Emits particles within a sphere shape.
            </summary>
        </member>
        <member name="F:Sandbox.Particle.LifeDelta">
            <summary>
            A range from 0 to 1 descriving how long this particle has been alive
            </summary>
        </member>
        <member name="F:Sandbox.Particle.DeathTime">
            <summary>
            The time that this particle is scheduled to die
            </summary>
        </member>
        <member name="F:Sandbox.Particle.Follower">
            <summary>
            A GameObject that is following us. Might be emitting other particles or something.
            </summary>
        </member>
        <member name="M:Sandbox.Particle.Get``1(System.String)">
            <summary>
            Get an arbituary data value
            </summary>
        </member>
        <member name="M:Sandbox.Particle.Set``1(System.String,``0)">
            <summary>
            Set an arbituary data value
            </summary>
        </member>
        <member name="T:Sandbox.Particle.BaseListener">
            <summary>
            Allows creating a class that will exist for as long as a particle.
            The methods get called in the particle thread, which removes the need to run through
            the particle list again, but it has the danger and restrictions that come with threaded code.
            </summary>
        </member>
        <member name="P:Sandbox.Particle.BaseListener.Source">
            <summary>
            The component that created this listener. May be null.
            </summary>
        </member>
        <member name="M:Sandbox.Particle.BaseListener.OnEnabled(Sandbox.Particle)">
            <summary>
            Called in a thread. The particle is in its first position.
            </summary>
        </member>
        <member name="M:Sandbox.Particle.BaseListener.OnUpdate(Sandbox.Particle,System.Single)">
            <summary>
            Called in a thread, guarenteed to be called after OnEnabled
            </summary>
        </member>
        <member name="M:Sandbox.Particle.BaseListener.OnDisabled(Sandbox.Particle)">
            <summary>
            Called in a thread. OnUpdate won't be called again.
            </summary>
        </member>
        <member name="M:Sandbox.Particle.AddListener(Sandbox.Particle.BaseListener,Sandbox.Component)">
            <summary>
            Add a listener.
            </summary>
        </member>
        <member name="M:Sandbox.Particle.RemoveListener(Sandbox.Particle.BaseListener)">
            <summary>
            Remove a listener
            </summary>
        </member>
        <member name="M:Sandbox.Particle.DisableListenersForComponent(Sandbox.Component)">
            <summary>
            Remove all listeners with this component set as the source. This is most commonly called when
            the passed component is destroyed or disabled, to remove any effects created.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleEffect">
            <summary>
            Defines and holds particles. This is the core of the particle system.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.MaxParticles">
            <summary>
            The maximum number of particles that can exist in this effect at once.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Lifetime">
            <summary>
            The lifetime of each particle, in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.TimeScale">
            <summary>
            Scales the simulation time for this effect.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.PreWarm">
            <summary>
            How many seconds to pre-warm this effect by when creating.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.StartDelay">
            <summary>
            The delay before a particle starts after being emitted, in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.PerParticleTimeScale">
            <summary>
            Per-particle time scale multiplier. Allows each particle to have a unique simulation speed.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleEffect.TimingMode.GameTime">
            <summary>
            Use game simulation time (affected by game time scale).
            </summary>
        </member>
        <member name="F:Sandbox.ParticleEffect.TimingMode.RealTime">
            <summary>
            Use real-world time (ignores game time scale).
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Timing">
            <summary>
            How time is updated for this effect.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.InitialVelocity">
            <summary>
            The initial velocity of the particle when it is created. This is applied before any forces are applied.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.StartVelocity">
            <summary>
            Apply an element of random velocity to the particle when it is created, in a random direction.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Damping">
            <summary>
            The damping factor applied to particle velocity over time.
            This reduces the velocity of particles, simulating resistance or drag.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ConstantMovement">
            <summary>
            Move this delta constantly. Ignores velocity, collisions and drag.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.LocalSpace">
            <summary>
            When 1 particles will be moved in local space relative to the emitter GameObject's transform. 
            This allows particles to be emitted in a local space, like a fire effect that moves with the player, but the particles can slowly move to world space.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ApplyRotation">
            <summary>
            Enables or disables rotation for particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Pitch">
            <summary>
            The pitch rotation of the particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Yaw">
            <summary>
            The yaw rotation of the particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Roll">
            <summary>
            The roll rotation of the particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ApplyColor">
            <summary>
            Enables or disables color application for particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ApplyAlpha">
            <summary>
            Enables or disables alpha application for particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Tint">
            <summary>
            The tint color applied to particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Gradient">
            <summary>
            The gradient used to color particles over their lifetime.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Brightness">
            <summary>
            The brightness multiplier applied to particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Alpha">
            <summary>
            The alpha transparency of particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ApplyShape">
            <summary>
            Enables or disables shape application for particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Scale">
            <summary>
            The scale of particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Stretch">
            <summary>
            The stretch factor of particles, affecting their aspect ratio.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Force">
            <summary>
            Enables or disables the application of forces to particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ForceDirection">
            <summary>
            The direction of the force applied to particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ForceScale">
            <summary>
            The scale of the force applied to each particle.
            This multiplier determines the intensity of the force applied to particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OrbitalForce">
            <summary>
            The orbital force applied to particles, causing them to rotate around a point.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OrbitalPull">
            <summary>
            The pull strength of the orbital force, drawing particles closer to the center.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ForceSpace">
            <summary>
            The simulation space in which forces are applied.
            Forces can be applied in either local space (relative to the emitter) or world space.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Collision">
            <summary>
            Enables or disables collision behavior for particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.DieOnCollisionChance">
            <summary>
            The chance that a particle will die upon collision.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.CollisionRadius">
            <summary>
            The radius used for collision detection.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.CollisionIgnore">
            <summary>
            The set of tags to ignore during collision detection.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Bounce">
            <summary>
            The bounce factor applied to particles upon collision.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Friction">
            <summary>
            The friction factor applied to particles upon collision.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Bumpiness">
            <summary>
            The bumpiness factor applied to particles upon collision.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.PushStrength">
            <summary>
            The strength of the push force applied to particles upon collision.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.SheetSequence">
            <summary>
            Enables or disables the use of a sheet sequence for particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.SequenceId">
            <summary>
            Which sequence to use.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.SequenceTime">
            <summary>
            Allows control of the sequence time, which spans from 0 to 1 for one loop.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.SequenceSpeed">
            <summary>
            Increment the sequence time by this much.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.UsePrefabFeature">
            <summary>
            Enables or disables the use of prefabs for particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.FollowerPrefab">
            <summary>
            Will choose a random prefab to spawn from this list.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.FollowerPrefabChance">
            <summary>
            If 1 then we'll always spawn a prefab. If 0.5 then we'll spawn a prefab 50% of the time.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.FollowerPrefabKill">
            <summary>
            When true the prefab will be destroyed at the end of the particle's life.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.CollisionPrefab">
            <summary>
            Will choose a random prefab to spawn from this list.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.CollisionPrefabAlign">
            <summary>
            Will choose a random prefab to spawn from this list.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.CollisionPrefabRotation">
            <summary>
            We will by default align to the particle's angle, but we can also randomize that.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.CollisionPrefabChance">
            <summary>
            If 1 then we'll always spawn a prefab. If 0.5 then we'll spawn a prefab 50% of the time.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnParticleDestroyed">
            <summary>
            Called any time a particle is destroyed.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnParticleCreated">
            <summary>
            Called any time a particle is created.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Particles">
            <summary>
            Active particles in the effect.
            Active particles are those currently being simulated and rendered.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.DelayedParticles">
            <summary>
            Delayed particles in the effect.
            Delayed particles are those that have been emitted but are waiting to be activated based on their start delay.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ParticleCount">
            <summary>
            The total number of particles in the effect, including both active and delayed particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.IsFull">
            <summary>
            Whether the particle effect has reached its maximum capacity.
            This is determined by comparing the total particle count to the <see cref="P:Sandbox.ParticleEffect.MaxParticles"/> property.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.Paused">
            <summary>
            Whether the particle simulation is currently paused.
            When paused, particles will not update their positions, velocities, or other properties.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnPreStep">
            <summary>
            Called before the particles are stepped.
            This allows custom logic to be executed before the simulation advances.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnPostStep">
            <summary>
            Called after the particles are stepped.
            This allows custom logic to be executed after the simulation advances.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnStep">
            <summary>
            Called after each particle is stepped.
            This provides an opportunity to modify individual particles during the simulation.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ParticleBounds">
            <summary>
            The bounding box that encompasses all active particles.
            This is useful for determining the spatial extent of the particle effect.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.MaxParticleSize">
            <summary>
            The size of the largest particle in the effect.
            This is determined by the maximum scale of any particle along its x, y, or z axis.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleEffect.SimulationSpace.World">
            <summary>
            Forces are applied in world space, independent of the emitter's position or rotation.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleEffect.SimulationSpace.Local">
            <summary>
            Forces are applied in local space, relative to the emitter's position and rotation.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleEffect.Emit(Vector3,System.Single)">
            <summary>
            Emit a particle at the given position.
            </summary>
            <param name="position">The position in which to spawn the particle</param>
            <param name="delta">The time delta of the spawn. The first spawned particle is 0, the last spawned particle is 1. This is used to evaluate the spawn particles like lifetime and delay.</param>
            <returns>A particle, will never be null. It's up to you to obey max particles.</returns>
        </member>
        <member name="P:Sandbox.ParticleEffect.Sandbox#Component#ITemporaryEffect#IsActive">
            <summary>
            Should return true if we have active particles
            </summary>
        </member>
        <member name="M:Sandbox.ParticleEffect.Upgrader_v1(System.Text.Json.Nodes.JsonObject)">
            <summary>
            v1
            - Added ApplyAlpha property if ApplyColor was true.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleEffect.Upgrader_v2(System.Text.Json.Nodes.JsonObject)">
            <summary>
            v2
            - Changed Space from enum to LocalSpace ParticleFloat, where 1 is local, 0 is world space.
            </summary>
        </member>
        <member name="P:Sandbox.IDynamicFloatContext.LifetimeDelta">
            <summary>
            Should return the lifetime delta we're going to use to evaluate
            </summary>
        </member>
        <member name="P:Sandbox.IDynamicFloatContext.RandomSeed">
            <summary>
            Should return the seed we're using for randomness
            </summary>
        </member>
        <member name="T:Sandbox.ParticleFloat">
            <summary>
            Represents a floating-point value that can change over time with support for various evaluation modes.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleFloat.ValueType.Constant">
            <summary>
            A value that doesn't change over time.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleFloat.ValueType.Range">
            <summary>
            The value is interpolated between two fixed floats.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleFloat.ValueType.Curve">
            <summary>
            A curve that defines how the value changes over time or based on an evaluation factor.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleFloat.ValueType.CurveRange">
            <summary>
            Two curves where the value is interpolated between them.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleFloat.EvaluationType.Life">
            <summary>
            Evaluates the value based on the lifetime using its normalized age.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleFloat.EvaluationType.Frame">
            <summary>
            Evaluates the value based on the current frame, introducing randomness for dynamic effects.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleFloat.EvaluationType.Seed">
            <summary>
            Evaluates the value based on a random seed. This means that in most situations, it's random per context.
            Like if this is on a particle, the value will be random per particle.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleFloat.Evaluate(System.Single@,System.Single@)">
            <summary>
            Evaluates the value based on the given delta and random seed, optimized for performance.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleFloat.Evaluate(Sandbox.IDynamicFloatContext,System.Int32,System.Int32)">
            <summary>
            Evaluates the value using a dynamic context and seed, optimized for clarity and functionality.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleFloat.IsNearlyZero">
            <summary>
            Checks if the value is nearly zero.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleFloat.JsonRead(System.Text.Json.Utf8JsonReader@,System.Type)">
            <summary>
            Reads a ParticleFloat instance from JSON, refactored for modularity.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleFloat.JsonWrite(System.Object,System.Text.Json.Utf8JsonWriter)">
            <summary>
            Writes a ParticleFloat instance to JSON, refactored for modularity.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleFloat.GetValue">
            <summary>
            This is only here to remain "compatible" with RangedFloat
            </summary>
        </member>
        <member name="T:Sandbox.ParticleGameSystem">
            <summary>
            Ticks the physics in FrameStage.PhysicsStep
            </summary>
        </member>
        <member name="M:Sandbox.ParticleGameSystem.ProcessWork(Sandbox.ParticleEffect.ParticleWork)">
            <summary>
            We process the particles in chunks, in parallel. We don't do one particle at a time because 
            it'd spend more time doing all the admin of giving them to threads than it would actually take.
            </summary>
            <param name="work"></param>
        </member>
        <member name="T:Sandbox.IBatchedParticleSpriteRenderer">
            <summary>
            Interface for batched particle renderers that can be processed by SceneSpriteSystem
            </summary>
        </member>
        <member name="T:Sandbox.IBatchedParticleSpriteRenderer.ParticleProcessResult">
            <summary>
            Result of particle processing operation
            </summary>
        </member>
        <member name="M:Sandbox.IBatchedParticleSpriteRenderer.ParticleProcessResult.#ctor(System.Int32,System.Int32)">
            <summary>
            Result of particle processing operation
            </summary>
        </member>
        <member name="M:Sandbox.IBatchedParticleSpriteRenderer.ProcessParticlesDirectly(System.Span{Sandbox.Rendering.SpriteBatchSceneObject.SpriteData})">
            <summary>
            Efficiently converts particle data directly into GPU-ready SpriteData format.
            This is the hot path for particle rendering - bypasses intermediate allocations
            by writing directly to the destination sprite buffer.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleLightRenderer">
            <summary>
            Adds lighting to particles in your effect.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleLightRenderer.Ratio">
            <summary>
            If 1, then every particle will get a light. If 0, no particles will get a light. If 0.5, half will get a particle.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleModelRenderer">
            <summary>
            Renders particles as models, using the particle's position, rotation, and size.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.RenderOptions">
            <summary>
            Render options for advanced rendering.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleModelRenderer.ModelEntry">
            <summary>
            Entry for a model, including its material group and body group settings.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.ModelEntry.Model">
            <summary>
            The model associated with this entry.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.ModelEntry.MaterialGroup">
            <summary>
            Material group for the model.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.ModelEntry.BodyGroups">
            <summary>
            Body group mask for the model.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.ModelEntry.HasMaterialGroups">
            <summary>
            Indicates whether the model has material groups.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.ModelEntry.HasBodyGroups">
            <summary>
            Indicates whether the model has body groups.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleModelRenderer.ModelEntry.op_Implicit(Sandbox.Model)~Sandbox.ParticleModelRenderer.ModelEntry">
            <summary>
            Converts a <see cref="P:Sandbox.ParticleModelRenderer.ModelEntry.Model"/> to a <see cref="T:Sandbox.ParticleModelRenderer.ModelEntry"/>.
            </summary>
            <param name="model">The model to convert.</param>
            <returns>A new <see cref="T:Sandbox.ParticleModelRenderer.ModelEntry"/> instance.</returns>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.Models">
            <summary>
            List of models for rendering. This property is obsolete; use <see cref="P:Sandbox.ParticleModelRenderer.Choices"/> instead.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.Choices">
            <summary>
            List of model entries available for rendering.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.MaterialOverride">
            <summary>
            Material override for rendering.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.RotateWithGameObject">
            <summary>
            If true, the models will rotate relative to the this GameObject
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.Scale">
            <summary>
            Scale factor for particle rendering.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.CastShadows">
            <summary>
            Indicates whether particles cast shadows.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleModelRenderer.OnParticleCreated(Sandbox.Particle)">
            <summary>
            Called when a particle is created.
            </summary>
            <param name="p">The particle being created.</param>
        </member>
        <member name="P:Sandbox.ParticleModelRenderer.ComponentVersion">
            <summary>
            Version of the component.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleModelRenderer.Upgrader_v1(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Upgrades the JSON representation of the particle model renderer to version 1.
            </summary>
            <param name="obj">The JSON object to upgrade.</param>
        </member>
        <member name="T:Sandbox.ParticleModel">
            <summary>
            Represents a particle model listener that updates the scene object based on particle properties.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleModel.Renderer">
            <summary>
            Renderer associated with this particle model.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleModel.#ctor(Sandbox.ParticleModelRenderer)">
            <summary>
            Initializes a new instance of the <see cref="T:Sandbox.ParticleModel"/> class.
            </summary>
            <param name="renderer">The particle model renderer.</param>
        </member>
        <member name="M:Sandbox.ParticleModel.OnEnabled(Sandbox.Particle)">
            <summary>
            Called when the particle is enabled.
            </summary>
            <param name="p">The particle being enabled.</param>
        </member>
        <member name="M:Sandbox.ParticleModel.OnDisabled(Sandbox.Particle)">
            <summary>
            Called when the particle is disabled.
            </summary>
            <param name="p">The particle being disabled.</param>
        </member>
        <member name="M:Sandbox.ParticleModel.OnUpdate(Sandbox.Particle,System.Single)">
            <summary>
            Updates the particle.
            </summary>
            <param name="p">The particle being updated.</param>
            <param name="dt">The delta time since the last update.</param>
        </member>
        <member name="T:Sandbox.ParticleRenderer">
            <summary>
            Renders a set of particles. Should be attached to a <see cref="P:Sandbox.ParticleRenderer.ParticleEffect"/>.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleRenderer.GetLocalBounds">
            <summary>
            Return the bounds of this renderer in local space.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleSpriteRenderer">
            <summary>
            Renders particles as 2D sprites - can be static or animated
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Sprite">
            <summary>
            The sprite resource to render. This can be completely static or contain animation(s).
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.StartingAnimationName">
            <summary>
            The animation that this sprite should start playing when the scene starts.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Scale">
            <summary>
            The scale of the sprite when rendered.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Additive">
            <summary>
            Whether or not the sprite should be rendered additively.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Shadows">
            <summary>
            Whether or not the sprite should cast shadows in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Lighting">
            <summary>
            Whether or not the sprite should be lit by the scene lighting.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Opaque">
            <summary>
            Indicates whether the sprite is opaque, optimizing rendering by skipping sorting.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.TextureFilter">
            <summary>
            The texture filtering mode used when rendering the sprite. For pixelated sprites use <see cref="F:Sandbox.Rendering.FilterMode.Point"/>.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Alignment">
            <summary>
            Alignment mode for the sprite's billboard behavior.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.SortMode">
            <summary>
            Sorting mode used for rendering particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.DepthFeather">
            <summary>
            Amount of feathering applied to the depth, softening its intersection with geometry.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.FogStrength">
            <summary>
            The strength of the fog effect applied to the sprite. This determines how much the sprite blends with any fog in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.FaceVelocity">
            <summary>
            Aligns the sprite to face its velocity direction.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.RotationOffset">
            <summary>
            Offset applied to the rotation when facing velocity.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.MotionBlur">
            <summary>
            Enables motion blur effects for the sprite.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.LeadingTrail">
            <summary>
            Determines whether the motion blur effect includes a leading trail.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.BlurAmount">
            <summary>
            Amount of blur applied to the sprite during motion blur.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.BlurSpacing">
            <summary>
            Spacing between blur samples in the motion blur effect.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.BlurOpacity">
            <summary>
            Opacity of the blur effect applied to the sprite.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.CurrentAnimation">
            <summary>
            The animation that is currently being played. Returns null if no sprite is set or the sprite has no animations.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.IsAnimated">
            <summary>
            Whether or not the sprite is animated. This is true if the sprite has more than one animation or if the current animation has more than one frame.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.IsSorted">
            <summary>
            Interface property to determine if particles should be sorted
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Pivot">
            <summary>
            The pivot point of the sprite, used for rotation and scaling. This is in normalized coordinates (0 to 1).
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Texture">
            <summary>
            The texture being displayed from the sprite given the current frame/animation.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.RenderTexture">
            <summary>
            Provides texture for rendering - implementation for IBatchedParticleSpriteRenderer
            </summary>
        </member>
        <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.LookAtCamera">
            <summary>
            Look directly at the camera, apply roll
            </summary>
        </member>
        <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.RotateToCamera">
            <summary>
            Look at the camera but don't pitch up and down, up is always up, can roll
            </summary>
        </member>
        <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.Particle">
            <summary>
            Use rotation provided by the particle, pitch yaw and roll
            </summary>
        </member>
        <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.Object">
            <summary>
            Align to game object rotation, apply pitch yaw and roll
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSpriteRenderer.SetAnimation(System.Int32)">
            <summary>
            Set the animation by index (the first animation is index 0).
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSpriteRenderer.SetAnimation(System.String)">
            <summary>
            Set the animation by name.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSpriteRenderer.Upgrader_v2(System.Text.Json.Nodes.JsonObject)">
            <summary>
            v2
            - Use embedded Sprite resource instead of a single Texture
            </summary>
        </member>
        <member name="T:Sandbox.ParticleTextRenderer">
            <summary>
            Renders particles as 2D sprites
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.Opaque">
            <summary>
            Indicates whether the sprite is opaque, optimizing rendering by skipping sorting.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.FaceVelocity">
            <summary>
            Aligns the sprite to face its velocity direction.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.RotationOffset">
            <summary>
            Offset applied to the rotation when facing velocity.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.MotionBlur">
            <summary>
            Enables motion blur effects for the sprite.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.LeadingTrail">
            <summary>
            Determines whether the motion blur effect includes a leading trail.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.BlurAmount">
            <summary>
            Amount of blur applied to the sprite during motion blur.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.BlurSpacing">
            <summary>
            Spacing between blur samples in the motion blur effect.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.BlurOpacity">
            <summary>
            Opacity of the blur effect applied to the sprite.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.Alignment">
            <summary>
            Alignment mode for the sprite's billboard behavior.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.SortMode">
            <summary>
            Sorting mode used for rendering particles.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.IsSorted">
            <summary>
            Interface property to determine if particles should be sorted
            </summary>
        </member>
        <member name="P:Sandbox.ParticleTextRenderer.RenderTexture">
            <summary>
            Provides texture for rendering the sprite
            </summary>
        </member>
        <member name="T:Sandbox.ParticleTrailRenderer">
            <summary>
            Renders a trail for each particle in the effect.
            </summary>
        </member>
        <member name="T:Sandbox.AmbientOcclusion">
            <summary>
            Adds an approximation of ambient occlusion using Screen Space Ambient Occlusion (SSAO).
            It darkens areas where ambient light is generally occluded from such as corners, crevices
            and surfaces that are close to each other.
            </summary>
        </member>
        <member name="F:Sandbox.AmbientOcclusion.SampleQuality.Low">
            <summary>
            9 samples
            </summary>
        </member>
        <member name="F:Sandbox.AmbientOcclusion.SampleQuality.Medium">
            <summary>
            16 samples
            </summary>
        </member>
        <member name="F:Sandbox.AmbientOcclusion.SampleQuality.High">
            <summary>
            25 samples
            </summary>
        </member>
        <member name="P:Sandbox.AmbientOcclusion.Intensity">
            <summary>
            The intensity of the darkening effect. Has no impact on performance.
            </summary>
        </member>
        <member name="P:Sandbox.AmbientOcclusion.Radius">
            <summary>
            Maximum distance of samples from pixel when determining its occlusion, in world units.
            </summary>
        </member>
        <member name="P:Sandbox.AmbientOcclusion.FalloffRange">
            <summary>
            Gently reduce sample impact as it gets out of the effect's radius bounds
            </summary>
        </member>
        <member name="P:Sandbox.AmbientOcclusion.Quality">
            <summary>
            Number of pixel samples taken to determine occlusion
            </summary>
        </member>
        <member name="P:Sandbox.AmbientOcclusion.DenoiseMode">
            <summary>
            How we should denoise the effect
            </summary>
        </member>
        <member name="P:Sandbox.AmbientOcclusion.ThinCompensation">
            <summary>
            Slightly reduce impact of samples further back to counter the bias from depth-based (incomplete) input scene geometry data
            </summary>
        </member>
        <member name="F:Sandbox.AmbientOcclusion.DenoiseModes.Spatial">
            <summary>
            Applies spatial denoising to reduce noise by averaging pixel values within a local neighborhood.
            This method smooths out noise by considering the spatial relationship between pixels in a single frame.
            </summary>
        </member>
        <member name="F:Sandbox.AmbientOcclusion.DenoiseModes.Temporal">
            <summary>
            Applies temporal denoising to reduce noise by averaging pixel values over multiple frames.
            This method leverages the temporal coherence of consecutive frames to achieve a noise-free result.
            </summary>
        </member>
        <member name="T:Sandbox.Bloom">
            <summary>
            Applies a bloom effect to the camera
            </summary>
        </member>
        <member name="T:Sandbox.Blur">
            <summary>
            Applies a blur effect to the camera.
            </summary>
        </member>
        <member name="T:Sandbox.ChromaticAberration">
            <summary>
            Applies a chromatic aberration effect to the camera
            </summary>
        </member>
        <member name="P:Sandbox.ChromaticAberration.Scale">
            <summary>
            Enable chromatic aberration
            </summary>
        </member>
        <member name="P:Sandbox.ChromaticAberration.Offset">
            <summary>
            The pixel offset for each color channel. These values should
            be very small as it's in UV space. (0.004 for example)
            X = Red
            Y = Green
            Z = Blue
            </summary>
        </member>
        <member name="T:Sandbox.ColorAdjustments">
            <summary>
            Applies color adjustments to the camera.
            </summary>
        </member>
        <member name="T:Sandbox.ColorGrading">
            <summary>
            Applies color grading to the camera
            </summary>
        </member>
        <member name="M:Sandbox.ColorGrading.ProcessCurve(Sandbox.Curve,System.String)">
            <summary>
            Represent our curves into shaders
            </summary>
        </member>
        <member name="T:Sandbox.DepthOfField">
            <summary>
            Applies a depth of field effect to the camera
            </summary>
        </member>
        <member name="P:Sandbox.DepthOfField.BlurSize">
            <summary>
            How blurry to make stuff that isn't in focus.
            </summary>
        </member>
        <member name="P:Sandbox.DepthOfField.FocalDistance">
            <summary>
            How far away from the camera to focus in world units.
            </summary>
        </member>
        <member name="P:Sandbox.DepthOfField.FocusRange">
            <summary>
            This modulates how far is the blur to the image.
            </summary>
        </member>
        <member name="P:Sandbox.DepthOfField.FrontBlur">
            <summary>
            Should we blur what's ahead the focal point towards us?
            </summary>
        </member>
        <member name="P:Sandbox.DepthOfField.BackBlur">
            <summary>
            Should we blur what's behind the focal point?
            </summary>
        </member>
        <member name="T:Sandbox.FilmGrain">
            <summary>
            Applies a film grain effect to the camera
            </summary>
        </member>
        <member name="T:Sandbox.Highlight">
            <summary>
            This should be added to a camera that you want to outline stuff
            </summary>
        </member>
        <member name="T:Sandbox.HighlightOutline">
            <summary>
            This component should be added to stuff you want to be outlined. You will also need to 
            add the Highlight component to the camera you want to render the outlines.
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.Material">
            <summary>
            If defined, the glow will use this material rather than a generated one.
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.Color">
            <summary>
            The colour of the glow outline
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.ObscuredColor">
            <summary>
            The colour of the glow when the mesh is obscured by something closer.
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.InsideColor">
            <summary>
            Color of the inside of the glow
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.InsideObscuredColor">
            <summary>
            Color of the inside of the glow when the mesh is obscured by something closer.
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.Width">
            <summary>
            The width of the line of the glow
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.OverrideTargets">
            <summary>
            Specify targets of the outline manually
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.Targets">
            <summary>
            Specify targets of the outline manually
            </summary>
        </member>
        <member name="M:Sandbox.HighlightOutline.GetOutlineTargets">
            <summary>
            Get a list of targets that we want to draw the outline around
            </summary>
        </member>
        <member name="T:Sandbox.MotionBlur">
            <summary>
            Applies a motion blur effect to the camera
            </summary>
        </member>
        <member name="T:Sandbox.Pixelate">
            <summary>
            Applies a pixelate effect to the camera
            </summary>
        </member>
        <member name="T:Sandbox.PostProcess">
            <summary>
            Adds an effect to the camera
            </summary>
        </member>
        <member name="P:Sandbox.PostProcess.RenderStage">
            <summary>
            The stage in the render pipeline that we'll get rendered in
            </summary>
        </member>
        <member name="P:Sandbox.PostProcess.RenderOrder">
            <summary>
            Lower numbers get renderered first
            </summary>
        </member>
        <member name="M:Sandbox.PostProcess.UpdateCommandList">
            <summary>
            You should implement this method and fill the CommandList with the actions
            that you want to do for this post process.
            </summary>
        </member>
        <member name="P:Sandbox.ScreenSpaceReflections.RoughnessCutoff">
            <summary>
            Stop tracing rays after this roughness value. 
            This is meant to be used to avoid tracing rays for very rough surfaces which are unlikely to have any reflections.
            This is a performance optimization.
            </summary>
        </member>
        <member name="T:Sandbox.Sharpen">
            <summary>
            Applies a sharpen effect to the camera
            </summary>
        </member>
        <member name="T:Sandbox.Vignette">
            <summary>
            Applies a vignette to the camera
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Color">
            <summary>
            The color of the vignette or the "border"
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Intensity">
            <summary>
            How strong the vignette is. This is a value between 0 -> 1
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Smoothness">
            <summary>
            How much fall off or how blurry the vignette is
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Roundness">
            <summary>
            How circular or round the vignette is
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Center">
            <summary>
            The center of the vignette in relation to UV space. This means
            a value of {0.5, 0.5} is the center of the screen
            </summary>
        </member>
        <member name="T:Sandbox.Decal">
            <summary>
            The Decal component projects textures onto model's opaque or transparent surfaces.
            They inherit and modify the PBR properties of the surface they're projected on.
            </summary>
        </member>
        <member name="P:Sandbox.Decal.LifeTime">
            <summary>
            How long should this decal live for?
            </summary>
        </member>
        <member name="P:Sandbox.Decal.Looped">
            <summary>
            If true then the decal will repeat itself forever
            </summary>
        </member>
        <member name="P:Sandbox.Decal.Transient">
            <summary>
            If true then this decal will automatically get removed when maxdecals are exceeded. This is good for
            things like bullect impacts, where you want to keep them around for as long as possible but also
            don't want to have an unlimited amount of them hanging around.
            
            Note that while the component will be destroyed, you probably want a TemporaryEffect component on the 
            GameObject to make sure it all gets fully deleted.
            </summary>
        </member>
        <member name="P:Sandbox.Decal.Size">
            <summary>
            A 2D size of the decal in world units.
            </summary>
        </member>
        <member name="P:Sandbox.Decal.Scale">
            <summary>
            Scale the width and height by this value
            </summary>
        </member>
        <member name="P:Sandbox.Decal.Rotation">
            <summary>
            Scale the width and height by this value
            </summary>
        </member>
        <member name="P:Sandbox.Decal.Depth">
            <summary>
            The depth of the decal in world units. This is how far the decal extends into the surface it is projected onto.
            </summary>
        </member>
        <member name="P:Sandbox.Decal.Parallax">
            <summary>
            How long should this decal live for?
            </summary>
        </member>
        <member name="P:Sandbox.Decal.ColorTint">
            <summary>
            Tints the color of the decal's albedo and can be used to adjust the overall opacity of the decal.
            </summary>
        </member>
        <member name="P:Sandbox.Decal.ColorMix">
            <summary>
            Controls the opacity of the decal's color texture without reducing the impact of the normal or rmo texture.
            Set to 0 to create a normal/rmo only decal masked by the color textures alpha.
            </summary>
        </member>
        <member name="P:Sandbox.Decal.AttenuationAngle">
            <summary>
            Attenuation angle controls how much the decal fades at an angle.
            At 0 it does not fade at all. Up to 1 it fades the most.
            </summary>
        </member>
        <member name="P:Sandbox.Decal.SortLayer">
            <summary>
            Determines the order the decal gets rendered in, the higher the layer the more priority it has.
            Decals on the same layer get automatically sorted by their GameObject ID.
            </summary>
        </member>
        <member name="P:Sandbox.Decal.SequenceId">
            <summary>
            Which sequence to use
            </summary>
        </member>
        <member name="P:Sandbox.Decal.WorldBounds">
            <summary>
            Get the world bounds of this decal
            </summary>
        </member>
        <member name="M:Sandbox.Decal.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our scene object tags
            </summary>
        </member>
        <member name="T:Sandbox.DecalRenderer">
            <summary>
            Component that creates a projected decal relative to its GameObject.
            </summary>
        </member>
        <member name="T:Sandbox.GradientFog">
            <summary>
            Adds a gradient fog to the world
            </summary>
        </member>
        <member name="T:Sandbox.ISpriteRenderGroup">
            <summary>
            Base interface for components that can be grouped for sprite rendering.
            Contains the 4 fields needed for render group classification.
            </summary>
        </member>
        <member name="T:Sandbox.LineRenderer">
            <summary>
            Renders a line between a list of points
            </summary>
        </member>
        <member name="M:Sandbox.LineRenderer.CalculateRMFNormals(System.Span{Vector3},System.Span{Vector3})">
            <summary>
            Calculates Rotation Minimizing Frame normals for a sequence of points in a single pass
            </summary>
        </member>
        <member name="T:Sandbox.ModelRenderer">
            <summary>
            Renders a model in the world
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.GetAttachmentObject(System.String)">
            <summary>
            Get the GameObject of a specific attachment.
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.GetAttachmentObject(Sandbox.ModelAttachments.Attachment)">
            <summary>
            Get the GameObject of a specific attachment.
            </summary>
        </member>
        <member name="P:Sandbox.ModelRenderer.LodOverride">
            <summary>
            Force a level of detail.
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.SetBodyGroup(System.String,System.Int32)">
            <summary>
            Set body group value by name
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.SetBodyGroup(System.Int32,System.Int32)">
            <summary>
            Set body group value by index
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.GetBodyGroup(System.String)">
            <summary>
            Get body group value by name
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.GetBodyGroup(System.Int32)">
            <summary>
            Get body group value by index
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our scene object tags
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.CopyFrom(Sandbox.Renderer)">
            <summary>
            Copy everything from another renderer
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.ClearMaterialOverrides">
            <summary>
            Completely stop overriding materials
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.SetMaterialOverride(Sandbox.Material,System.String)">
            <summary>
            Set a material override for a material with a specific attribute set. For example, if you have a model with lots of different materials, but one of them has an attribute "skin" set to "1", then 
            calling this with a material and "skin" will override only that material.
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.ApplyMaterialOverrides">
            <summary>
            Apply any saved material overrides to the scene object.
            </summary>
        </member>
        <member name="P:Sandbox.ModelRenderer.Materials">
            <summary>
            Access to the materials 
            </summary>
        </member>
        <member name="M:Sandbox.Renderer.CopyFrom(Sandbox.Renderer)">
            <summary>
            Copy everything from another renderer
            </summary>
        </member>
        <member name="P:Sandbox.Renderer.Attributes">
            <summary>
            Attributes that are applied to the renderer based on the current material and shader.
            If the renderer is disabled, the changes are deferred until it is enabled again.
            Attributes are not saved to disk, and are not cloned when copying the renderer.
            </summary>
        </member>
        <member name="P:Sandbox.Renderer.ExecuteBefore">
            <summary>
            A command list which is executed immediately before rendering this
            </summary>
        </member>
        <member name="P:Sandbox.Renderer.ExecuteAfter">
            <summary>
            A command list which is executed immediately after rendering this
            </summary>
        </member>
        <member name="M:Sandbox.Renderer.BackupRenderAttributes(Sandbox.RenderAttributes)">
            <summary>
            Backup the specified RenderAttributes so we can restore them later with <see cref="M:Sandbox.Renderer.RestoreRenderAttributes(Sandbox.RenderAttributes)"/>
            </summary>
        </member>
        <member name="M:Sandbox.Renderer.RestoreRenderAttributes(Sandbox.RenderAttributes)">
            <summary>
            Restore any attributes that were previously backed up with <see cref="M:Sandbox.Renderer.BackupRenderAttributes(Sandbox.RenderAttributes)"/>
            </summary>
        </member>
        <member name="M:Sandbox.Renderer.RenderSceneObject(Sandbox.Rendering.RendererSetup)">
            <summary>
            Render the <see cref="T:Sandbox.SceneObject"/> of this renderer with the specified overrides.
            </summary>
        </member>
        <member name="P:Sandbox.RenderOptions.Game">
            <summary>
            Regular game rendering layers
            </summary>
        </member>
        <member name="P:Sandbox.RenderOptions.Overlay">
            <summary>
            Rendered above everything else
            </summary>
        </member>
        <member name="P:Sandbox.RenderOptions.Bloom">
            <summary>
            Rendererd during bloom
            </summary>
        </member>
        <member name="P:Sandbox.RenderOptions.AfterUI">
            <summary>
            Rendered after the UI is rendered
            </summary>
        </member>
        <member name="M:Sandbox.RenderOptions.Apply(Sandbox.SceneObject)">
            <summary>
            Apply these options to a SceneObject
            </summary>
        </member>
        <member name="T:Sandbox.SkinnedModelRenderer">
            <summary>
            Renders a skinned model in the world. A skinned model is any model with bones/animations.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.GetBoneObject(System.Int32)">
            <summary>
            Get the GameObject of a specific bone.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.GetBoneObject(System.String)">
            <summary>
            Find a bone's GameObject by bone name. 
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.GetBoneObject(Sandbox.BoneCollection.Bone)">
            <inheritdoc cref="M:Sandbox.SkinnedModelRenderer.GetBoneObject(System.Int32)"/>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.TryGetBoneTransform(System.String,Transform@)">
            <summary>
            Try to get the final worldspace bone transform.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.TryGetBoneTransform(Sandbox.BoneCollection.Bone@,Transform@)">
            <summary>
            Try to get the final worldspace bone transform.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.TryGetBoneTransformAnimation(Sandbox.BoneCollection.Bone@,Transform@)">
            <summary>
            Try to get the worldspace bone transform after animation but before physics and procedural bones.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.GetBoneTransforms(System.Boolean)">
            <summary>
            Allocate an array of bone transforms in either world space or parent space.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.GetBoneVelocities">
            <summary>
            Allocate an array of bone veloicities in world space
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.UseAnimGraph">
            <summary>
            Usually used for turning off animation on ragdolls.
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.AnimationGraph">
            <summary>
            Override animgraph, otherwise uses animgraph of the model.
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.Sequence">
            <summary>
            Allows playback of sequences directly, rather than using an animation graph.
            Requires <see cref="P:Sandbox.SkinnedModelRenderer.UseAnimGraph"/> disabled if the scene model has one.
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.PlaybackRate">
            <summary>
            Control playback rate of animgraph or current sequence.
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.PlayAnimationsInEditorScene">
            <summary>
            If true then animations will play while in an editor scene.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.ReadBonesFromGameObjects">
            <summary>
            For Procedural Bones, copy the current value to the animation bone
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.UpdateGameObjectsFromBones">
            <summary>
            For non procedural bones, copy the "parent space" bone from to the GameObject transform. Will
            return true if any transforms have changed.
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.OnFootstepEvent">
            <summary>
            Called when a footstep event happens
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.OnGenericEvent">
            <summary>
            Called when a generic animation event happens
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.OnSoundEvent">
            <summary>
            Called when a sound event happens
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.OnAnimTagEvent">
            <summary>
            Called when an anim tag event happens
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.Morphs">
            <summary>
            Access to the morphs for this model
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.MorphAccessor.Set(System.String,System.Single)">
            <summary>
            Set this value
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.MorphAccessor.ContainsOverride(System.String)">
            <summary>
            Returns true if we have this value overridden (set). False means its value is likely
            being driven by animation etc.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.MorphAccessor.Get(System.String)">
            <summary>
            Get this value
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.MorphAccessor.Clear(System.String)">
            <summary>
            Clear this value, don't override it
            </summary>
        </member>
        <member name="F:Sandbox.SkinnedModelRenderer.parameters">
            <summary>
            If something sets parameters before the model is spawned, then we store them
            and apply them when it does spawn. This isn't ideal, but it is what it is.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.ClearParameters">
            <summary>
            Remove any stored parameters
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.SetLookDirection(System.String,Vector3)">
            <summary>
            Converts value to vector local to this entity's eyepos and passes it to SetAnimVector
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.SetLookDirection(System.String,Vector3,System.Single)">
            <summary>
            Converts value to vector local to this entity's eyepos and passes it to SetAnimVector. 
            This also sets {name}_weight to the weight value.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.SetIk(System.String,Transform)">
            <summary>
            Sets an IK parameter. This sets 3 variables that should be set in the animgraph:
            1. ik.{name}.enabled
            2. ik.{name}.position
            3. ik.{name}.rotation
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.ClearIk(System.String)">
            <summary>
            This sets ik.{name}.enabled to false.
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.Parameters">
            <summary>
            Access to the animgraph parameters for this model
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.Duration">
            <inheritdoc cref="P:Sandbox.AnimationSequence.Duration"/>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.IsFinished">
            <inheritdoc cref="P:Sandbox.AnimationSequence.IsFinished"/>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.TimeNormalized">
            <inheritdoc cref="P:Sandbox.AnimationSequence.TimeNormalized"/>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.Time">
            <inheritdoc cref="P:Sandbox.AnimationSequence.Time"/>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.SequenceNames">
            <inheritdoc cref="P:Sandbox.AnimationSequence.SequenceNames"/>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.Name">
            <inheritdoc cref="P:Sandbox.AnimationSequence.Name"/>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.Looping">
            <inheritdoc cref="P:Sandbox.AnimationSequence.Looping"/>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.Blending">
            <inheritdoc cref="P:Sandbox.AnimationSequence.Blending"/>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.PlaybackRate">
            <summary>
            Control playback rate of sequence.
            </summary>
        </member>
        <member name="T:Sandbox.SkyBox2D">
            <summary>
            Adds a 2D skybox to the world
            </summary>
        </member>
        <member name="M:Sandbox.SkyBox2D.OnTagsChanged">
            <summary>
            Tags have been updated
            </summary>
        </member>
        <member name="T:Sandbox.SpriteRenderer">
            <summary>
            Renders a sprite in the world
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.Sprite">
            <summary>
            The sprite resource to render. This can be completely static or contain animation(s).
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.StartingAnimationName">
            <summary>
            The animation that this sprite should start playing when the scene starts.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.PlaybackSpeed">
            <summary>
            The playback speed of the animation. 0 is paused, and negative values will play the animation in reverse.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.Size">
            <summary>
            The width and height of the sprite in world units.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.Color">
            <summary>
            The color of the sprite. This is multiplied with the texture color.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.Additive">
            <summary>
            Whether or not the sprite should be rendered additively.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.Shadows">
            <summary>
            Whether or not the sprite should cast shadows.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.Opaque">
            <summary>
            Whether or not the sprite should be rendered opaque. If true, any semi-transparent pixels will be dithered.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.Lighting">
            <summary>
            Whether or not the sprite should be lit by the scene's lighting system. Otherwise it will be unlit/fullbright.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.DepthFeather">
            <summary>
            Amount of feathering applied to the depth, softening its intersection with geometry.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.FogStrength">
            <summary>
            The strength of the fog effect applied to the sprite. This determines how much the sprite blends with any fog in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.FlipHorizontal">
            <summary>
            Whether or not the sprite should be flipped horizontally.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.FlipVertical">
            <summary>
            Whether or not the sprite should be flipped vertically.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.TextureFilter">
            <summary>
            The texture filtering mode used when rendering the sprite. For pixelated sprites, use <see cref="F:Sandbox.UI.ImageRendering.Point"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.Billboard">
            <summary>
            Alignment mode for the sprite's billboard behavior.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.IsSorted">
            <summary>
            Whether or not the sprite should be sorted by depth. If the sprite is opaque, this can be turned off for a performance boost if not needed.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.CurrentAnimation">
            <summary>
            The animation that is currently being played. Returns null if no sprite is set or the sprite has no animations.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.CurrentFrameIndex">
            <summary>
            The index of the current frame being displayed. This will change over time if the sprite is animated, and can be set to go to a specific frame even during playback.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.IsAnimated">
            <summary>
            Whether or not the sprite is animated. This is true if the sprite has more than one animation or if the current animation has more than one frame.
            </summary>
        </member>
        <member name="P:Sandbox.SpriteRenderer.Texture">
            <summary>
            The texture of the current frame being displayed. Returns a transparent texture when no valid frame is available.
            </summary>
        </member>
        <member name="M:Sandbox.SpriteRenderer.PlayAnimation(System.Int32)">
            <summary>
            Play an animation by index (the first animation is index 0).
            </summary>
        </member>
        <member name="M:Sandbox.SpriteRenderer.PlayAnimation(System.String)">
            <summary>
            Play an animation by name.
            </summary>
        </member>
        <member name="M:Sandbox.SpriteRenderer.Upgrader_v2(System.Text.Json.Nodes.JsonObject)">
            <summary>
            v2
            - Use embedded Sprite resource instead of a single Texture
            </summary>
        </member>
        <member name="T:Sandbox.TextRenderer">
            <summary>
            Renders text in the world
            </summary>
        </member>
        <member name="T:Sandbox.TextRenderer.HAlignment">
            <summary>
            Represents the horizontal alignment of the text.
            </summary>
        </member>
        <member name="T:Sandbox.TextRenderer.VAlignment">
            <summary>
            Represents the vertical alignment of the text.
            </summary>
        </member>
        <member name="P:Sandbox.TextRenderer.TextScope">
            <summary>
            The text scope defines what text to render and it's visual properties (such as font, color, outline, etc.)
            </summary>
        </member>
        <member name="P:Sandbox.TextRenderer.Scale">
            <summary>
            The size of the text in the world. This is different from the font size, which is defined in the TextScope and determines resolution of the rendered text.
            </summary>
        </member>
        <member name="P:Sandbox.TextRenderer.HorizontalAlignment">
            <summary>
            The horizontal alignment of the text in the world.
            </summary>
        </member>
        <member name="P:Sandbox.TextRenderer.VerticalAlignment">
            <summary>
            The vertical alignment of the text in the world.
            </summary>
        </member>
        <member name="P:Sandbox.TextRenderer.BlendMode">
            <summary>
            The blend mode of the text. This determines how the text is rendered over the world.
            </summary>
        </member>
        <member name="P:Sandbox.TextRenderer.FogStrength">
            <summary>
            The strength of the fog effect applied to the text. This determines how much the text blends with any fog in the scene.
            </summary>
        </member>
        <member name="M:Sandbox.TextRenderer.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our scene object tags
            </summary>
        </member>
        <member name="P:Sandbox.TextRenderer.Color">
            <summary>
            The color of the text from the TextScope.
            </summary>
        </member>
        <member name="P:Sandbox.TextRenderer.FontSize">
            <summary>
            The font size of the text from the TextScope. This is different from the Scale, which determines how large the text appears in the world.
            </summary>
        </member>
        <member name="T:Sandbox.TrailRenderer">
            <summary>
            Renders a trail behind the object, when it moves.
            </summary>
        </member>
        <member name="P:Sandbox.TrailRenderer.Emitting">
            <summary>
            When enabled, new points are added to the trail.
            </summary>
        </member>
        <member name="T:Sandbox.VolumetricFogController">
            <summary>
            Internal component for storing the baked fog texture
            We don't need to expose the volumetric fog controller like we did previously with entities,
            But we need to be fetch the baked fog texture from the map file
            </summary>
        </member>
        <member name="T:Sandbox.VolumetricFogVolume">
            <summary>
            Adds a volumetric fog volume to the scene.
            </summary>
        </member>
        <member name="T:Sandbox.Terrain">
            <summary>
            Terrain renders heightmap based terrain.
            </summary>
        </member>
        <member name="M:Sandbox.Terrain.Create">
            <summary>
            Call on enable or storage change
            </summary>
        </member>
        <member name="M:Sandbox.Terrain.RayIntersects(Ray,System.Single,Vector3@)">
            <summary>
            Given a world ray, finds out the LOCAL position it intersects with this terrain.
            </summary>
        </member>
        <member name="M:Sandbox.Terrain.SyncCPUTexture(Sandbox.Terrain.SyncFlags,Sandbox.RectInt)">
            <summary>
            Downloads dirty regions from the GPU texture maps onto the CPU, updating collider data and making changes saveable.
            This is used from the editor after modifying.
            </summary>
        </member>
        <member name="M:Sandbox.Terrain.SyncGPUTexture">
            <summary>
            Updates the GPU texture maps with the CPU data
            </summary>
        </member>
        <member name="P:Sandbox.Terrain.Storage">
            <summary>
            Storage contains pretty much everything: heightmap, controlmaps, materials, grass, etc etc
            </summary>
        </member>
        <member name="F:Sandbox.Terrain._materialOverride">
            <summary>
            Override the terrain rendering with your own material shader.
            This needs to be explicitly set up to work with the Terrain Shader API.
            </summary>
        </member>
        <member name="P:Sandbox.Terrain.TerrainSize">
            <summary>
            Uniform world size of the width and length of the terrain.
            </summary>
        </member>
        <member name="P:Sandbox.Terrain.TerrainHeight">
            <summary>
            World size of the maximum height of the terrain.
            </summary>
        </member>
        <member name="M:Sandbox.Terrain.UpdateTerrainBuffer">
            <summary>
            Upload the Terrain buffer, this should be called when some base settings change.
            </summary>
        </member>
        <member name="M:Sandbox.Terrain.UpdateMaterialsBuffer">
            <summary>
            Upload the Terrain buffer, this should be called when materials are added, removed or modified.
            </summary>
        </member>
        <member name="M:Sandbox.TerrainClipmap.GenerateMesh_DiamondSquare(System.Int32,System.Int32,Sandbox.Material)">
            <summary>
            Inefficient implementation of diamond square, it's not merging verticies.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.PanelComponent.HasClass(System.String)">
            <inheritdoc cref="M:Sandbox.UI.Panel.HasClass(System.String)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.RemoveClass(System.String)">
            <inheritdoc cref="M:Sandbox.UI.Panel.RemoveClass(System.String)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.AddClass(System.String)">
            <inheritdoc cref="M:Sandbox.UI.Panel.AddClass(System.String)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.BindClass(System.String,System.Func{System.Boolean})">
            <inheritdoc cref="M:Sandbox.UI.Panel.BindClass(System.String,System.Func{System.Boolean})"/>
        </member>
        <member name="M:Sandbox.PanelComponent.SetClass(System.String,System.Boolean)">
            <inheritdoc cref="M:Sandbox.UI.Panel.SetClass(System.String,System.Boolean)"/>
        </member>
        <member name="P:Sandbox.PanelComponent.Panel">
            <summary>
            The panel. Can be null if the panel doesn't exist yet.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder)">
            <summary>
            Gets overridden by .razor file
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.GetRenderTreeChecksum">
            <summary>
            Gets overridden by .razor file
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.OnTreeFirstBuilt">
            <summary>
            Called when the razor ui has been built.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.OnTreeBuilt">
            <summary>
            Called after the tree has been built. This can happen any time the contents change.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.BuildHash">
            <summary>
            When this has changes, we will re-render this panel. This is usually
            implemented as a HashCode.Combine containing stuff that causes the
            panel's content to change.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.StateHasChanged">
            <summary>
            Should be called when you want the component to be re-rendered.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.OnMouseDown(Sandbox.UI.MousePanelEvent)">
            <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseDown(Sandbox.UI.MousePanelEvent)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.OnMouseMove(Sandbox.UI.MousePanelEvent)">
            <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseMove(Sandbox.UI.MousePanelEvent)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.OnMouseUp(Sandbox.UI.MousePanelEvent)">
            <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseUp(Sandbox.UI.MousePanelEvent)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.OnMouseOut(Sandbox.UI.MousePanelEvent)">
            <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseOut(Sandbox.UI.MousePanelEvent)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.OnMouseOver(Sandbox.UI.MousePanelEvent)">
            <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseOver(Sandbox.UI.MousePanelEvent)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.OnMouseWheel(Vector2)">
            <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseWheel(Vector2)"/>
        </member>
        <member name="T:Sandbox.CustomBuildPanel">
            <summary>
            A panel where we control the tree build.
            </summary>
        </member>
        <member name="T:Sandbox.ScreenPanel">
            <summary>
            Renders any attached PanelComponents to the screen. Acts as the root for all your UI components.
            </summary>
        </member>
        <member name="F:Sandbox.ScreenPanel.AutoScale.ConsistentHeight">
            <summary>
            The height is scaled on the assumptiuon that we're always 1080p
            </summary>
        </member>
        <member name="F:Sandbox.ScreenPanel.AutoScale.FollowDesktopScaling">
            <summary>
            We use the same scaling as the desktop
            </summary>
        </member>
        <member name="T:Sandbox.WorldInput">
            <summary>
            A router for world input, the best place to put this is on your player's camera.
            Uses cursor ray when mouse is active, otherwise the direction of this gameobject.
            </summary>
        </member>
        <member name="P:Sandbox.WorldInput.LeftMouseAction">
            <summary>
            Which action is our left clicking button?
            </summary>
        </member>
        <member name="P:Sandbox.WorldInput.RightMouseAction">
            <summary>
            Which action is our right clicking button?
            </summary>
        </member>
        <member name="P:Sandbox.WorldInput.Hovered">
            <summary>
            The <see cref="T:Sandbox.UI.Panel"/> that is currently hovered by this input.
            </summary>
        </member>
        <member name="T:Sandbox.WorldPanel">
            <summary>
            Renders any attached PanelComponents to the world in 3D space.
            </summary>
        </member>
        <member name="P:Sandbox.WorldPanel.InteractionRange">
            <summary>
            How far can we interact with this world panel?
            </summary>
        </member>
        <member name="M:Sandbox.WorldPanel.OnTagsChanged">
            <summary>
            Tags have been updated
            </summary>
        </member>
        <member name="T:Sandbox.Volumes.SceneVolume">
            <summary>
            A generic way to represent volumes in a scene. If we all end up using this instead of defining our own version
            in everything, we can improve this and improve everything at the same time.
            </summary>
        </member>
        <member name="F:Sandbox.Volumes.SceneVolume.VolumeTypes.Sphere">
            <summary>
            A sphere. It's like the earth. Or an eyeball.
            </summary>
        </member>
        <member name="F:Sandbox.Volumes.SceneVolume.VolumeTypes.Box">
            <summary>
            A box, like a cube.
            </summary>
        </member>
        <member name="M:Sandbox.Volumes.SceneVolume.DrawGizmos(System.Boolean)">
            <summary>
            Draws an editable sphere/box gizmo, for adjusting the volume
            </summary>
        </member>
        <member name="M:Sandbox.Volumes.SceneVolume.Test(Transform@,Vector3@)">
            <summary>
            Is this point within the volume
            </summary>
        </member>
        <member name="M:Sandbox.Volumes.SceneVolume.Test(Transform@,BBox@)">
            <summary>
            Is this point within the volume
            </summary>
        </member>
        <member name="M:Sandbox.Volumes.SceneVolume.Test(Transform@,Sandbox.Sphere@)">
            <summary>
            Is this point within the volume
            </summary>
        </member>
        <member name="M:Sandbox.Volumes.SceneVolume.Test(Vector3@)">
            <summary>
            Is this point within the (local space) volume
            </summary>
        </member>
        <member name="M:Sandbox.Volumes.SceneVolume.GetVolume">
            <summary>
            Get the actual amount of volume in this shape. This is useful if you want to make
            a system where you prioritize by volume size. Don't forget to multiply by scale!
            </summary>
        </member>
        <member name="T:Sandbox.Volumes.VolumeSystem">
            <summary>
            A base GameObjectSystem for handling of IVolume components. You can use this to find volume components
            by position.
            </summary>
        </member>
        <member name="M:Sandbox.Volumes.VolumeSystem.FindSingle``1(Vector3)">
            <summary>
            Find a volume of this type, at this point. Will return null if none.
            </summary>
        </member>
        <member name="M:Sandbox.Volumes.VolumeSystem.FindAll``1(Vector3)">
            <summary>
            Find all volumes of this type, at this point
            </summary>
        </member>
        <member name="T:Sandbox.DamageInfo">
            <summary>
            Describes the damage that should be done to something. This is purposefully a class
            so it can be derived from, allowing games to create their own special types of damage, while
            not having to create a whole new system.
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Attacker">
            <summary>
            Usually a player or Npc
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Weapon">
            <summary>
            The weapon that did the damage, or a vehicle etc
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Hitbox">
            <summary>
            The hitbox that we hit (if any)
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Damage">
            <summary>
            Amount of damage this should do
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Origin">
            <summary>
            The origin of the damage. For bullets this would be the shooter's eye position. For explosions, this would be the center of the exposion.
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Position">
            <summary>
            The location of the damage on the hit object.
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Shape">
            <summary>
            The physics shape that we hit (if any)
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Tags">
            <summary>
            Tags for this damage, allows you to enter and read different damage types etc
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.IsExplosion">
            <summary>
            True if this is explosive damage
            </summary>
        </member>
        <member name="T:Sandbox.IGameObjectNetworkEvents">
            <summary>
            Allows listening to network events on a specific GameObject
            </summary>
        </member>
        <member name="M:Sandbox.IGameObjectNetworkEvents.NetworkOwnerChanged(Sandbox.Connection,Sandbox.Connection)">
            <summary>
            Called when the owner of a network GameObject is changed
            </summary>
        </member>
        <member name="M:Sandbox.IGameObjectNetworkEvents.StartControl">
            <summary>
            We have become the controller of this object, we are no longer a proxy
            </summary>
        </member>
        <member name="M:Sandbox.IGameObjectNetworkEvents.StopControl">
            <summary>
            This object has become a proxy, controlled by someone else
            </summary>
        </member>
        <member name="T:Sandbox.ISceneCollisionEvents">
            <summary>
            Listen to all collision events that happen during a physics step.
            </summary>
        </member>
        <member name="M:Sandbox.ISceneCollisionEvents.OnCollisionStart(Sandbox.Collision)">
            <summary>
            Called when a collider/rigidbody starts touching another collider.
            </summary>
        </member>
        <member name="M:Sandbox.ISceneCollisionEvents.OnCollisionUpdate(Sandbox.Collision)">
            <summary>
            Called once per physics step for every collider being touched.
            </summary>
        </member>
        <member name="M:Sandbox.ISceneCollisionEvents.OnCollisionStop(Sandbox.CollisionStop)">
            <summary>
            Called when a collider/rigidbody stops touching another collider.
            </summary>
        </member>
        <member name="M:Sandbox.ISceneCollisionEvents.OnCollisionHit(Sandbox.Collision)">
            <summary>
            Called when a collider/rigidbody hits another collider, including repeated hits
            on the same shape while they are already touching.
            </summary>
        </member>
        <member name="T:Sandbox.ISceneLoadingEvents">
            <summary>
            Allows listening to events related to scene loading
            </summary>
        </member>
        <member name="M:Sandbox.ISceneLoadingEvents.BeforeLoad(Sandbox.Scene,Sandbox.SceneLoadOptions)">
            <summary>
            Called before the loading starts
            </summary>
        </member>
        <member name="M:Sandbox.ISceneLoadingEvents.OnLoad(Sandbox.Scene,Sandbox.SceneLoadOptions)">
            <summary>
            Called during loading. The game will wait for your task to finish
            </summary>
        </member>
        <member name="M:Sandbox.ISceneLoadingEvents.AfterLoad(Sandbox.Scene)">
            <summary>
            Loading has finished
            </summary>
        </member>
        <member name="T:Sandbox.IScenePhysicsEvents">
            <summary>
            Allows events before and after the the physics step
            </summary>
        </member>
        <member name="M:Sandbox.IScenePhysicsEvents.PrePhysicsStep">
            <summary>
            Called before the physics step is run. This is called pretty much
            right after FixedUpdate.
            </summary>
        </member>
        <member name="M:Sandbox.IScenePhysicsEvents.PostPhysicsStep">
            <summary>
            Called after the physics step is run
            </summary>
        </member>
        <member name="T:Sandbox.ISceneStartup">
            <summary>
            Allows listening to events related to scene startup. This should really only apply to GameObjectSystem's
            because components won't have been spawned/created when most of this is invoked.
            </summary>
        </member>
        <member name="M:Sandbox.ISceneStartup.OnHostPreInitialize(Sandbox.SceneFile)">
            <summary>
            Called before the scene is loaded. In game only, on host only.
            </summary>
        </member>
        <member name="M:Sandbox.ISceneStartup.OnHostInitialize">
            <summary>
            Called after the scene is loaded. In game only, on the host only.
            </summary>
        </member>
        <member name="M:Sandbox.ISceneStartup.OnClientInitialize">
            <summary>
            Called in game after the client has loaded the initial scene from the server, or after OnHostInitialize. 
            This is not called on the dedicated server.
            </summary>
        </member>
        <member name="T:Sandbox.CollisionSoundSystem">
            <summary>
            This system exists to collect pending collision sounds and filter them into a unique set, to avoid
            unnesssary sounds playing, when they're going to be making the same sound anyway.
            </summary>
        </member>
        <member name="M:Sandbox.CollisionSoundSystem.RegisterCollision(Sandbox.Collision@)">
            <summary>
            Register this physics collision with the sound system
            </summary>
        </member>
        <member name="M:Sandbox.CollisionSoundSystem.AddShapeCollision(Sandbox.PhysicsShape,Sandbox.Surface,Vector3@,System.Single,System.Boolean)">
            <summary>
            Add a collision sound for this shape
            </summary>
        </member>
        <member name="M:Sandbox.CollisionSoundSystem.ProcessQueue">
            <summary>
            Create the pending sounds
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Capsule(Capsule,Color,System.Single,Transform,System.Boolean,System.Int32)">
            <summary>
            Draw a wireframe capsule, simple cylinder with 2 hemispheres.
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Cylinder(Capsule,Color,System.Single,Transform,System.Boolean,System.Int32)">
            <summary>
            Draw a wireframe cylinder, like a capsule without the hemispheres, showing all sides.
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Box(Vector3,Vector3,Color,System.Single,Transform,System.Boolean)">
            <summary>
            Draw a box
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Box(BBox,Color,System.Single,Transform,System.Boolean)">
            <summary>
            Draw a box
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.GameObject(Sandbox.GameObject,Color,System.Single,Transform,System.Boolean,System.Boolean,Sandbox.Material)">
            <summary>
            Draw a GameObject in the world
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Normal(Vector3,Vector3,Color,System.Single,Transform,System.Boolean)">
            <summary>
            Draw a line 
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Line(Line,Color,System.Single,Transform,System.Boolean)">
            <summary>
            Draw a line 
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Line(Vector3,Vector3,Color,System.Single,Transform,System.Boolean)">
            <summary>
            Draw a line 
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Line(System.Collections.Generic.IEnumerable{Vector3},Color,System.Single,Transform,System.Boolean)">
            <summary>
            Draw a line 
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Model(Sandbox.Model,Color,System.Single,Transform,System.Boolean,System.Boolean,Sandbox.Material,Transform[])">
            <summary>
            Draw model in the world
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Sphere(Sandbox.Sphere,Color,System.Single,Transform,System.Boolean)">
            <summary>
            Draw a sphere
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Text(Vector3,System.String,System.Single,Sandbox.TextFlag,Color,System.Single,System.Boolean)">
            <summary>
            Draw text in the world
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Text(Vector3,Sandbox.TextRendering.Scope,Sandbox.TextFlag,System.Single,System.Boolean)">
            <summary>
            Draw text in the world
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Frustum(Sandbox.Frustum,Color,System.Single,Transform,System.Boolean)">
            <summary>
            Draw a frustum
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Add(System.Single,Sandbox.SceneObject)">
            <summary>
            Add an entry manually
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.ScreenText(Vector2,System.String,System.Single,Sandbox.TextFlag,Color,System.Single)">
            <summary>
            Draw text on the screen
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.ScreenText(Vector2,Sandbox.TextRendering.Scope,Sandbox.TextFlag,System.Single)">
            <summary>
            Draw text on the screen
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Texture(Sandbox.Texture,Vector2,System.Nullable{Color},System.Single)">
            <summary>
            Draw a texture on the screen
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Texture(Sandbox.Texture,Sandbox.Rect,System.Nullable{Color},System.Single)">
            <summary>
            Draw a texture on the screen
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlaySystem.Trace(Sandbox.SceneTraceResult,System.Single,System.Boolean)">
            <summary>
            Draws the result of a physics trace, showing the start and end points, the hit location and normal (if any),
            and the traced shape (ray, sphere, box, capsule, cylinder) at both the start and end positions.
            </summary>
        </member>
        <member name="F:Sandbox.DecalGameSystem._transients">
            <summary>
            A list of decals that can be destroyed after a certain time.
            </summary>
        </member>
        <member name="T:Sandbox.HitboxSystem">
            <summary>
            Ticks the physics in FrameStage.PhysicsStep
            </summary>
        </member>
        <member name="T:Sandbox.InterpolationSystem">
            <summary>
            Updates interpolation for any <see cref="T:Sandbox.GameTransform"/> that needs it.
            </summary>
        </member>
        <member name="M:Sandbox.InterpolationSystem.AddGameObject(Sandbox.GameObject)">
            <summary>
            Add a <see cref="T:Sandbox.GameObject"/> to the interpolation list.
            </summary>
        </member>
        <member name="M:Sandbox.InterpolationSystem.RemoveGameObject(Sandbox.GameObject)">
            <summary>
            Remove a <see cref="T:Sandbox.GameObject"/> from the interpolation list.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkDebugSystem.Track``1(System.String,``0)">
            <summary>
            Track an incoming message so that we can gather data about how frequently it is called
            and the size of the messages.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkDebugSystem.Record``1(Sandbox.NetworkDebugSystem.MessageType,``0)">
            <summary>
            Record the size of a message by category to be added to the current tick sample. These
            can be shown on a network graph.
            </summary>
        </member>
        <member name="T:Sandbox.ScenePhysicsSystem">
            <summary>
            Ticks the physics in FrameStage.PhysicsStep
            </summary>
        </member>
        <member name="T:Sandbox.SceneSoundscapeSystem">
            <summary>
            Implements logic for the SoundScape system
            </summary>
        </member>
        <member name="M:Sandbox.SceneSpriteSystem.FindCurrentRenderGroup(System.Guid)">
            <summary>
            Find the component's current render group - might be outdated if component has changed.
            Returns null if not present in any
            </summary>
        </member>
        <member name="T:Sandbox.SceneSpriteSystem.RenderGroupKey">
            <summary>
            A key that defines a render group used in SceneSpriteSystem. Each permutation of this object represent a different sprite batch.
            </summary>
        </member>
        <member name="M:Sandbox.SceneSpriteSystem.RenderGroupKey.#ctor(Sandbox.SceneSpriteSystem.InstanceGroupFlags,System.Collections.Generic.HashSet{System.String},Sandbox.RenderOptions)">
            <summary>
            A key that defines a render group used in SceneSpriteSystem. Each permutation of this object represent a different sprite batch.
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectSystem">
            <summary>
            Allows creation of a system that always exists in every scene, is hooked into the scene's lifecycle, 
            and is disposed when the scene is disposed.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectSystem.Listen(Sandbox.GameObjectSystem.Stage,System.Int32,System.Action,System.String)">
            <summary>
            Listen to a frame stage. Order is used to determine the order in which listeners are called, the default action always happens at 0, so if you
            want it to happen before you should go to -1, if you want it to happen after go to 1 etc.
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectSystem.Stage">
            <summary>
            A list of stages in the scene tick in which we can hook
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.StartUpdate">
            <summary>
            At the very start of the scene update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.UpdateBones">
            <summary>
            Bones are worked out
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.PhysicsStep">
            <summary>
            Physics step, called in fixed update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.Interpolation">
            <summary>
            When transforms are interpolated
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.FinishUpdate">
            <summary>
            At the very end of the scene update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.StartFixedUpdate">
            <summary>
            Called at the start of fixed update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.FinishFixedUpdate">
            <summary>
            Called at the end of fixed update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.SceneLoaded">
            <summary>
            Called after a scene has been loaded
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectSystem.ITraceProvider">
            <summary>
            When implementing an ITraceProvider, the most importannt thing to keep in mind 
            is that the call to DoTrace should be thread safe. This might be called from 
            multiple threads at once, so you better watch out.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectSystem.ForceChangeId(System.Guid)">
            <summary>
            Should only be called by <see cref="M:Sandbox.GameObjectDirectory.Add(Sandbox.GameObjectSystem)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectSystem.GetOrCreateInterpolatedVar``1(``0,System.String)">
            <summary>
            Get or create a new interpolated variable. This will set the current interpolated value to the
            provided one if it hasn't been created yet.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectSystem.Sandbox#IDeltaSnapshot#WriteDeltaSnapshot(Sandbox.DeltaSnapshot)">
            <summary>
            Write delta snapshot data to the specified <see cref="T:Sandbox.DeltaSnapshot"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectSystem.Sandbox#IDeltaSnapshot#SendNetworkUpdate">
            <summary>
            Try to send a network update or do nothing if no update is required. This is most
            likely called after WriteDeltaSnapshot.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectSystem.WriteDataTable(System.Boolean)">
            <summary>
            Write all pending data table changes.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectSystem.ReadDataTable(System.Byte[],Sandbox.NetworkTable.ReadFilter)">
            <summary>
            Read the network table data.
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectSystem`1">
            <summary>
            A syntax sugar wrapper around GameObjectSystem, which allows you to access your system using
            SystemName.Current instead of Scene.GetSystem.
            </summary>
        </member>
        <member name="T:Sandbox.TimedCallbackList">
            <summary>
            Keeps a list of callbacks
            The intention of this is that in the future we'll have a nice window that will
            show the relative performance of each callback, and allow you to disable them to debug.
            </summary>
        </member>
        <member name="T:Sandbox.CallbackBatch">
            <summary>
            We want to execute callbacks in a predictable order. This happens
            naturally when spawning one GameObject, but when spawning a scene, or a 
            prefab, we want to hold the calls to things like OnEnable and call them all
            after OnStart or whatever has been called on all the objects in the batch.
            </summary>
        </member>
        <member name="M:Sandbox.CallbackBatch.Batch(System.String)">
            <summary>
            Add callbacks to the previous batch (or create one). This allows for one single batch, the
            most outer one, and won't create a new batch for inner ones. This is used when doing things like
            deserializing a map, so all the OnEnable etc are executed at the same time, and in the right order.
            </summary>
        </member>
        <member name="M:Sandbox.CallbackBatch.Isolated(System.String)">
            <summary>
            Collect callbacks in this scope and execute them immediately at the end of this batch. This is used
            for things like gameobject Clones, where we're going to want access to the object straight after 
            creating it.. and if we're inside a Batch then OnEnable etc won't have been called, so it will be
            confusing to everyone.
            </summary>
        </member>
        <member name="T:Sandbox.CommonCallback">
            <summary>
            A list of component methods that are deferred and batched into groups, and exected in group order.
            This is used to ensure that components are initialized in a predictable order.
            The order of this enum is critical.
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Deserialize">
            <summary>
            The component is deserializing.
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Validate">
            <summary>
            The component has been deserialized, or edited in the editor
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Loading">
            <summary>
            An opportunity for the component to load any data they need to load
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Awake">
            <summary>
            The component is awake. Called only once, on first enable.
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Enable">
            <summary>
            Component has been enabled
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Dirty">
            <summary>
            The component has become dirty, usually due to a property changing
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Disable">
            <summary>
            Component has been disabled
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Destroy">
            <summary>
            Component has been destroyed
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Term">
            <summary>
            GameObject actually deleted
            </summary>
        </member>
        <member name="T:Sandbox.FindMode">
            <summary>
            Flags to search for Components.
            I've named this something generic because I think we can re-use it to search for GameObjects too.
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.Enabled">
            <summary>
            Components that are enabled
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.Disabled">
            <summary>
            Components that are disabled
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InSelf">
            <summary>
            Components in this object
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InParent">
            <summary>
            Components in our parent
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InAncestors">
            <summary>
            Components in all ancestors (parent, their parent, their parent, etc)
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InChildren">
            <summary>
            Components in our children
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InDescendants">
            <summary>
            Components in all decendants (our children, their children, their children etc)
            </summary>
        </member>
        <member name="F:Sandbox.ComponentList._list">
            <summary>
            This is the hard list of components.
            This isn't a HashSet because we need the order to stay.
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetAll">
            <summary>
            Get all components, including disabled ones
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.OnHotload">
            <summary>
            Hotload has occurred
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Create(Sandbox.TypeDescription,System.Boolean)">
            <summary>
            Add a component of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Create``1(System.Boolean)">
            <summary>
            Add a component of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Create(System.Type,System.Boolean)">
            <summary>
            Add a component of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Get``1(Sandbox.FindMode)">
            <summary>
            Get a component of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Get(System.Type,Sandbox.FindMode)">
            <summary>
            Get a component of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetAll(System.Type,Sandbox.FindMode)">
            <summary>
            Get all components of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetAll(Sandbox.FindMode)">
            <summary>
            Get all components
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetAll``1(Sandbox.FindMode)">
            <summary>
            Get a list of components on this game object, optionally recurse when deep is true
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.TryGet``1(``0@,Sandbox.FindMode)">
            <summary>
            Try to get this component
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.FirstOrDefault(System.Func{Sandbox.Component,System.Boolean})">
            <summary>
            Allows linq style queries
            </summary>
        </member>
        <member name="P:Sandbox.ComponentList.Count">
            <summary>
            Amount of components - including disabled
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Move(Sandbox.Component,System.Int32)">
            <summary>
            Move the position of the component in the list by delta (-1 means up one, 1 means down one)
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.MoveToIndex(Sandbox.Component,System.Int32)">
            <summary>
            Move the component to a specific index in the list.
            If a component is already at that index, it will be swapped with the component being moved.
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Get``1(System.Boolean)">
            <summary>
            Find component on this gameobject
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetOrCreate``1(Sandbox.FindMode)">
            <summary>
            Find this component, if it doesn't exist - create it.
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInAncestorsOrSelf``1(System.Boolean)">
            <summary>
            Find component on this gameobject's ancestors or on self
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInAncestors``1(System.Boolean)">
            <summary>
            Find component on this gameobject's ancestors
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInDescendantsOrSelf``1(System.Boolean)">
            <summary>
            Find component on this gameobject's decendants or on self
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInDescendants``1(System.Boolean)">
            <summary>
            Find component on this gameobject's decendants
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInChildrenOrSelf``1(System.Boolean)">
            <summary>
            Find component on this gameobject's immediate children or on self
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInChildren``1(System.Boolean)">
            <summary>
            Find component on this gameobject's immediate children
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInParentOrSelf``1(System.Boolean)">
            <summary>
            Find component on this gameobject's parent or on self
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInParent``1(System.Boolean)">
            <summary>
            Find component on this gameobject's parent
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Get(System.Guid)">
            <summary>
            Find component on this gameobject with the specified id
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.AddMissing(Sandbox.MissingComponent)">
            <summary>
            Adds a special component that will keep information about a missing component.
            This component just holds the raw json of this component.
            </summary>
        </member>
        <member name="T:Sandbox.IComponentLister">
            <summary>
            Interface for types that reference a <see cref="T:Sandbox.ComponentList"/>, to provide
            convenience method for accessing that list.
            </summary>
        </member>
        <member name="T:Sandbox.GameObject">
            <summary>
            An object in the scene. Functionality is added using Components. A GameObject has a transform, which explains its position,
            rotation and scale, relative to its parent. It also has a name, and can be enabled or disabled. When disabled, the GameObject
            is still in the scene, but the components don't tick and are all disabled.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Sandbox.CloneConfig@)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.PostClone(System.Collections.Generic.Dictionary{System.Object,System.Object},System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
            <summary>
            Runs after this clone has been created by a cloned GameObject.
            </summary>
            <param name="originalToClonedObject">A mapping of original objects to their clones, used for all reference types.</param>
            <param name="originalIdToCloneId">A mapping of original GUIDs to cloned GUIDs, used for GameObject and Component references in JSON.</param>
        </member>
        <member name="M:Sandbox.GameObject.Clone(System.String,System.Nullable{Sandbox.CloneConfig})">
            <summary>
            Clone a prefab from path
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(System.String,Transform,Sandbox.GameObject,System.Boolean,System.String)">
            <summary>
            Clone a prefab from path
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Sandbox.PrefabFile,System.Nullable{Sandbox.CloneConfig})">
            <summary>
            Clone a prefab from path
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Sandbox.PrefabFile,Transform,Sandbox.GameObject,System.Boolean,System.String)">
            <summary>
            Clone a prefab from path
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Transform,Sandbox.GameObject,System.Boolean,System.String)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Vector3)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Vector3,Rotation)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Vector3,Rotation,Vector3)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Sandbox.GameObject,Vector3,Rotation,Vector3)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Scene">
            <summary>
            The scene that this GameObject is in.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Transform">
            <summary>
            Our position relative to our parent, or the scene if we don't have any parent.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Name">
            <summary>
            The GameObject's name is usually used for debugging, and for finding it in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsRoot">
            <summary>
            Returns true of this is a root object. Root objects are parented to the scene.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Root">
            <summary>
            Return the root GameObject. The root is the object that is parented to the scene - which could very much be this object.
            </summary>
        </member>
        <member name="F:Sandbox.GameObject.enabledTokenSource">
            <summary>
            This token source is expired when leaving the game session, or when the GameObject is disabled/destroyed.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.EnabledToken">
            <summary>
            This token is cancelled when the GameObject ceases to exist, or is disabled
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Components">
            <summary>
            Access components on this GameObject
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Enabled">
            <summary>
            Is this gameobject enabled?
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.#ctor(System.String)">
            <summary>
            Create a new GameObject with the given name. Will be created enabled.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.#ctor(System.Boolean,System.String)">
            <summary>
            Create a new GameObject with the given enabled state and name.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.#ctor(Sandbox.GameObject,System.Boolean,System.String)">
            <summary>
            Create a new GameObject with the given parent, enabled state and name.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.CreateTaskSource">
            <summary>
            Creates a new task source. Any Waits etc created by Task will be cancelled
            when the GameObject is disabled, or destroyed, or the game is exited.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.CancelTaskSource">
            <summary>
            Cancel this task source
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Active">
            <summary>
            Is this gameobject active. For it to be active, it needs to be enabled, all of its ancestors
            need to be enabled, and it needs to be in a scene.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.ForEachChildFast``1(System.String,System.Boolean,,``0@)">
            <summary>
            Like the above, but faster, no allocations
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.UpdateEnabledStatus">
            <summary>
            Should be called whenever we change anything that we suspect might
            cause the active status to change on us, or our components. Don't call
            this directly. Only call it via SceneUtility.ActivateGameObject( this );
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.IsDescendant(Sandbox.GameObject)">
            <summary>
            Returns true if the passed in object is a decendant of ours
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.IsAncestor(Sandbox.GameObject)">
            <summary>
            Returns true if the passed in object is an ancestor
            </summary>
        </member>
        <member name="F:Sandbox.GameObject._humanReadableId">
            <summary>
            The human readable ID is the number in parentheses at the end of the name. (If it exists)
            There is no guarantee that this is unique, or sequential.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetBounds">
            <summary>
            This is slow, and somewhat innacurate. Don't call it every frame!
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetLocalBounds">
            <summary>
            This is slow, and somewhat innacurate. Don't call it every frame!
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetNextSibling(System.Boolean)">
            <summary>
            Get the GameObject after us,
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.OnHotload">
            <summary>
            Internal stuff only
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.DebugOverlay">
            <summary>
            Allows drawing of temporary debug shapes and text in the scene
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsValid">
            <summary>
            True if the GameObject is not destroyed
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Term">
            <summary>
            Actually destroy the object and its children. Turn off and destroy components.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.OnParentBeingDestroyed">
            <summary>
            Called on a child GameObject when its parent is being destroyed
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.TermSilent">
            <summary>
            Destroy the object and its children and destroy any components without
            invoking any callbacks.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.TermFinal">
            <summary>
            The last thing ever called.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Destroy">
            <summary>
            Destroy this object. Will actually be destroyed at the start of the next frame.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsDestroyed">
            <summary>
            Return true if this object is destroyed. This will also return true if the object is marked to be destroyed soon.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.DestroyImmediate">
            <summary>
            Destroy this object immediately. Calling this might cause some problems if functions
            are expecting the object to still exist, so it's not always a good idea.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.RemoveChild(Sandbox.GameObject)">
            <summary>
            Remove all children
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Sandbox.GameObject.Clear">
            <summary>
            Destroy all components and child objects
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.ShouldSurviveSceneTransition">
            <summary>
            True if this GameObject should survive a scene load
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clear(System.Boolean)">
            <summary>
            Destroy all components and child objects
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.RunEvent``1(System.Action{``0},Sandbox.FindMode)">
            <summary>
            Post event to a specific GameObject (and its descendants by default - you can specify a <see cref="T:Sandbox.FindMode"/> to control this)
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsDeserializing">
            <summary>
            True if this GameObject is being deserialized right now
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.HasFlagOrParent(Sandbox.GameObjectFlags)">
            <summary>
            Do we or our ancestor have this flag
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.AddComponent``1(System.Boolean)">
            <summary>
            Add a component to this GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetOrAddComponent``1(System.Boolean)">
            <summary>
            Add a component to this GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetComponent``1(System.Boolean)">
            <summary>
            Get a component on this GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetComponents``1(System.Boolean)">
            <summary>
            Get components on this GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetComponentsInChildren``1(System.Boolean,System.Boolean)">
            <summary>
            Get components on this GameObject and on descendant GameObjects
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetComponentInChildren``1(System.Boolean,System.Boolean)">
            <summary>
            Get component on this GameObject or on descendant GameObjects
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetComponentsInParent``1(System.Boolean,System.Boolean)">
            <summary>
            Get components on this GameObject and on ancestor GameObjects
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetComponentInParent``1(System.Boolean,System.Boolean)">
            <summary>
            Get component on this GameObject and on ancestor GameObjects
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.FindSelectionBase">
            <summary>
            Finds the first GameObject in the ancestor chain that we consider a selection base.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.ForceChangeId(System.Guid)">
            <summary>
            Should only be called by <see cref="M:Sandbox.GameObjectDirectory.Add(Sandbox.GameObject)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.SetDeterministicId(System.Guid)">
            <summary>
            Allows overriding the ID of this object. This should be used sparingly, and only when necessary.
            This is generally used for network reasons, to make something deterministic.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.LocalTransform">
            <summary>
            The local transform of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.LocalPosition">
            <summary>
            The local position of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.LocalRotation">
            <summary>
            The local rotation of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.LocalScale">
            <summary>
            The local scale of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsProxy">
            <summary>
            True if this is a networked object and is owned by another client. This means that we're
            not controlling this object, so shouldn't try to move it or anything.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsNetworkRoot">
            <summary>
            If true then this object is the root of a networked object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Networked">
            <summary>
            OBSOLETE: Use NetworkMode instead.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkMode">
            <summary>
            How should this object be networked to other clients? By default, a <see cref="T:Sandbox.GameObject"/> will be
            networked as part of the <see cref="P:Sandbox.GameObject.Scene"/> snapshot.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.OwnerTransfer">
            <summary>
            If this object is networked, who can control ownership of it? This property will only
            be synchronized for a root network object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkOrphaned">
            <summary>
            Determines what happens when the owner disconnects. This property will only
            be synchronized for a root network object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkInterpolation">
            <summary>
            Whether or not our networked transform will be interpolated. This property will only
            be synchronized for a root network object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawn">
            <summary>
            Spawn on the network. If you have permission to spawn entities, this will spawn on
            everyone else's clients and you will be the owner.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawn(Sandbox.NetworkSpawnOptions)">
            <summary>
            Spawn on the network with the specified options. If you have permission to spawn
            entities, this will spawn on everyone else's clients.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawn(System.Boolean,Sandbox.Connection)">
            <summary>
            Spawn on the network. If you have permission to spawn entities, this will spawn on
            everyone else's clients and the owner will be the connection provided.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawn(Sandbox.Connection)">
            <summary>
            Spawn on the network. If you have permission to spawn entities, this will spawn on
            everyone else's clients and the owner will be the connection provided.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawnRemote(Sandbox.ObjectCreateMsg)">
            <summary>
            Initialize this object from the network
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_RequestDropOwnership">
            <summary>
            Make a request from the host to stop being the network owner of this game object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_DropOwnership">
            <summary>
            Stop being the network owner of this game object, or clear ownership if you're the host.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_RequestTakeOwnership">
            <summary>
            Make a request from the host to become the network owner of this game object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_TakeOwnership">
            <summary>
            Become the network owner of this game object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_RequestAssignOwnership(System.Guid)">
            <summary>
            Make a request from the host to assign ownership of this game object to the specified connection <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_AssignOwnership(System.Guid)">
            <summary>
            Assign ownership of this game object to the specified connection <see cref="T:System.Guid"/>.
            </summary>
            <param name="guid"></param>
        </member>
        <member name="P:Sandbox.GameObject.NetworkRoot">
            <summary>
            The network root is the first networked GameObject above this.
            This gets set from the parent's NetworkSpawn and invalidated when the parent changes.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkRefresh(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Update hierarchy from a network refresh.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawnRecursive(Sandbox.Connection)">
            <summary>
            Loop all of our children, and any with networking enabled, we should spawn them
            with the same creator + owner as this.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Network">
            <summary>
            Access network information for this GameObject.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.Active">
            <summary>
            Is this object networked
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.RootGameObject">
            <summary>
            Get the GameObject that is the root of this network object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.IsOwner">
            <summary>
            Are we the owner of this network object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.OwnerId">
            <summary>
            The Id of the owner of this object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.IsCreator">
            <summary>
            Are we the creator of this network object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.CreatorId">
            <summary>
            The Id of the create of this object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.IsProxy">
            <summary>
            Is this object a network proxy. A network proxy is a network object that is not being simulated on the local pc.
            This means it's either owned by no-one and is being simulated by the host, or owned by another client.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.OwnerConnection">
            <summary>
            Try to get the connection that owns this object. This can and will return null
            if we don't have information for this connection.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.Owner">
            <summary>
            Try to get the connection that owns this object. This can and will return null
            if we don't have information for this connection.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer">
            <summary>
            Who can control ownership of this networked object?
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.NetworkOrphaned">
            <summary>
            Determines what happens when the owner disconnects.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.Interpolation">
            <summary>
            Whether the networked object's transform is interpolated.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.EnableInterpolation">
            <summary>
            Enable interpolation for the networked object's transform.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.DisableInterpolation">
            <summary>
            Disable interpolation for the networked object's transform.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.ClearInterpolation">
            <summary>
            <inheritdoc cref="M:Sandbox.GameTransform.ClearInterpolation"/>
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.SetOrphanedMode(Sandbox.NetworkOrphaned)">
            <summary>
            Set what happens to this networked object when the owner disconnects.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.SetOwnerTransfer(Sandbox.OwnerTransfer)">
            <summary>
            Set who can control ownership of this networked object. Only the current owner can change this.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.Refresh">
            <summary>
            Send a complete refresh snapshot of this networked object to other clients. This is useful if you have
            made vast changes to components or children.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.Refresh(Sandbox.GameObject)">
            <summary>
            Send a refresh for a specific <see cref="T:Sandbox.GameObject"/> in the hierarchy of this networked object to other clients.
            This is useful if you've destroyed or added a new <see cref="T:Sandbox.GameObject"/> descendent and don't want to refresh
            the entire networked object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.Refresh(Sandbox.Component)">
            <summary>
            Send a refresh for a specific <see cref="T:Sandbox.Component"/> in the hierarchy of this networked object to other clients.
            This is useful if you've destroyed or added a new <see cref="T:Sandbox.Component"/> and don't want to refresh the entire object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.TakeOwnership">
            <summary>
            Become the network owner of this object.
            <br/>
            <br/>
            Note: whether or not you can take ownership of this object depends on the
            <see cref="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer"/> of this networked object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.AssignOwnership(Sandbox.Connection)">
            <summary>
            Set the owner of this object to the specified <see cref="T:Sandbox.Connection"/>.
            <br/>
            <br/>
            Note: whether or not you can assign ownership of this object depends on the
            <see cref="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer"/> of this networked object.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="channel"/> cannot be null. To clear owner, use <see cref="M:Sandbox.GameObject.NetworkAccessor.DropOwnership"/> instead.</exception>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.AssignOwnership(System.Guid)">
            <summary>
            Assign ownership to the specific connection id. This should only be used internally
            when we want to force an ownership change, such as for a <see cref="P:Sandbox.GameObject.NetworkAccessor.NetworkOrphaned"/> action.
            </summary>
            <param name="connectionId"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.DropOwnership">
            <summary>
            Stop being the owner of this object. Will clear the owner so the object becomes
            controlled by the server, and owned by no-one.
            <br/>
            <br/>
            Note: whether or not you can drop ownership of this object depends on the
            <see cref="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer"/> of this networked object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.Spawn">
            <summary>
            <inheritdoc cref="M:Sandbox.GameObject.NetworkSpawn"/>
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.Spawn(Sandbox.Connection)">
            <summary>
            <inheritdoc cref="M:Sandbox.GameObject.NetworkSpawn(Sandbox.Connection)"/>
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.BreakFromPrefab">
            <summary>
            We are cloned from a prefab. Stop that.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetPrefab(System.String)">
            <summary>
            Get the GameObject of a prefab from file path
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsPrefabInstance">
            <summary>
            This GameObject is part of a prefab instance.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsPrefabInstanceRoot">
            <summary>
            This GameObject is the root of a prefab instance.
            Returns true for regular instance roots and nested prefab instance roots.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.PrefabInstanceRoot">
            <summary>
            Get the root of the prefab instance this GameObject is part of.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.OutermostPrefabInstanceRoot">
            <summary>
            Get the outermost prefab instance root of this GameObject.
            This is the root of the prefab instance this GameObject is part of, or the root of the prefab instance this GameObject is nested in.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsOutermostPrefabInstanceRoot">
            <summary>
            This GameObject is the root of a prefab instance and is not nested inside another prefab instance.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsNestedPrefabInstanceRoot">
            <summary>
            This GameObject is the root of a nested prefab instance.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsPrefabCacheSceneRoot">
            <summary>
            Is this PrefabRoot the root of a prefab cache scene?
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.MapSource">
            <summary>
            The filename of the map this object is defined in.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.InitPrefabInstance(System.String,System.Boolean)">
            <summary>
            Initializes the instance data.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.PrefabInstance">
            <summary>
            Access point for all prefab instance related data.
            Can be accessed on both instance root and children contained within the instance.
            For outermost prefab instances this will contain a patch and guid mappings.
            For nested prefab instances this will just contain the prefab source.
            </summary>
        </member>
        <member name="F:Sandbox.GameObject.DiffObjectDefinitions">
            <summary>
            Defines objects within a scene hierarchy we want to track for prefab diffing and patching.
            </summary>
        </member>
        <member name="F:Sandbox.GameObject._removeAfterDeserializationRefresh">
            <summary>
            Helper variable for editor refreshes during deserialization.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.SceneForNetwork">
            <summary>
            If we're serializing for network, we won't include any networked objects
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.Cloning">
            <summary>
            We're cloning this object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.SingleNetworkObject">
            <summary>
            We're going to send a single network object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.SerializePrefabForDiff">
            <summary>
            Serialize the full hierarchy, prefab instances will be expanded to include all their children and components.
            All instances will be considered nested instances.
            The path to the prefab instance will be included in the JSON <see cref="F:Sandbox.GameObject.JsonKeys.EditorPrefabInstanceNestedSource"/>
            Implies 
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.SerializeForPrefabInstanceToPrefabUpdate">
            <summary>
            Serialize the prefab instance so it can be used to update the state of the prefab.
            Makes sure TopLevel nested prefabs are flagged, so they can get converted to a full prefab instance in the prefab.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.IgnoreChildren">
            <summary>
            Don't serialize gameObject children.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.IgnoreComponents">
            <summary>
            Don't serialize gameObject components.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.DeserializeOptions.IsRefreshing">
            <summary>
            
            When true, updates the existing GameObject hierarchy instead of creating a new one from scratch.
            This preserves C# object references and identity, used for undo/redo operations,
            and prefab instance patching.
            
            During refreshing:
            - Existing GameObjects and Components are updated rather than recreated
            - Objects are matched by their GUIDs
            - Only missing objects are created
            - Existing objects not present in the JSON are removed
            - Component ordering is preserved as specified in the JSON
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.DeserializeOptions.IsNetworkRefresh">
            <summary>
            Should be used in Conjunction with <see cref="P:Sandbox.GameObject.DeserializeOptions.IsRefreshing"/>.
            Makes sure child networked objects are not removed during refresh.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.DeserializeOptions.TransformOverride">
            <summary>
            Allows overriding the transform when deserializing. Will apply only to the root object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Serialize(Sandbox.GameObject.SerializeOptions)">
            <summary>
            Returns either a full JsonObject with all the GameObjects data,
            or if this GameObject is a prefab instance, it wil return an object containing the patch/diff between instance and prefab.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.SerializePrefabInstance">
            <summary>
            Creates a JSON representation of this prefab instance including its overrides and GUID mappings.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.SerializePrefabInstanceForNetwork(Sandbox.GameObject.SerializeOptions)">
            <summary>
            Creates a JSON representation of this prefab instance including its overrides and GUID mappings.
            Only includes non networked objects.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.SerializeStandard(Sandbox.GameObject.SerializeOptions)">
            <summary>
            Returns a JsonObject containing all the GameObject's data.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.SerializeTransform(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Serializing the transform depends on a bunch of stuff, so split it into this method for clarity.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.DeserializeTransform(System.Text.Json.Nodes.JsonObject,Sandbox.GameObject.DeserializeOptions)">
            <summary>
            Again - this can be complicated, so this is extracted
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.DeserializePrefabVariables(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Only needed for legacy support, when cloning.
            </summary>
            <param name="variables"></param>
        </member>
        <member name="M:Sandbox.GameObject.PushDeserializeContext">
            <summary>
            Push ActionGraph source location and cache if we're a prefab instance or map object.
            </summary>
        </member>
        <member name="T:Sandbox.GameObject.JsonKeys">
            <summary>
            Json Keys used for serialization and deserialization of GameObjects.
            Kept here so they are easier to change, and we are less susceptible to typos.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.PlaySound(Sandbox.SoundEvent,Vector3)">
            <summary>
            Play this sound on this GameObject. The sound will follow the position of the GameObject.
            You'll be able to use GameObject.StopAllSounds to stop all sounds that are following this GameObject.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.StopAllSounds(System.Single)">
            <summary>
            Stop any sounds playing on this GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.OnTagsUpdatedInternal">
            <summary>
            Called by GameTags when the tags change
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Upgrader_v1(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Converts Legacy Prefab Instance Data and variables to a patch.
            - Root level properties: Transform, Flags, Network... are converted to property overrides
            - Prefab Variables are converted to component property overrides
            - Prefab to instance guid lookup is created
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.ConvertLegacyPrefabInstanceToPatch(System.Text.Json.Nodes.JsonObject,Sandbox.PrefabFile)">
            <summary>
            Backwards combatibility for old prefab instances.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.WorldTransform">
            <summary>
            The world transform of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.WorldPosition">
            <summary>
            The world position of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.WorldRotation">
            <summary>
            The world rotation of the game object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.WorldScale">
            <summary>
            The world scale of the game object.
            </summary>
        </member>
        <member name="T:Sandbox.CloneConfig">
            <summary>
            The low level input of a GameObject.Clone
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Hidden">
            <summary>
            Hide this object in heirachy/inspector
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.NotSaved">
            <summary>
            Don't save this object to disk, or when duplicating
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Bone">
            <summary>
            Auto created - it's a bone, driven by animation
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Attachment">
            <summary>
            Auto created - it's an attachment
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Error">
            <summary>
            There's something wrong with this
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Loading">
            <summary>
            Loading something
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Deserializing">
            <summary>
            Is in the process of deserializing
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.DontDestroyOnLoad">
            <summary>
            When loading a new scene, keep this gameobject active
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.NotNetworked">
            <summary>
            Keep local - don't network this object as part of the scene snapshot
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Refreshing">
            <summary>
            In the process of refreshing from the network
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.ProceduralBone">
            <summary>
            Stops animation stomping the bone, will use the bone's local position
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.EditorOnly">
            <summary>
            Only exists in the editor. Don't spawn it in game.
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Absolute">
            <summary>
            Ignore the parent transform. Basically, position: absolute for gameobjects.
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.PhysicsBone">
            <summary>
            The position of this object is controlled by by physics - usually via a RigidBody component
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectReference">
            <summary>
            A serialized reference to a <see cref="T:Sandbox.GameObject"/> that can be resolved at runtime.
            Can either have a <see cref="P:Sandbox.GameObjectReference.GameObjectId"/> for objects in a scene, or a <see cref="P:Sandbox.GameObjectReference.PrefabPath"/>
            if we're referencing a prefab.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectReference.FromId(System.Guid)">
            <summary>
            Reference a <see cref="T:Sandbox.GameObject"/> in a scene by its <see cref="P:Sandbox.GameObject.Id"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectReference.FromPrefabPath(System.String)">
            <summary>
            Reference a prefab by its <see cref="P:Sandbox.Resource.ResourcePath"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectReference.FromInstance(Sandbox.GameObject)">
            <summary>
            Reference a given <see cref="T:Sandbox.GameObject"/>.
            </summary>
        </member>
        <member name="P:Sandbox.GameObjectReference.ReferenceType">
            <summary>
            Expected to be <c>"gameobject"</c> for a game object reference.
            </summary>
        </member>
        <member name="P:Sandbox.GameObjectReference.GameObjectId">
            <summary>
            If we're referencing an object in a scene, this is its <see cref="P:Sandbox.GameObject.Id"/>.
            </summary>
        </member>
        <member name="P:Sandbox.GameObjectReference.PrefabPath">
            <summary>
            If we're referencing a prefab, this is its <see cref="P:Sandbox.Resource.ResourcePath"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectReference.Resolve">
            <summary>
            Attempt to resolve this reference in the current <see cref="P:Sandbox.Game.ActiveScene"/>. Returns <see langword="null"/> if
            the reference couldn't be resolved, and logs a warning.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectReference.Resolve(Sandbox.Scene,System.Boolean)">
            <summary>
            Attempt to resolve this reference in the given <paramref name="scene"/>. Returns <see langword="null"/> if
            the reference couldn't be resolved.
            </summary>
            <param name="scene">Scene to attempt to resolve the reference in.</param>
            <param name="warn">If true, log a warning to the console if the reference couldn't be resolved.</param>
        </member>
        <member name="T:Sandbox.GameTags">
            <summary>
            Entity Tags are strings you can set and check for on any entity. Internally
            these strings are tokenized and networked so they're also available clientside.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.TryGetAll">
            <summary>
            Returns all the tags this object has.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.TryGetAll(System.Boolean)">
            <summary>
            Returns all the tags this object has.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Has(System.String)">
            <summary>
            Returns true if this object (or its parents) has given tag.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Has(System.String,System.Boolean)">
            <summary>
            Returns true if this object has given tag.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.HasAny(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Returns true if this object has one or more tags from given tag list.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Add(System.String)">
            <summary>
            Try to add the tag to this object.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Add(System.String[])">
            <summary>
            Adds multiple tags. Calls <see cref="M:Sandbox.GameTags.Add(System.String)">EntityTags.Add</see> for each tag.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Remove(System.String)">
            <summary>
            Try to remove the tag from this entity.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.RemoveAll">
            <summary>
            Remove all tags
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.GetTokens">
            <summary>
            Returns a list of ints, representing the tags. These are used internally by the engine.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.GetSuggested">
            <summary>
            Get all potential suggested tags that someone might want to add to this set.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.FixedUpdateInterpolation">
            <summary>
            Automatically interpolate the transform over multiple frames when changed within the context
            of a fixed update. This results in a smoother appearance for a moving <see cref="P:Sandbox.GameTransform.GameObject"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.HasAuthority">
            <summary>
            Do we have permission to change this transform?
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.IsFollowingParent">
            <summary>
            Are we following our parent object?
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.InsideChangeCallback">
            <summary>
            Returns true if we're inside the transform changed callback.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.IsInterpolating">
            <summary>
            Returns true if we're interpolating the transform, which means we're not inside a change callback and
            we're not in a fixed update scene.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.InterpolatedLocal">
            <summary>
            The current interpolated local transform.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.Local">
            <summary>
            The current local transform.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.SetLocalTransformFast(Transform@)">
            <summary>
            Sets the local transform without firing a bunch of "transform changed" callbacks.
            The assumption is that you're changing a bunch of child transforms, and will then call
            transform changed on the root, which will then invoke all the callbacks just once.
            This is what the animation system does!
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.TargetWorld">
            <summary>
            The target world transform. For internal use only.
            </summary>
        </member>
        <member name="F:Sandbox.GameTransform._worldCached">
            <summary>
            The world transform gets cached to avoid recalculating it every time. It is invalidated in TransformChanged, which
            is called recursively down children when the transform changes.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.World">
            <summary>
            The current world transform.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.Position">
            <summary>
            The position in world coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.Rotation">
            <summary>
            The rotation in world coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.Scale">
            <summary>
            The scale in world coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.LocalPosition">
            <summary>
            Position in local coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.LocalRotation">
            <summary>
            Rotation in local coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.LocalScale">
            <summary>
            Scale in local coordinates.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.LerpTo(Transform@,System.Single)">
            <summary>
            Performs linear interpolation between this and the given transform.
            </summary>
            <param name="target">The destination transform.</param>
            <param name="frac">Fraction, where 0 would return this, 0.5 would return a point between this and given transform, and 1 would return the given transform.</param>
        </member>
        <member name="M:Sandbox.GameTransform.DisableProxy">
            <summary>
            Disable the proxy temporarily
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.TargetLocal">
            <summary>
            The desired local transform. If we are interpolating we'll use the last value in the interpolation buffer.
            This is useful for networking because we always want to send the "real" transform.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.InterpolatedWorld">
            <summary>
            The interpolated world transform. For internal use only.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.ClearInterpolation">
            <summary>
            Clear any interpolation and force us to reach our final destination immediately. If we own this object
            we'll tell other clients to clear interpolation too when they receive the next network update from us.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.ClearLocalInterpolation">
            <summary>
            Like <see cref="M:Sandbox.GameTransform.ClearInterpolation"/> but will not clear interpolation across the network.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.DisableInterpolation">
            <summary>
            Temporarily disable Fixed Update Interpolation.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Sandbox.GameTransform.OnTransformChanged">
            <summary>
            Called when the transform is changed
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.TransformChanged(System.Boolean)">
            <summary>
            Our transform has changed, which means our children transforms changed too
            tell them all.
            </summary>
        </member>
        <member name="T:Sandbox.TransformProxyComponent">
            <summary>
            Help to implement a component that completely overrides the transform. This is useful for scenarios
            where you will want to keep the local transform of a GameObject, but want to offset based on that 
            for some reason.
            Having multiple of these on one GameObject is not supported, and will result in weirdness.
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.GetLocalTransform">
            <summary>
            Override to provide the local transform
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.SetLocalTransform(Transform@)">
            <summary>
            Called when the local transform is being set
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.GetWorldTransform">
            <summary>
            Override to provide the world transform. The default implementation will calculate it using GetLocalTransform() based on the parent.
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.SetWorldTransform(Transform)">
            <summary>
            Called when the world transform is being set
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.MarkTransformChanged">
            <summary>
            Tell our other components, and our children that our transform has changed. This will
            update things like Renderers to update their render positions.
            </summary>
        </member>
        <member name="T:Sandbox.INetworkDeltaSnapshot">
            <summary>
            Can be implemented on a type so that when used in conjunction with <see cref="T:Sandbox.SyncAttribute">[Sync]</see> you
            can write and read directly from delta snapshots.
            </summary>
        </member>
        <member name="M:Sandbox.INetworkDeltaSnapshot.WriteSnapshot(System.Int32,Sandbox.DeltaSnapshot)">
            <summary>
            Write to a <see cref="T:Sandbox.DeltaSnapshot"/>.
            </summary>
            <param name="slot">The parent slot in the network table for this property</param>
            <param name="snapshot">The snapshot we're writing to</param>
        </member>
        <member name="M:Sandbox.INetworkDeltaSnapshot.ReadSnapshot(System.Int32,Sandbox.DeltaSnapshot)">
            <summary>
            Read from a <see cref="T:Sandbox.DeltaSnapshot"/>.
            </summary>
            <param name="slot">The parent slot in the network table for this property</param>
            <param name="snapshot">The snapshot we're reading from</param>
        </member>
        <member name="T:Sandbox.INetworkProperty">
            <summary>
            An interface for networked properties via <see cref="T:Sandbox.SyncAttribute"/>.
            </summary>
        </member>
        <member name="M:Sandbox.INetworkProperty.Init(System.Int32,Sandbox.INetworkProxy)">
            <summary>
            Called when initializing with a network table at the specified slot.
            </summary>
            <param name="slot">Our slot index in the network table</param>
            <param name="parent">The object we belong to</param>
        </member>
        <member name="T:Sandbox.INetworkProxy">
            <summary>
            An interface to implement to determine whether this object is a proxy.
            </summary>
        </member>
        <member name="T:Sandbox.INetworkReliable">
            <summary>
            Indicates that this type must be sent reliably and cannot be sent as part of a
            delta snapshot.
            </summary>
        </member>
        <member name="T:Sandbox.INetworkSerializer">
            <summary>
            An interface for specifying how a custom type can be serialized and deserialized
            over the network with support for only sending changes.
            </summary>
        </member>
        <member name="M:Sandbox.INetworkSerializer.WriteChanged(Sandbox.ByteStream@)">
            <summary>
            Write any changes to the <see cref="T:Sandbox.ByteStream"/>. This is only applicable if
            the type that implements this also implements <see cref="T:Sandbox.INetworkReliable"/>.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.INetworkSerializer.WriteAll(Sandbox.ByteStream@)">
            <summary>
            Write all data to the <see cref="T:Sandbox.ByteStream"/>.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.INetworkSerializer.Read(Sandbox.ByteStream@)">
            <summary>
            Read data from a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:Sandbox.INetworkSerializer.HasChanges">
            <summary>
            Whether we currently have changes (are we dirty?)
            </summary>
        </member>
        <member name="T:Sandbox.NetDictionary`2">
            <summary>
            A networkable dictionary for use with the <see cref="T:Sandbox.SyncAttribute"/> and <see cref="T:Sandbox.HostSyncAttribute"/>. Only changes will be
            networked instead of sending the whole dictionary every time, so it's more efficient.
            <br/>
            <para>
            <b>Example usage:</b>
            <code>
            public class MyComponent : Component
            {
            	[Sync] public NetDictionary&lt;string,bool&gt; MyBoolTable { get; set; } = new();
            	<br/>
            	public void SetBoolState( string key, bool state )
            	{
            		if ( IsProxy ) return;
            		MyBoolTable[key] = state;
            	}
            }
            </code>
            </para>
            </summary>
        </member>
        <member name="T:Sandbox.NetDictionary`2.Change">
            <summary>
            Represents a change in the dictionary.
            </summary>
        </member>
        <member name="P:Sandbox.NetDictionary`2.Values">
            <summary>
            <inheritdoc cref="P:System.Collections.ObjectModel.ObservableDictionary`2.Values"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IDictionary.Contains(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IDictionary.Remove(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Add(`0,`1)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Add(`0,`1)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Clear">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Clear"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.ContainsKey(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.ContainsKey(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetDictionary`2.Keys">
            <summary>
            <inheritdoc cref="P:System.Collections.ObjectModel.ObservableDictionary`2.Keys"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Remove(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Remove(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.TryGetValue(`0,`1@)"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetDictionary`2.Count">
            <summary>
            <inheritdoc cref="P:System.Collections.ObjectModel.ObservableDictionary`2.Count"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.IDictionary.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.GetEnumerator"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetDictionary`2.Sandbox#INetworkSerializer#HasChanges">
            <summary>
            Do we have any pending changes?
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Sandbox#INetworkSerializer#WriteChanged(Sandbox.ByteStream@)">
            <summary>
            Write any changed items to a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Sandbox#INetworkSerializer#Read(Sandbox.ByteStream@)">
            <summary>
            Read a network update from a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Sandbox#INetworkSerializer#WriteAll(Sandbox.ByteStream@)">
            <summary>
            Write all items to a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.ReadAll(Sandbox.ByteStream@)">
            <summary>
            Read all changes in the dictionary as if we're building it for the first time.
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.ReadChanged(Sandbox.ByteStream@)">
            <summary>
            Read any changed items from a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="T:Sandbox.NetList`1">
            <summary>
            A networkable list for use with the <see cref="T:Sandbox.SyncAttribute"/> and <see cref="T:Sandbox.HostSyncAttribute"/>. Only changes will be
            networked instead of sending the whole list every time, so it's more efficient.
            <br/>
            <para>
            <b>Example usage:</b>
            <code>
            public class MyComponent : Component
            {
            	[Sync] public NetList&lt;int&gt; MyIntegerList { get; set; } = new();
            	<br/>
            	public void AddNumber( int number )
            	{
            		if ( IsProxy ) return;
            		MyIntegerList.Add( number );
            	}
            }
            </code>
            </para>
            </summary>
        </member>
        <member name="T:Sandbox.NetList`1.Change">
            <summary>
            Represents a change in the list.
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#Add(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.Add(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Remove(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.Contains(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.IndexOf(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.Insert(System.Int32,System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.Remove(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Clear">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Clear"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Contains(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Contains(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.CopyTo(`0[],System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Add(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Add(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Remove(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Remove(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.IndexOf(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.IndexOf(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Insert(System.Int32,`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.RemoveAt(System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetList`1.Count">
            <summary>
            <inheritdoc cref="P:System.Collections.Generic.List`1.Count"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.GetEnumerator"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetList`1.Sandbox#INetworkSerializer#HasChanges">
            <summary>
            Do we have any pending changes?
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Sandbox#INetworkSerializer#WriteChanged(Sandbox.ByteStream@)">
            <summary>
            Write any changed items to a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Sandbox#INetworkSerializer#Read(Sandbox.ByteStream@)">
            <summary>
            Read a network update from a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Sandbox#INetworkSerializer#WriteAll(Sandbox.ByteStream@)">
            <summary>
            Write all items to a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.ReadAll(Sandbox.ByteStream@)">
            <summary>
            Read all changes in the list as if we're building it for the first time.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.NetList`1.ReadChanged(Sandbox.ByteStream@)">
            <summary>
            Read any changed items from a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="T:Sandbox.NetworkTable`1">
            <summary>
            A network table that can be used with <see cref="T:Sandbox.SyncAttribute">[Sync]</see>. It will be serialized
            fully for clients when they first need it, and then it will be sent as delta snapshots when individual
            entries change.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkTable`1.Entries">
            <summary>
            Read-only access for all entries in the network table.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable`1.Clear">
            <summary>
            Clear the network table.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable`1.Set(System.Int32,`0)">
            <summary>
            Set the value of an entry in the specified slot.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable`1.Get(System.Int32)">
            <summary>
            Get the value of an entry in the specified slot.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable`1.OnInit(System.Int32)">
            <summary>
            Called when initialized from a parent network table.
            </summary>
            <param name="parentSlot"></param>
        </member>
        <member name="M:Sandbox.NetworkTable`1.OnKeyRemoved(System.Int32)">
            <summary>
            Called whenever a key is removed from the table.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable`1.OnValueChanged(System.Int32,`0)">
            <summary>
            Called whenever a value changes in a specific slot.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable`1.OnCleared">
            <summary>
            Called when the network table is cleared.
            </summary>
        </member>
        <member name="T:Sandbox.NetworkTransforms">
            <summary>
            A <see cref="T:Sandbox.NetworkTable`1"/> containing <see cref="T:Transform">Transforms</see> but each component of the transform
            is added to a <see cref="T:Sandbox.DeltaSnapshot"/>.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshot.AddReference">
            <summary>
            Add to reference count for this object.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshot.Release">
            <summary>
            Release a reference for this object, and return it to the pool
            if nothing else is referencing it.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshot.AddSerialized(System.Int32,System.Byte[])">
            <summary>
            Add a serialized byte array value to the specified slot.
            </summary>
            <param name="slot"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sandbox.DeltaSnapshot.Add``1(System.Int32,``0)">
            <summary>
            Add a value to the specified slot and serialize it to a byte array.
            </summary>
            <param name="slot"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Sandbox.DeltaSnapshot.TryGetValue``1(System.Int32,``0@)">
            <summary>
            Try to get a deserialized value from the specified slot.
            </summary>
            <param name="slot"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sandbox.DeltaSnapshot.From(System.Collections.Generic.Dictionary{System.Int32,System.Byte[]})">
            <summary>
            Build a <see cref="T:Sandbox.DeltaSnapshot"/> from the specified dictionary of type and value.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotCluster.AddReference">
            <summary>
            Add to reference count for this object.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotCluster.Release">
            <summary>
            Release a reference for this object, and return it to the pool
            if nothing else is referencing it.
            </summary>
        </member>
        <member name="P:Sandbox.DeltaSnapshotCluster.MaxSize">
            <summary>
            The maximum size (in bytes) of a single snapshot cluster. Since clusters are generally sent unreliably,
            the maximum size should really be under the typical MTU size of 1500 bytes.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotCluster.Add(Sandbox.DeltaSnapshot)">
            <summary>
            Add a <see cref="T:Sandbox.DeltaSnapshot"/> to the cluster. It will be ignored if the snapshot is empty.
            </summary>
            <param name="snapshot"></param>
        </member>
        <member name="T:Sandbox.DeltaSnapshotSystem.PooledMemoryStream">
            <summary>
            A wrapper around <see cref="T:System.IO.MemoryStream"/> used internally here to rent a pooled
            stream and avoid allocations where possible.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.PooledMemoryStream.Rent(System.Int32)">
            <summary>
            Rent a new stream from the pool or create one if none are available.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.PooledMemoryStream.GetWrittenSpan">
            <summary>
            Get a span of only the written portion of the buffer.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.PooledMemoryStream.Return">
            <summary>
            Return this stream to the pool and reset it.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.ConnectionData.RemoveNetworkObject(Sandbox.NetworkObject)">
            <summary>
            Clean up any data about a removed networked object.
            </summary>
            <param name="nwo"></param>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.ConnectionData.Clear">
            <summary>
            Clear this connection and clean up.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.ConnectionData.Tick">
            <summary>
            Tick the connection and clear any out-of-date data.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.RemoveConnection(Sandbox.Connection)">
            <summary>
            Remove a connection from the snapshot system.
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.Reset">
            <summary>
            Reset all connection data for the snapshot system. This might happen when a hotload
            occurs, or the host changes.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.ClearNetworkObject(Sandbox.NetworkObject)">
            <summary>
            Locally clear any stored snapshot information about a networked object.
            </summary>
            <param name="nwo"></param>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.CreateSnapshotId(System.Guid)">
            <summary>
            Create a new snapshot id for the provided <see cref="T:Sandbox.NetworkObject"/>.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.UpdateTime">
            <summary>
            Update the cached real time value that is used internally in the Delta Snapshot System.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.Tick">
            <summary>
            Tick the snapshot system and clear any out-of-date data.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.Send(System.Collections.Generic.IEnumerable{Sandbox.IDeltaSnapshot},System.Collections.Generic.IEnumerable{Sandbox.Connection})">
            <summary>
            Send a delta snapshot for a set of networked objects to the specified connections.
            </summary>
            <param name="objects"></param>
            <param name="connections"></param>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.Send(Sandbox.IDeltaSnapshot,Sandbox.NetFlags,System.Boolean)">
            <summary>
            Send a delta snapshot for a single networked object.
            </summary>
        </member>
        <member name="M:Sandbox.DeltaSnapshotSystem.GetFullSnapshotData(Sandbox.DeltaSnapshot)">
            <summary>
            Get a full serialized data update for a snapshot.
            </summary>
        </member>
        <member name="P:Sandbox.IDeltaSnapshot.Id">
            <summary>
            Unique identifier for this object.
            </summary>
        </member>
        <member name="P:Sandbox.IDeltaSnapshot.IsProxy">
            <summary>
            Whether this object is a proxy (or we own it.)
            </summary>
        </member>
        <member name="M:Sandbox.IDeltaSnapshot.OnSnapshot(Sandbox.Connection,Sandbox.DeltaSnapshot)">
            <summary>
            Called when a snapshot is received by a <see cref="T:Sandbox.Connection"/>.
            </summary>
            <param name="source"></param>
            <param name="snapshot"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.IDeltaSnapshot.WriteDeltaSnapshot(Sandbox.DeltaSnapshot)">
            <summary>
            Write delta snapshot data to the specified <see cref="T:Sandbox.DeltaSnapshot"/>.
            </summary>
        </member>
        <member name="M:Sandbox.IDeltaSnapshot.SendNetworkUpdate">
            <summary>
            Try to send a network update or do nothing if no update is required. This is most
            likely called after WriteDeltaSnapshot.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObjectPool`1.Rent">
            <summary>
            Rent an object from the pool.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObjectPool`1.Return(`0)">
            <summary>
            Return an object to the pool.
            </summary>
        </member>
        <member name="M:Sandbox.SnapshotData.AddReference">
            <summary>
            Add to reference count for this object.
            </summary>
        </member>
        <member name="M:Sandbox.SnapshotData.Release">
            <summary>
            Release a reference for this object, and return it to the pool
            if nothing else is referencing it.
            </summary>
        </member>
        <member name="T:Sandbox.SnapshotState">
            <summary>
            Represents the current snapshot state for an object based on delta snapshots received
            from another client.
            </summary>
        </member>
        <member name="F:Sandbox.SnapshotState.MaximumAckResponseTime">
            <summary>
            How many seconds we'll allow to pass for a snapshot acknowledgement packet
            to be received from a client.
            </summary>
        </member>
        <member name="M:Sandbox.SnapshotState.IsNewer(System.UInt16,System.UInt16)">
            <summary>
            Whether the incoming snapshot id is newer than our last processed one. This
            automatically handles wrapping of the ushort.
            </summary>
        </member>
        <member name="M:Sandbox.SnapshotState.AddPredicted(System.Int32,System.Byte[],System.Single)">
            <summary>
            Add a predicted entry to the snapshot. 
            </summary>
            <param name="slot"></param>
            <param name="value"></param>
            <param name="timeNow"></param>
        </member>
        <member name="M:Sandbox.SnapshotState.Update(System.Int32,System.UInt16,System.Byte[])">
            <summary>
            Update the value in the stored snapshot.
            </summary>
        </member>
        <member name="M:Sandbox.SnapshotState.TryGetValue(System.Int32,System.Byte[]@,System.Single)">
            <summary>
            Try to get the serialized byte array value from the specified slot.
            </summary>
        </member>
        <member name="M:Sandbox.SnapshotState.ToDeltaSnapshot(System.UInt16,System.Collections.Generic.IEnumerable{System.Int32},System.Single)">
            <summary>
            Create a new delta snapshot using the values of this snapshot state but only with the slots
            from the provided <see cref="T:Sandbox.DeltaSnapshot"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SnapshotState.From(Sandbox.DeltaSnapshot)">
            <summary>
            Build a new <see cref="T:Sandbox.SnapshotState"/> from the specified <see cref="T:Sandbox.DeltaSnapshot"/>.
            </summary>
        </member>
        <member name="T:Sandbox.HostSyncAttribute">
            <summary>
            Automatically synchronize a property of a networked object from the host to other clients.
            Obsolete: 11/12/2024
            </summary>
        </member>
        <member name="M:Sandbox.IInterpolatedSyncVar.Create``1(``0)">
            <summary>
            Create a new interpolator for the type of the provided value.
            </summary>
        </member>
        <member name="M:Sandbox.IInterpolatedSyncVar.Query(System.Single)">
            <summary>
            Query the interpolated value at the provided time.
            </summary>
        </member>
        <member name="T:Sandbox.InterpolatedSyncVar`1">
            <summary>
            Contains a target value and the current interpolated value for the
            property it represents.
            </summary>
        </member>
        <member name="M:Sandbox.InterpolatedSyncVar`1.#ctor(Sandbox.Interpolation.IInterpolator{`0})">
            <summary>
            Contains a target value and the current interpolated value for the
            property it represents.
            </summary>
        </member>
        <member name="M:Sandbox.InterpolatedSyncVar`1.Query(System.Single)">
            <summary>
            Query the value at the specified time.
            </summary>
        </member>
        <member name="M:Sandbox.InterpolatedSyncVar`1.Update(`0)">
            <summary>
            Update the value with the latest value from the network.
            </summary>
        </member>
        <member name="T:Sandbox.NetworkMode">
            <summary>
            Specifies how a <see cref="T:Sandbox.GameObject"/> should be networked.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkMode.Never">
            <summary>
            Never network this <see cref="T:Sandbox.GameObject"/>.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkMode.Object">
            <summary>
            Network this <see cref="T:Sandbox.GameObject"/> as a single network object. Objects networked in this
            way can have an owner, and synchronized properties with <see cref="T:Sandbox.SyncAttribute"/>.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkMode.Snapshot">
            <summary>
            Network this <see cref="T:Sandbox.GameObject"/> to other clients as part of the <see cref="T:Sandbox.Scene"/> snapshot.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.Id">
            <summary>
            The unique <see cref="T:System.Guid"/> of the underlying <see cref="P:Sandbox.NetworkObject.GameObject"/>.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.Creator">
            <summary>
            The <see cref="T:System.Guid"/> of the connection that created this.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkObject._isNetworkSpawning">
            <summary>
            If true then this object is spawning on the host, on behalf of another client. While it's
            doing this we're going to act like the host is the owner.. so that anything that is called in
            OnAwake will think we're not a proxy - until we've fully handed it off.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.Owner">
            <summary>
            The <see cref="T:System.Guid"/> of the connection that owns this.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.IsOwner">
            <summary>
            Are we the owner of this networked object?
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.IsUnowned">
            <summary>
            Is this networked object unowned?
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.IsProxy">
            <summary>
            This is this a proxy if we don't own this networked object.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.InitializeForConnection(Sandbox.Connection,System.Boolean)">
            <summary>
            Initialize and spawn this networked object with the specified owner <see cref="T:Sandbox.Connection"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.CallNetworkSpawn(Sandbox.Connection)">
            <summary>
            Call INetworkSpawn hooks
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.BroadcastNetworkSpawn(Sandbox.Connection)">
            <summary>
            Tell everyone that we exist, and spawn any child network objects with the same owner.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.Initialize(Sandbox.ObjectCreateMsg)">
            <summary>
            Initialize this networked object from a create message.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.HasControl(Sandbox.Connection)">
            <summary>
            Whether the specified <see cref="T:Sandbox.Connection"/> has control over this networked object. A connection
            has control if the object is unowned and they are the host, or if they own it directly.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.GetPropertySlot(System.Int32,System.Guid)">
            <summary>
            Get a deterministic property slot for use with a network table. This kind of sucks but it's easy
            to change it later if there's a better / faster way.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.WriteReliableData">
            <summary>
            Write all reliable data table entries.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.WriteDataTable(System.Boolean)">
            <summary>
            Write all pending data table changes.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.ReadDataTable(System.Byte[],Sandbox.NetworkTable.ReadFilter)">
            <summary>
            Read the network table data.
            </summary>
        </member>
        <member name="T:Sandbox.NetworkOrphaned">
            <summary>
            Specifies what happens when the owner of a networked object disconnects.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkOrphaned.Destroy">
            <summary>
            Destroy the networked object.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkOrphaned.Host">
            <summary>
            Assign the host as the owner.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkOrphaned.Random">
            <summary>
            Randomly assign another connection as the owner.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkOrphaned.ClearOwner">
            <summary>
            Clear the owner of the networked object.
            </summary>
        </member>
        <member name="T:Sandbox.NetworkSpawnOptions">
            <summary>
            Configurable options when spawning a networked object.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkSpawnOptions.#ctor">
            <summary>
            Configurable options when spawning a networked object.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkSpawnOptions.Default">
            <summary>
            The default network spawn options.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkSpawnOptions.OrphanedMode">
            <summary>
            What happens to this networked object when its owner disconnects?
            </summary>
        </member>
        <member name="P:Sandbox.NetworkSpawnOptions.OwnerTransfer">
            <summary>
            Who can control the ownership of this networked object?
            </summary>
        </member>
        <member name="P:Sandbox.NetworkSpawnOptions.StartEnabled">
            <summary>
            Should this networked object start enabled?
            </summary>
        </member>
        <member name="P:Sandbox.NetworkSpawnOptions.Owner">
            <summary>
            Who should be the owner of this networked object?
            </summary>
        </member>
        <member name="P:Sandbox.NetworkTable.IsReadingChanges">
            <summary>
            Internal flag set while reading changes. Useful when you want to force
            something to be set when we otherwise wouldn't have permission to.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.Entry.HasControl(Sandbox.Connection)">
            <summary>
            Whether the specified <see cref="T:Sandbox.Connection"/> has control of this entry.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.Entry.HasControl">
            <summary>
            Whether we (our local <see cref="T:Sandbox.Connection"/>) have control of this entry.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sandbox.NetworkTable.HasAnyChanges">
            <summary>
            Do we have any pending changes for entries we control?
            </summary>
        </member>
        <member name="P:Sandbox.NetworkTable.HasReliableChanges">
            <summary>
            Do we have any pending reliable changes for entries we control?
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.Unregister(System.Int32)">
            <summary>
            Unregister a variable assigned to a slot id.
            </summary>
            <param name="slot"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.Register(System.Int32,Sandbox.NetworkTable.Entry)">
            <summary>
            Register a variable assigned to a slot id.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.GetValue(System.Int32)">
            <summary>
            Get a variable from a slot id.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.IsRegistered(System.Int32)">
            <summary>
            Does a variable with the specified slot exist?
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.HasControl(System.Int32)">
            <summary>
            Do we have control over the value for a specific slot id?
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.UpdateSlotHash(System.Int32,System.Object)">
            <summary>
            Update the hash for a specific slot id.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.SetValue(System.Int32,System.Object)">
            <summary>
            Set a variable from a slot id.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.WriteSnapshot(Sandbox.DeltaSnapshot)">
            <summary>
            Write supported snapshot variables serialized to the specified dictionary.
            </summary>
            <param name="snapshot"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.ReadSnapshot(Sandbox.Connection,Sandbox.DeltaSnapshot)">
            <summary>
            Read and apply any variables from the provided snapshot.
            </summary>
            <param name="snapshot"></param>
            <param name="source"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.WriteAllReliable(Sandbox.ByteStream@)">
            <summary>
            Write all reliable variables to the provided <see cref="T:Sandbox.ByteStream"/>.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.WriteAll(Sandbox.ByteStream@)">
            <summary>
            Write all variables to the provided <see cref="T:Sandbox.ByteStream"/>.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.WriteEntryToStream(Sandbox.NetworkTable.Entry,Sandbox.ByteStream@,System.Boolean)">
            <summary>
            Write an entry to the specified <see cref="T:Sandbox.ByteStream"/>.
            </summary>
            <param name="entry"></param>
            <param name="bs"></param>
            <param name="onlyWriteChanges"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.WriteReliableChanged(Sandbox.ByteStream@)">
            <summary>
            Write any changes to the provided <see cref="T:Sandbox.ByteStream"/> for entries that must be sent reliably. Calling this will clear the changes.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.WriteChanged(Sandbox.ByteStream@)">
            <summary>
            Write any changes to the provided <see cref="T:Sandbox.ByteStream"/>. Calling this will clear the changes.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.Read(Sandbox.ByteStream@,Sandbox.NetworkTable.ReadFilter)">
            <summary>
            Read and apply any variables from the provided <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.QueryValues">
            <summary>
            If any properties are "query" types, we'll copy the new values to ourselves
            and mark as changed, if changed.
            </summary>
        </member>
        <member name="T:Sandbox.OwnerTransfer">
            <summary>
            Specifies who can control ownership of a networked object.
            </summary>
        </member>
        <member name="F:Sandbox.OwnerTransfer.Takeover">
            <summary>
            Anyone can control ownership.
            </summary>
        </member>
        <member name="F:Sandbox.OwnerTransfer.Fixed">
            <summary>
            Only the host can change the ownership.
            </summary>
        </member>
        <member name="F:Sandbox.OwnerTransfer.Request">
            <summary>
            Anyone can request ownership changes from the host.
            </summary>
        </member>
        <member name="T:Sandbox.RpcAttribute">
            <summary>
            Marks a method as being an RPC. This means that it can be called over the network.
            </summary>
        </member>
        <member name="T:Sandbox.Rpc.BroadcastAttribute">
            <summary>
            Marks a method as being an RPC. It will be called for everyone.
            </summary>
        </member>
        <member name="T:Sandbox.Rpc.HostAttribute">
            <summary>
            Marks a method as being an RPC. It will only be called on the host.
            </summary>
        </member>
        <member name="T:Sandbox.Rpc.OwnerAttribute">
            <summary>
            Marks a method as being an RPC. It will only be called on owner of this object.
            </summary>
        </member>
        <member name="P:Sandbox.Rpc.Caller">
            <summary>
            The <see cref="T:Sandbox.Connection"/> that is calling this method.
            </summary>
        </member>
        <member name="P:Sandbox.Rpc.CallerId">
            <summary>
            The id of the <see cref="T:Sandbox.Connection"/> that is calling this method.
            </summary>
        </member>
        <member name="P:Sandbox.Rpc.Calling">
            <summary>
            Whether we're currently being called from a remote <see cref="T:Sandbox.Connection"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.Resume(Sandbox.WrappedMethod)">
            <summary>
            Resume a method from an RPC. If the RPC caller is our local connection then we'll
            first disable any active filter and restore it afterwards.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:Sandbox.Rpc.PreCall">
            <summary>
            Called right before calling an RPC function.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.FilterInclude(System.Collections.Generic.IEnumerable{Sandbox.Connection})">
            <summary>
            Filter the recipients of any Rpc called in this scope to only include the specified <see cref="T:Sandbox.Connection"/> set.
            </summary>
            <param name="connections">Only send the RPC to these connections.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterInclude(System.Predicate{Sandbox.Connection})">
            <summary>
            Filter the recipients of any Rpc called in this scope to only include a <see cref="T:Sandbox.Connection"/> based on a predicate.
            </summary>
            <param name="predicate">Only send the RPC to connections that meet the criteria of the predicate.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterInclude(Sandbox.Connection)">
            <summary>
            Filter the recipients of any Rpc called in this scope to only include the specified <see cref="T:Sandbox.Connection"/>.
            </summary>
            <param name="connection">Only send the RPC to this connection.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterExclude(System.Predicate{Sandbox.Connection})">
            <summary>
            Filter the recipients of any Rpc called in this scope to exclude a <see cref="T:Sandbox.Connection"/> based on a predicate.
            </summary>
            <param name="predicate">Exclude connections that don't meet the criteria of the predicate from receiving the RPC.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterExclude(System.Collections.Generic.IEnumerable{Sandbox.Connection})">
            <summary>
            Filter the recipients of any Rpc called in this scope to exclude the specified <see cref="T:Sandbox.Connection"/> set.
            </summary>
            <param name="connections">Exclude these connections from receiving the RPC.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterExclude(Sandbox.Connection)">
            <summary>
            Filter the recipients of any Rpc called in this scope to exclude the specified <see cref="T:Sandbox.Connection"/>.
            </summary>
            <param name="connection">Exclude this connection from receiving the RPC.</param>
        </member>
        <member name="M:Sandbox.Rpc.IncomingInstanceRpcMsg(Sandbox.ObjectRpcMsg,Sandbox.Connection)">
            <summary>
            An instance RPC call is incoming from the network. Look up the method and call it.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.IncomingInstanceRpcMsg(Sandbox.SceneRpcMsg,Sandbox.Connection)">
            <summary>
            An instance RPC call is incoming from the network. Look up the method and call it.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.HasHostInstancePermission(Sandbox.Connection,Sandbox.NetFlags)">
            <summary>
            Does the current caller have permission to invoke the RPC?
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.HasInstancePermission(Sandbox.Connection,Sandbox.GameObject,Sandbox.NetFlags)">
            <summary>
            Does the current caller have permission to invoke the RPC?
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.OnCallInstanceRpc(Sandbox.GameObjectSystem@,Sandbox.WrappedMethod@,System.Object[]@)">
            <summary>
            Called when an instance RPC is called for a <see cref="T:Sandbox.Scene"/> and <see cref="T:Sandbox.GameObjectSystem"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.OnCallInstanceRpc(Sandbox.GameObject@,Sandbox.Component@,Sandbox.WrappedMethod@,System.Object[]@)">
            <summary>
            Called when an instance RPC is called for a <see cref="T:Sandbox.GameObject"/> and <see cref="T:Sandbox.Component"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.SendInstanceRpc(Sandbox.GameObjectSystem,Sandbox.WrappedMethod@,System.Object[],Sandbox.RpcAttribute)">
            <summary>
            Do the actual send of the instance RPC.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.SendInstanceRpc(Sandbox.GameObject,Sandbox.Component,Sandbox.WrappedMethod@,System.Object[],Sandbox.RpcAttribute)">
            <summary>
            Do the actual send of the instance RPC.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.IncomingStaticRpcMsg(Sandbox.StaticRpcMsg,Sandbox.Connection)">
            <summary>
            A static RPC call is incoming from the network. Look up the method and call it.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.OnCallRpc(Sandbox.WrappedMethod,System.Object[])">
            <summary>
            Called when a static RPC is called
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.HasStaticPermission(Sandbox.Connection,Sandbox.NetFlags)">
            <summary>
            Does the current caller have permission to invoke the RPC?
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.SendStaticRpc(Sandbox.WrappedMethod,System.Object[],Sandbox.RpcAttribute)">
            <summary>
            Do the actual send of the static RPC.
            </summary>
        </member>
        <member name="T:Sandbox.BroadcastAttribute">
            <summary>
            Marks a method as being an RPC that when invoked will be called for all connected clients including the host.
            The state of the object the RPC is called on will be up-to-date including its <see cref="T:Sandbox.GameTransform"/> and any
            properties with the <see cref="T:Sandbox.SyncAttribute"/> or <see cref="T:Sandbox.HostSyncAttribute"/> attributes by the time the method
            is called on remote clients. The only except is any synchronized properties marked with <see cref="P:Sandbox.SyncAttribute.Query"/> which
            will generally only be received every network tick.
            </summary>
        </member>
        <member name="T:Sandbox.AuthorityAttribute">
            <summary>
            Marks a method as being an RPC specifically targeted to the owner of the <see cref="T:Sandbox.GameObject"/>, or the host
            if the <see cref="T:Sandbox.GameObject"/> doesn't have an owner.
            <br/><br/>
            The state of the object the RPC is called on will be up-to-date including its <see cref="T:Sandbox.GameTransform"/> and any
            properties with the <see cref="T:Sandbox.SyncAttribute"/> or <see cref="T:Sandbox.HostSyncAttribute"/> attributes by the time the method
            is called on remote clients. The only except is any synchronized properties marked with <see cref="P:Sandbox.SyncAttribute.Query"/> which
            will generally only be received every network tick.
            </summary>
        </member>
        <member name="T:Sandbox.NetPermission">
            <summary>
            Specifies who can invoke an action over the network.
            </summary>
        </member>
        <member name="F:Sandbox.NetPermission.Anyone">
            <summary>
            Anyone can invoke this.
            </summary>
        </member>
        <member name="F:Sandbox.NetPermission.HostOnly">
            <summary>
            Only the host can invoke this.
            </summary>
        </member>
        <member name="F:Sandbox.NetPermission.OwnerOnly">
            <summary>
            Only the owner can invoke this. If the action is static, this works the same way as <see cref="F:Sandbox.NetPermission.HostOnly"/>.
            </summary>
        </member>
        <member name="T:Sandbox.SceneNetworkSystem">
            <summary>
            This is created and referenced by the network system, as a way to route.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.SuppressSpawnMessages">
            <summary>
            Any <see cref="T:Sandbox.GameObject">GameObjects</see> created within this scope will not send spawn messages to other clients.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.LoadSceneBroadcast(Sandbox.SceneLoadOptions)">
            <summary>
            Load a scene for all other clients. This can only be called by the host.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.NetworkSpawnBatch">
            <summary>
            Start a network spawn batch. Any networked objects created within this scope
            will be sent with one spawn message. This makes sure that any references are
            kept to child networked objects when the objects are spawned on the other side.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.NetworkSpawnBroadcast(Sandbox.NetworkObject)">
            <summary>
            Broadcast the spawning of a networked object. This will add the networked object
            to batch list if we're spawning as part of a batch, and will ignore the spawn message
            entirely if we're supposed to be suppressing spawn messages.
            </summary>
            <param name="networkObject"></param>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.OnLoadSceneSnapshotMsg(Sandbox.LoadSceneSnapshotMsg,Sandbox.Connection,System.Guid)">
            <summary>
            Called when the host has provided us with a snapshot for a newly loaded scene.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.OnLoadSceneRequestSnapshotMsg(Sandbox.LoadSceneRequestSnapshotMsg,Sandbox.Connection,System.Guid)">
            <summary>
            Called when a client has requested the snapshot for a newly loaded scene. This is usually
            once they've done any preloading that they need to do.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.OnLoadSceneMsg(Sandbox.LoadSceneBeginMsg,Sandbox.Connection,System.Guid)">
            <summary>
            Called when the host has told us to load a new scene.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.OnSceneLoadedMsg(Sandbox.SceneLoadedMsg,Sandbox.Connection,System.Guid)">
            <summary>
            Called by clients to confirm they have finished loading the new scene.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.GetMountedVPKs(Sandbox.Connection,Sandbox.Network.MountedVPKsResponse@)">
            <summary>
            A client has joined and wants to know what VPKs to preload.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.MountVPKs(Sandbox.Connection,Sandbox.Network.MountedVPKsResponse)">
            <summary>
            Asynchronously load and mount any VPKs from the provided server response.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.GetSnapshot(Sandbox.Connection,Sandbox.Network.SnapshotMsg@)">
            <summary>
            A client has joined and wants a snapshot of the world.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.SetSnapshotAsync(Sandbox.Network.SnapshotMsg)">
            <summary>
            We have recieved a snapshot of the world.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.AcceptConnection(Sandbox.Connection,System.String@)">
            <summary>
            Called on the host to decide whether to accept a <see cref="T:Sandbox.Connection"/>. If any <see cref="T:Sandbox.Component"/>
            that implements this returns false, the connection will be denied.
            </summary>
            <param name="channel"></param>
            <param name="reason">The reason to display to the client.</param>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.OnHeartbeat(System.Single)">
            <summary>
            A heartbeat has been received from the host. We should make sure our times are in sync.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.OnDeltaSnapshotMessage(Sandbox.Network.InternalMessageType,Sandbox.ByteStream,Sandbox.Connection)">
            <summary>
            A delta snapshot message has been received from another connection.
            </summary>
        </member>
        <member name="T:Sandbox.ObjectRefreshMsgAck">
            <summary>
            When a client has sent an acknowledgement that they've received a refresh message for
            a networked object.
            </summary>
        </member>
        <member name="T:Sandbox.ObjectDestroyComponentMsg">
            <summary>
            When a <see cref="T:Sandbox.Component"/> in the hierarchy of a networked object has
            been destroyed.
            </summary>
        </member>
        <member name="T:Sandbox.ObjectDestroyDescendantMsg">
            <summary>
            When a <see cref="T:Sandbox.GameObject"/> in the hierarchy of a networked object has
            been destroyed.
            </summary>
        </member>
        <member name="T:Sandbox.ObjectRefreshDescendantMsg">
            <summary>
            When a <see cref="T:Sandbox.GameObject"/> in the hierarchy of a networked object has
            been added or changed.
            </summary>
        </member>
        <member name="T:Sandbox.ObjectRefreshComponentMsg">
            <summary>
            When a <see cref="T:Sandbox.Component"/> in the hierarchy of a networked object has
            been added or changed.
            </summary>
        </member>
        <member name="T:Sandbox.ObjectRefreshMsg">
            <summary>
            When a networked object has been refreshed. This is a full update message for that
            networked object. Any new GameObjects or Components in the hierarchy will be
            created and existing ones will be updated.
            </summary>
        </member>
        <member name="T:Sandbox.SyncAttribute">
            <summary>
            Automatically synchronize a property of a networked object from the owner to other clients.
            </summary>
        </member>
        <member name="P:Sandbox.SyncAttribute.Query">
             <summary>
             Query this value for changes rather than counting on set being called. This is appropriate
             if the value returned by its getter can change without calling its setter.
            
             Obsoleted: 13/12/2024
             </summary>
        </member>
        <member name="P:Sandbox.SyncAttribute.Flags">
            <summary>
            Flags that describe how this property is synchronized.
            </summary>
        </member>
        <member name="T:Sandbox.SyncFlags">
            <summary>
            Describes the behaviour of network synchronization.
            </summary>
        </member>
        <member name="F:Sandbox.SyncFlags.FromHost">
            <summary>
            The host has ownership over the value.
            </summary>
        </member>
        <member name="F:Sandbox.SyncFlags.Query">
            <summary>
            Query this value for changes rather than counting on set being called. This is appropriate
            if the value returned by its getter can change without calling its setter.
            </summary>
        </member>
        <member name="F:Sandbox.SyncFlags.Interpolate">
            <summary>
            The value will be interpolated between ticks. This is currently only supported for <see cref="T:System.Single"/>, <see cref="T:System.Double"/>, <see cref="T:Angles"/>,
            <see cref="T:Rotation"/>, <see cref="T:Transform"/>, <see cref="T:Vector3"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.MakeIdGuidsUnique(System.Text.Json.Nodes.JsonObject,System.Nullable{System.Guid})">
            <summary>
            Find all "__guid" guids, and replace them with new guids. This is used to make GameObject serializations unique,
            so when you duplicate stuff, it copies over uniquely and keeps associations.
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.MakeGameObjectsUnique(System.Text.Json.Nodes.JsonObject,System.Nullable{System.Guid})">
            <summary>
            Find all "Id" guids, and replace them with new guids. This is used to make GameObject serializations unique,
            so when you duplicate stuff, it copies over uniquely and keeps associations.
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject,Transform)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject,Vector3,Rotation)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject,Vector3)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.GetPrefabScene(Sandbox.PrefabFile)">
            <summary>
            Get a (cached) scene from a PrefabFile
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.RenderToBitmap(Sandbox.Bitmap,System.Func{Sandbox.GameObject})">
            <summary>
            Render a GameObject to a bitmap. This is usually used for easily rendering "previews" of GameObjects, 
            for things like saving thumbnails etc.
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.RenderGameObjectToBitmap(Sandbox.GameObject,Sandbox.Bitmap)">
            <summary>
            Render a GameObject to a bitmap. This is usually used for easily rendering "previews" of GameObjects, 
            for things like saving thumbnails etc.
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.RenderModelBitmap(Sandbox.Model,Sandbox.Bitmap)">
            <summary>
            Render a Model to a bitmap. This is usually used for easily rendering "previews" of Models for thumbnails
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.RunInBatchGroup(System.Action)">
            <summary>
            Run an action inside a batch group. A batchgroup is used with GameObject and Components to
            make sure that their OnEnable/OnDisable and other callbacks are called in a deterministic order,
            and that they can find each other during creation.
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectDirectory">
            <summary>
            New GameObjects and Components are registered with this class when they're created, and 
            unregistered when they're removed. This gives us a single place to enforce
            Id uniqueness in the scene, and allows for fast lookups by Id.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectDirectory.FindSystemByGuid(System.Guid)">
            <summary>
            Find a GameObjectSystem in the scene by Guid. This should be really really fast.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectDirectory.FindComponentByGuid(System.Guid)">
            <summary>
            Find a Component in the scene by Guid. This should be really really fast.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectDirectory.FindByGuid(System.Guid)">
            <summary>
            Find a GameObject in the scene by Guid. This should be really really fast.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectDirectory.FindByName(System.String,System.Boolean)">
            <summary>
            Find objects with this name. Not performant.
            </summary>
        </member>
        <member name="T:Sandbox.ISceneMetadata">
            <summary>
            Allows components to add metadata to the scene/prefab file, which is accessible before loading it.
            </summary>
        </member>
        <member name="T:Sandbox.PrefabCacheScene">
            <summary>
            A prefab which is loaded and accessible via GameObject.GetPrefab( x )
            </summary>
        </member>
        <member name="P:Sandbox.PrefabCacheScene.FullPrefabInstanceJson">
            <summary>
            Contains the the JSON for the prefab after loading it's cached scene and expanding all prefab instances.
            We cache this since we use this quite often to resolve nested prefab instance overrides.
            </summary>
        </member>
        <member name="F:Sandbox.PrefabCacheScene.referencedPrefabs">
            <summary>
            Contains all the prefab files that are referenced by this prefab scene.
            </summary>
        </member>
        <member name="M:Sandbox.PrefabCacheScene.Destroy">
            <summary>
            Don't try and do this. You can't destroy a PrefabCacheScene.
            </summary>
        </member>
        <member name="P:Sandbox.PrefabScene.Variables">
            <summary>
            A list of variables and their targets for this prefab scene
            </summary>
        </member>
        <member name="T:Sandbox.PrefabScene.VariableCollection">
            <summary>
            A collection of variabnles that have been configured for this scene
            </summary>
        </member>
        <member name="M:Sandbox.Scene.RegisterComponent(Sandbox.Component)">
            <summary>
            Called for every enabled component
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetAllComponents``1">
            <summary>
            Get all components of type. This can include interfaces.
            This function can only find enabled/active components.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetAllComponents(System.Type)">
            <summary>
            Get all components of type. This can include interfaces.
            This function can only find enabled/active components.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.OverrideSourceLocation">
            <summary>
            For scenes within a hammer MapWorld, for action graph stack traces,
            and so the editor knows the map must be saved when editing graphs from it.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.WantsSystemScene">
            <summary>
            If true we'll additive load the system scene when this scene is loaded. Defaults
            to true. You might want to disable this for specific scenes, like menu scenes etc.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.RenderAttributes">
            <summary>
            Global render attributes accessible on any renderable in this Scene.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.IsValid">
            <summary>
            Returns true if this scene has not been destroyed
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Destroy">
            <summary>
            Destroy this scene. After this you should never use it again.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.CreateObject(System.Boolean)">
            <summary>
            Create a GameObject on this scene. This doesn't require the scene to be the active scene.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Push">
            <summary>
            Push this scene as the active scene, for a scope
            </summary>
        </member>
        <member name="P:Sandbox.Scene.Cameras">
            <summary>
            Cache all enabled and disabled cameras in the scene.
            Registered/Deregistered in CameraComponent.OnAwake and OnDestroy.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.PreCameraRender">
            <summary>
            Should be called before rendering. This allows things like reflections to render.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.Volumes">
            <summary>
            Allows quickly finding components that have a volume
            </summary>
        </member>
        <member name="M:Sandbox.Scene.AddSystemScene">
            <summary>
            Adds the "system" scene, which is defined in the project settings.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.FindAllWithTags(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Find objects with all tags
            </summary>
        </member>
        <member name="M:Sandbox.Scene.FindAllWithTag(System.String)">
            <summary>
            Find objects with tag
            </summary>
        </member>
        <member name="M:Sandbox.Scene.QueueDelete(Sandbox.GameObject)">
            <summary>
            Adds a GameObject to delete later
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ProcessDeletes">
            <summary>
            Delete any GameObjects waiting to be deleted
            </summary>
        </member>
        <member name="P:Sandbox.Scene.Editor">
            <summary>
            Allows access to the scene's editor session from the game. This will be null if there is no
            editor session active on this scene.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.ISceneEditorSession.HasUnsavedChanges">
            <summary>
            True if this scene has unsaved changes
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ISceneEditorSession.AddSelectionUndo">
            <summary>
            You have changed the editor's selection, add a new undo entry
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ISceneEditorSession.FrameTo(BBox@)">
            <summary>
            Focus the editor camera onto this box
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ISceneEditorSession.Save(System.Boolean)">
            <summary>
            Save this scene to disk
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ISceneEditorSession.RecordChange(Sandbox.SerializedProperty)">
            <summary>
            Tell undo about this property change
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ISceneEditorSession.AddUndo(System.String,System.Action,System.Action)">
            <summary>
            Add a new undo entry
            </summary>
        </member>
        <member name="M:Sandbox.Scene.RunEvent``1(System.Action{``0},Sandbox.FindMode)">
            <summary>
            Run an event on all components. The find argument is unused when calling this on a scene.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.Listener">
            <summary>
            Default scene sound listener, at the camera.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.Listeners">
            <summary>
            Multiple scene sound listeners, created by audio listener components.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.UpdateDefaultListener">
            <summary>
            Update default sound listener to camera.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.DisposeListeners">
            <summary>
            Dispose any sound listeners we created.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.AddListener">
            <summary>
            Add a new sound listener and return it.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.RemoveListener(Sandbox.Audio.Listener)">
            <summary>
            Remove and dispose a scene sound listener.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.FindClosestListener(Vector3)">
            <summary>
            Find the closest sound listener at this point.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.IsLoading">
            <summary>
            Return true if we're in an initial loading phase
            </summary>
        </member>
        <member name="M:Sandbox.Scene.WaitForLoading">
            <summary>
            Wait for scene loading to finish
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Load(Sandbox.GameResource)">
            <summary>
            Load from the provided <see cref="T:Sandbox.SceneFile"/>. This will not load the scene for other clients in a
            multiplayer session, you should instead use <see cref="M:Sandbox.Game.ChangeScene(Sandbox.SceneLoadOptions)"/>
            if you want to bring other clients.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Load(Sandbox.SceneLoadOptions)">
            <summary>
            Load from the provided <see cref="T:Sandbox.SceneLoadOptions"/>. This will not load the scene for other clients in a
            multiplayer session, you should instead use <see cref="M:Sandbox.Game.ChangeScene(Sandbox.SceneLoadOptions)"/>
            if you want to bring other clients.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.LoadFromFile(System.String)">
            <summary>
            Load from the provided file name. This will not load the scene for other clients in a
            multiplayer session, you should instead use <see cref="M:Sandbox.Game.ChangeScene(Sandbox.SceneLoadOptions)"/>
            if you want to bring other clients.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.CreateSceneFile">
            <summary>
            Create a new SceneFile from this scene
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ToSceneFile(Sandbox.SceneFile)">
            <summary>
            Save the contents of this scene to the SceneFile
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Nav_Update">
            <summary>
            In editor this gets called every frame
            In game this gets called every fixed update
            </summary>
        </member>
        <member name="P:Sandbox.Scene.NetworkRate">
            <summary>
            One divided by ProjectSettings.Networking.UpdateRate.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.SceneNetworkUpdate">
            <summary>
            Send any pending network updates at our desired <see cref="P:Sandbox.Scene.NetworkRate"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.DoOrphanedActions(Sandbox.Connection)">
            <summary>
            Do appropriate actions based on the <see cref="T:Sandbox.NetworkOrphaned"/> mode for all networked objects owned by a specific connection.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ClearObjectIndex">
            <summary>
            Should only be called when destroying the scene. This here just to avoid unregistering
            all of the objects when we don't need to, because we're just quitting.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.HotloadObjectIndex">
            <summary>
            When hotload occurs, the interfaces etc could have changed. So first of all we want to
            go through and remove any null entries, then we want to go through and re-add everything.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.AddObjectToDirectory(System.Object)">
            <summary>
            Adds object instance, indexed by type, to the directory so that its values are accessible by GetAll
            </summary>
        </member>
        <member name="M:Sandbox.Scene.RemoveObjectFromDirectory(System.Object)">
            <summary>
            Adds object instance, indexed by type, to the directory so that its values are accessible by GetAll
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetAll``1">
            <summary>
            Get all objects of this type. This could be a component or a GameObjectSystem, or other stuff in the future.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Get``1">
            <summary>
            Gets the first object found of this type. This could be a component or a GameObjectSystem, or other stuff in the future.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Scene.ShutdownSystems">
            <summary>
            Call dispose on all installed hooks
            </summary>
        </member>
        <member name="M:Sandbox.Scene.InitSystems">
            <summary>
            Find all types of SceneHook, create an instance of each one and install it.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Signal(Sandbox.GameObjectSystem.Stage@)">
            <summary>
            Signal a hook stage
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetCallbacks(Sandbox.GameObjectSystem.Stage@)">
            <summary>
            Get the hook container for this stage
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ResetListenerMetrics">
            <summary>
            Reset the listener metrics to 0, like before a benchmark or something
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetListenerMetrics">
            <summary>
            Get a JSON serializable list of metrics from the scene's listeners.
            (this is just internal object[] right now because I can't be fucked to exose it properly)
            </summary>
        </member>
        <member name="M:Sandbox.Scene.AddHook(Sandbox.GameObjectSystem.Stage,System.Int32,System.Action,System.String,System.String)">
            <summary>
            Call this method on this stage. This returns a disposable that will remove the hook when disposed.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetSystem``1">
            <summary>
            Get a specific system by type.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetSystem``1(``0@)">
            <summary>
            Get a specific system by type.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetSystemByType(Sandbox.TypeDescription)">
            <summary>
            Get a specific system by <see cref="T:Sandbox.TypeDescription"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetSystems">
            <summary>
            Get all systems belonging to this scene.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.PreTickReset">
            <summary>
            The update loop will turn certain settings on
            Here we turn them to their defaults.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.UpdateTimeFromHost(System.Double)">
            <summary>
            Update the current time from the host
            </summary>
        </member>
        <member name="M:Sandbox.Scene.RunPendingStarts">
            <summary>
            Run OnStart on all components that haven't had OnStart called yet
            </summary>
        </member>
        <member name="M:Sandbox.Scene.SharedTick">
            <summary>
            This is called in EditorTick and GameTick. It's only called in EditorTick if we're actually
            an editor scene. 
            </summary>
        </member>
        <member name="M:Sandbox.Scene.FindInPhysics(Sandbox.Sphere)">
            <summary>
            Find game objects in a sphere using physics.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.FindInPhysics(BBox)">
            <summary>
            Find game objects in a box using physics.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.FindInPhysics(Sandbox.Frustum)">
            <summary>
            Find game objects in a frustum using physics.
            </summary>
        </member>
        <member name="T:Sandbox.ISceneEvent`1">
            <summary>
            A wrapper for scene event interfaces. Allows syntax sugar of something like
            `IPlayerEvents.Post( x => x.OnPlayerHurt( this, amount ) )` instead of using
            Scene.Run to call them manually.
            </summary>
        </member>
        <member name="M:Sandbox.ISceneEvent`1.Post(System.Action{`0})">
            <summary>
            Post an event to the entire scene, including GameObjectSystem's
            </summary>
        </member>
        <member name="M:Sandbox.ISceneEvent`1.PostToGameObject(Sandbox.GameObject,System.Action{`0},Sandbox.FindMode)">
            <summary>
            Post event to a specific GameObject (and its descendants by default - you can specify a <see cref="T:Sandbox.FindMode"/> to control this)
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrace.NeedsFilterCallback">
            <summary>
            returns true if we need to do some managed side filtering
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Sphere(System.Single,Vector3@,Vector3@)">
            <summary>
            Casts a sphere from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Sphere(System.Single,Ray@,System.Single@)">
            <summary>
            Casts a sphere from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Box(Vector3,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Box(Vector3,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Box(BBox,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Box(BBox,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Capsule(Capsule)">
            <summary>
            Casts a capsule
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Capsule(Capsule,Vector3@,Vector3@)">
            <summary>
            Casts a capsule from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Capsule(Capsule,Ray@,System.Single@)">
            <summary>
            Casts a capsule from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Cylinder(System.Single,System.Single)">
            <summary>
            Casts a cylinder
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Cylinder(System.Single,System.Single,Vector3@,Vector3@)">
            <summary>
            Casts a cylinder from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Cylinder(System.Single,System.Single,Ray@,System.Single@)">
            <summary>
            Casts a cylinder from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Ray(Vector3@,Vector3@)">
            <summary>
            Casts a ray from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Ray(Ray@,System.Single@)">
            <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Body(Sandbox.PhysicsBody)">
            <summary>
            Casts a <see cref="T:Sandbox.PhysicsBody"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Body(Sandbox.PhysicsBody,Vector3@)">
            <summary>
            Casts a PhysicsBody from its current position and rotation to desired end point.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Body(Sandbox.Rigidbody,Vector3@)">
            <summary>
            Casts a PhysicsBody from its current position and rotation to desired end point.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Body(Sandbox.PhysicsBody,Transform@,Vector3@)">
            <summary>
            Casts a PhysicsBody from a position and rotation to desired end point.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Sweep(Sandbox.PhysicsBody@,Transform@,Transform@)">
            <summary>
            Sweeps each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of given PhysicsBody and returns the closest collision. Does not support Mesh PhysicsShapes.
            Basically 'hull traces' but with physics shapes.
            Same as tracing a body but allows rotation to change during the sweep.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Sweep(Sandbox.Rigidbody@,Transform@,Transform@)">
            <summary>
            Sweeps each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of given PhysicsBody and returns the closest collision. Does not support Mesh PhysicsShapes.
            Basically 'hull traces' but with physics shapes.
            Same as tracing a body but allows rotation to change during the sweep.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Sweep(Sandbox.PhysicsBody@,Transform@)">
            <summary>
            Creates a Trace.Sweep using the <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see>'s position as the starting position.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.FromTo(Vector3@,Vector3@)">
            <summary>
            Sets the start and end positions of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.FromTo(Transform@,Vector3@)">
            <summary>
            Sets the start transform and end position of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Size(BBox@)">
            <summary>
            Makes this trace an axis aligned box of given size. Extracts mins and maxs from the Bounding Box.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Size(Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size. Calculates mins and maxs by assuming given size is (maxs-mins) and the center is in the middle.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Size(Vector3@,Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Rotated(Rotation@)">
            <summary>
            Makes this a rotated trace, for tracing rotated boxes and capsules.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Radius(System.Single)">
            <summary>
            Makes this trace a sphere of given radius.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.UseHitPosition(System.Boolean)">
            <summary>
            Should we compute hit position.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.UseHitboxes(System.Boolean)">
            <summary>
            Should we hit hitboxes
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.UseRenderMeshes(System.Boolean)">
            <summary>
            Should we hit meshes too? This can be slow and only really recommended for editor work.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.UseRenderMeshes(System.Boolean,System.Boolean)">
            <summary>
            Should we hit meshes too? This can be slow and only really recommended for editor work.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.UsePhysicsWorld(System.Boolean)">
            <summary>
            Should we hit physics objects?
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithTag(System.String)">
            <summary>
            Only return entities with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the entity will need all tags).
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithAllTags(System.String[])">
            <summary>
            Only return entities with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithAllTags(Sandbox.ITagSet)">
            <summary>
            Only return entities with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithAnyTags(System.String[])">
            <summary>
            Only return entities with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithAnyTags(Sandbox.ITagSet)">
            <summary>
            Only return entities with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithoutTags(System.String[])">
            <summary>
            Only return entities without any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithoutTags(Sandbox.ITagSet)">
            <summary>
            Only return entities without any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithCollisionRules(System.String,System.Boolean)">
            <summary>
            Use the collision rules of an object with the given tags.
            </summary>
            <param name="tag">Which tag this trace will adopt the collision rules of.</param>
            <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
        </member>
        <member name="M:Sandbox.SceneTrace.WithCollisionRules(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Use the collision rules for the given set of tags.
            </summary>
            <param name="tags">Which tags this trace will adopt the collision rules of.</param>
            <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreGameObject(Sandbox.GameObject)">
            <summary>
            Do not hit this object
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreGameObjectHierarchy(Sandbox.GameObject)">
            <summary>
            Do not hit this object
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.HitTriggers">
            <summary>
            Hit Triggers
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.HitTriggersOnly">
            <summary>
            Hit Only Triggers
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreStatic">
            <summary>
            Do not hit static objects
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreDynamic">
            <summary>
            Do not hit dynamic objects
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreKeyframed">
            <summary>
            Do not hit keyframed objects
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Run">
            <summary>
            Run the trace and return the result. The result will return the first hit.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.RunAll">
            <summary>
            Run the trace and record everything we hit along the way. The result will be an array of hits.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.FilterCallback(Sandbox.PhysicsShape)">
            <summary>
            Return true if we should hit this shape.
            We puposely keep this locked down, don't offer a user specified callback.
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Hit">
            <summary>
            Whether the trace hit something or not
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.StartedSolid">
            <summary>
            Whether the trace started in a solid
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.StartPosition">
            <summary>
            The start position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.EndPosition">
            <summary>
            The end or hit position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.HitPosition">
            <summary>
            The hit position of the trace. Requires <see cref="M:Sandbox.SceneTrace.UseHitPosition(System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Normal">
            <summary>
            The hit surface normal (direction vector)
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Fraction">
            <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.GameObject">
            <summary>
            The GameObject that was hit
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Component">
            <summary>
            The Component that was hit
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Collider">
            <summary>
            The Collider that was hit
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Body">
            <summary>
            The physics object that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Shape">
            <summary>
            The physics shape that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Surface">
            <summary>
            The physical properties of the hit surface
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Bone">
            <summary>
            The id of the hit bone (either from hitbox or physics shape)
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Direction">
            <summary>
            The direction of the trace ray
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Triangle">
            <summary>
            The triangle index hit, if we hit a mesh <see cref="T:Sandbox.PhysicsShape">physics shape</see>
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Tags">
            <summary>
            The tags that the hit shape had
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Hitbox">
            <summary>
            The hitbox that we hit
            </summary>
        </member>
        <member name="P:Sandbox.SceneTraceResult.Distance">
            <summary>
            The distance between start and end positions.
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Links">
            <summary>
            A list of services that we have linked
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Memberships">
            <summary>
            A list of organizations of which we're a member
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Favourites">
            <summary>
            A list of our favourited games
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Session">
            <summary>
            Current client hash (the login session cookie)
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.SteamId">
            <summary>
            The current logged in user's steamid
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Score">
            <summary>
            The current logged in user's gamercore
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.AvatarJson">
            <summary>
            The current logged in user's avatar, from the backend
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.Update">
            <summary>
            Update Current
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.IsFavourite(System.String)">
            <summary>
            Helper - return true if Current.Favourites contains us
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.HasOrganization(System.String)">
            <summary>
            Returns true if a user is a member of this organization
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.GetUploadEndPointAsync(System.String)">
            <summary>
            Returns a URL in which users have the ability to upload files (but not the ability to list or download files).
            This is used so users can upload files to our blob storage, and give us the filename - rather than uploading big
            ass files to our api.
            </summary>
        </member>
        <member name="M:Sandbox.Api.GetAccountInformation">
            <summary>
            Get linked service credentials, ie "twitch". Under the hood, on our server, we will
            probably be renewing the token with the service (assume the token is only good for 2-3 hours).
            </summary>
        </member>
        <member name="M:Sandbox.Api.Benchmarks.Post(Sandbox.Services.BenchmarkRecord[],System.Threading.CancellationToken)">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Events.Add(Sandbox.Api.Events.EventRecord)">
            <summary>
            Add an event to the queue. You should not use this event again.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Events.Flush">
            <summary>
            Force an immediate flush of all events
            </summary>
        </member>
        <member name="M:Sandbox.Api.Events.TickEvents">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Events.PostEventsAsync(Sandbox.Api.Events.EventRecord[])">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Performance.CollectStat(System.String,System.Double)">
            <summary>
            Collect a statistic. This should usually be called ONCE per frame, per stat.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Performance.BuildStats">
            <summary>
            Convert statDict into an object that we can send to the backend.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Performance.ArrayToMetric(System.Collections.Generic.List{System.Double})">
            <summary>
             Here we take the array of values and convert them into an object with a bunch of statistics about them.
             Basically trying to cover our bases as much as possible, in case we need to show this data later on.
            </summary>
        </member>
        <member name="F:Sandbox.Api.LaunchGuid">
            <summary>
            This attempts to be a unique identifier for the launch of a game.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.FlushWithBookmarkAsync(System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Flush the stats and wait until they have been ingested by the backend, 
            at which point they should be available in stats and leaderboard queries.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.ForceFlush">
            <summary>
            Force an immediate flush of all events
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.ForceFlushAsync">
            <summary>
            Force an immediate flush of the stats and wait until it's done
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.TickStats">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.PostStatsAsync(Sandbox.Api.Stats.StatRecord[])">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Package">
            <summary>
            The package ident (lowercase [org.package])
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Name">
            <summary>
            The name of the stat (lowercase, no spaces)
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Created">
            <summary>
            When this stat was created
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Updated">
            <summary>
            When this stat was updated
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.IsIncrement">
            <summary>
            If this is an increment
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Compounds">
            <summary>
            If this represents multiple calls, this is the number of calls
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.MinValue">
            <summary>
            If this represents multiple calls, this is the smallest
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.MaxValue">
            <summary>
            If this represents multiple calls, this is the largest
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Value">
            <summary>
            The actual value
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Context">
            <summary>
            Additional context. Map etc..
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Session">
            <summary>
            The current session (or null if #local)
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.SessionSeconds">
            <summary>
            The current time in session
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Data">
            <summary>
            Should be a dynamic object
            </summary>
        </member>
        <member name="P:Sandbox.Achievement.IsVisible">
            <summary>
            Returns whether this achievement should be visible to the player
            </summary>
        </member>
        <member name="P:Sandbox.Achievement.ProgressionFraction">
            <summary>
            A float, representing the progression of this stat. 0 is 0%, 1 is 100%. Not clamped.
            </summary>
        </member>
        <member name="M:Sandbox.Achievement.GetFractionFromStat(Sandbox.Services.Stats.PlayerStat)">
            <summary>
            Given a stat return the fraction completed this achievement is. The assumption
            is that the stat you pass in matches the stat this achievement is looking for.
            The number returned is unclamped.
            </summary>
        </member>
        <member name="T:Sandbox.AchievementCollection">
            <summary>
            Holds achievements for a package
            </summary>
        </member>
        <member name="M:Sandbox.AchievementCollection.Get(System.String)">
            <summary>
            Get achievement by name, or null of it doesn't exist
            </summary>
        </member>
        <member name="M:Sandbox.AchievementCollection.RecountProgression">
            <summary>
            Use the current stats to recount the progression on stats with progression. This is purely for UI,
            you can't force an achivement to unlock early by calling this.
            </summary>
        </member>
        <member name="M:Sandbox.AchievementCollection.ManualUnlock(System.String)">
            <summary>
            Unlock this achievement. It must be a manual achievement.
            </summary>
        </member>
        <member name="M:Sandbox.AchievementCollection.Unlock(System.String)">
            <summary>
            Unlock this achievement. It can be anything.
            </summary>
        </member>
        <member name="M:Sandbox.AchievementCollection.TestAchivementsForUnlock">
            <summary>
            Check each achievement to see if it can be unlocked.
            </summary>
        </member>
        <member name="T:Sandbox.Cloud">
            <summary>
            For accessing assets from the cloud - from code
            </summary>
        </member>
        <member name="M:Sandbox.Cloud.Asset(System.String)">
            <summary>
            Returns the path of the asset referenced by this package
            </summary>
        </member>
        <member name="M:Sandbox.Cloud.Model(System.String)">
            <summary>
            Loads a model from the cloud by its identifier. The asset is downloaded during code compilation, so it's treated like a local model since it's shipped along with your package.
            <br></br>
            If you wish to load a model at runtime, use <see cref="M:Sandbox.Cloud.Load``1(System.String,System.Boolean)"/> instead.
            </summary>
            <param name="ident">The cloud ident/url of the model</param>
        </member>
        <member name="M:Sandbox.Cloud.Material(System.String)">
            <summary>
            Loads a material from the cloud by its identifier. The asset is downloaded during code compilation, so it's treated like a local material since it's shipped along with your package.
            <br></br>
            If you wish to load a material at runtime, use <see cref="M:Sandbox.Cloud.Load``1(System.String,System.Boolean)"/> instead.
            </summary>
            <param name="ident">The cloud ident/url of the material</param>
        </member>
        <member name="M:Sandbox.Cloud.SoundEvent(System.String)">
            <summary>
            Loads a sound event from the cloud by its identifier. The asset is downloaded during code compilation, so it's treated like a local particle system since it's shipped along with your package.
            <br></br>
            If you wish to load a sound event at runtime, use <see cref="M:Sandbox.Cloud.Load``1(System.String,System.Boolean)"/> instead.
            </summary>
            <param name="ident">The cloud ident/url of the particle system</param>
        </member>
        <member name="M:Sandbox.Cloud.Shader(System.String)">
            <summary>
            Loads a shader from the cloud by its identifier. The asset is downloaded during code compilation, so it's treated like a local shader since it's shipped along with your package.
            <br></br>
            If you wish to load a shader at runtime, use <see cref="M:Sandbox.Cloud.Load``1(System.String,System.Boolean)"/> instead.
            </summary>
            <param name="ident">The cloud ident/url of the shader</param>
        </member>
        <member name="M:Sandbox.Cloud.Load``1(System.String,System.Boolean)">
            <summary>
            Loads a resource asynchronously from the cloud by its identifier, downloading the package if the client doesn't have it locally.
            </summary>
        </member>
        <member name="T:Sandbox.Cloud.AssetAttribute">
            <summary>
            Automatically addeded to a type as a result of using Cloud.Model etc inside.
            </summary>
        </member>
        <member name="T:Sandbox.Cloud.CloudAssetProviderAttribute">
            <summary>
            Tells codegen to generate a [assembly: Cloud.Asset] for this method
            </summary>
        </member>
        <member name="T:Sandbox.LocalPackage">
            <summary>
            A mock package, this is a package wrapped around a <see cref="P:Sandbox.LocalPackage.Project"/>
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.ContentPath">
            <summary>
            The path to this project's assets
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.CodePath">
            <summary>
            The path to this project's code
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.LocalizationPath">
            <summary>
            The path to this project's localization files
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.IsBuiltIn">
            <summary>
            True if this package is shipped with the game - so everyone should have it
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.AssemblyFileSystem">
            <summary>
            A filesystem into which compiled assemblies are written
            </summary>
        </member>
        <member name="M:Sandbox.LocalPackage.GetMeta``1(System.String,``0)">
            <summary>
            Retrieve meta directly from the project instead of the package
            </summary>
        </member>
        <member name="M:Sandbox.LocalPackage.NeedsLocalBasePackage">
            <summary>
            Return true if we need the "base" package including. There are a few situations:
            
            1. We're the root gamemode
            
            </summary>
        </member>
        <member name="T:Sandbox.ManifestSchema">
            <summary>
            An addon's manifest, describing what files are available
            </summary>
        </member>
        <member name="P:Sandbox.ManifestSchema.Schema">
            <summary>
            For internal use
            </summary>
        </member>
        <member name="P:Sandbox.ManifestSchema.Files">
            <summary>
            A list of files that should be mounted to use this asset
            </summary>
        </member>
        <member name="T:Sandbox.Package">
            <summary>
            Represents an asset on <a href="https://asset.party/">Asset Party</a>.
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetAchievements">
            <summary>
            Get a list of achievements
            </summary>
        </member>
        <member name="P:Sandbox.Package.IsRemote">
            <summary>
            Whether this is a remote or a locally installed package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Org">
            <summary>
            The owner of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.FullIdent">
            <summary>
            Full unique identity of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Ident">
            <summary>
            Unique identity of this package within its <see cref="P:Sandbox.Package.Org">organization.</see>.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Title">
            <summary>
            A "nice" name of this package, which will be shown to players in UI.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Summary">
            <summary>
            A short summary of the package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Description">
            <summary>
            Full description of the package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Thumb">
            <summary>
            Link to the thumbnail image of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.ThumbWide">
            <summary>
            Link to the thumbnail image of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.ThumbTall">
            <summary>
            Link to the thumbnail image of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.VideoThumb">
            <summary>
            Link to the thumbnail video of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.EngineVersion">
            <summary>
            Engine version this package was uploaded with.
            This is useful for when the base game undergoes large API changes.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Tags">
            <summary>
            List of tags for this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageReferences">
            <summary>
            List of packages that this package depends on. These will be downloaded and installed when
            installing this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.EditorReferences">
            <summary>
            List of packages that this package depended on during editing.
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageType">
            <summary>
            What kind of package it is.
            </summary>
        </member>
        <member name="P:Sandbox.Package.TypeName">
            <summary>
            What kind of package it is.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Public">
            <summary>
            Whether this package is public or hidden.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Archived">
            <summary>
            Whether this package is archived or not.
            </summary>
        </member>
        <member name="P:Sandbox.Package.FileSize">
            <summary>
            The total size of this package in MB. This only applies to packages from Asset Party, the total file size
            of local packages are not calculated.
            </summary>
        </member>
        <member name="T:Sandbox.Package.PackageUsageStats">
            <summary>
            Statistics for user interactions with this package
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Group.Users">
            <summary>
            Unique Users
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Group.Seconds">
            <summary>
            Total combined user-seconds
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Group.Sessions">
            <summary>
            Total combined user-seconds
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Total">
            <summary>
            Total lifetime usage stats
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Month">
            <summary>
            Usage for the last 3 days
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Week">
            <summary>
            Usage for the last week
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Day">
            <summary>
            Usage for the last 24 hours
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.UsersNow">
            <summary>
            How many users are using it right now
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Trend">
            <summary>
            The trend is a number that represents whether it's been popular recently. Higher means more popular.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Usage">
            <summary>
            Statistics for user interactions with this package
            </summary>
        </member>
        <member name="P:Sandbox.Package.Favourited">
            <summary>
            Number of players who added this package to their favourites.
            </summary>
        </member>
        <member name="P:Sandbox.Package.VotesUp">
            <summary>
            Number of players who voted this package up.
            </summary>
        </member>
        <member name="P:Sandbox.Package.VotesDown">
            <summary>
            Number of players who voted this package down.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Source">
            <summary>
            Link to this package's sources, if set.
            </summary>
        </member>
        <member name="P:Sandbox.Package.ApiVersion">
            <summary>
            For game extension compatibility. Game targeting extensions are only compatible with that game
            if the API Versions match.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Screenshots">
            <summary>
            A list of screenshots
            </summary>
        </member>
        <member name="P:Sandbox.Package.Screenshot.IsVideo">
            <summary>
            True if this is a loading screen rather than a regular screenshot
            </summary>
        </member>
        <member name="M:Sandbox.Package.Screenshot.GetThumbUrl(System.Int32,System.Int32)">
            <summary>
            Return the URL of a thumbnail matching this exact size. For caching reasons it's going to be best if
            we can keep this to round number sizes (256, 512 etc) rather than trying to exact fit.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IsFavourite">
            <summary>
            True if this asset is in our favourite list.
            </summary>
        </member>
        <member name="P:Sandbox.Package.CanEdit">
            <summary>
            True if we're a member of this package's organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Url">
            <summary>
            A link to this asset on our backend
            </summary>
        </member>
        <member name="P:Sandbox.Package.Updated">
            <summary>
            When the entry was last updated. If these are different between packages
            then something updated on the backend.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Created">
            <summary>
            When the package was originally created.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Collections">
            <summary>
            How many collections we're in (roughly)
            </summary>
        </member>
        <member name="P:Sandbox.Package.Referencing">
            <summary>
            How many packages we're referencing (roughly)
            </summary>
        </member>
        <member name="P:Sandbox.Package.Referenced">
            <summary>
            How many packages we're referenced by (roughly)
            </summary>
        </member>
        <member name="P:Sandbox.Package.Reviews">
            <summary>
            Stats for the reviews. Gives the number of reviews, and the fraction of the total score.
            </summary>
        </member>
        <member name="P:Sandbox.Package.ErrorRate">
            <summary>
            What fraction of users got errors from this package in the last day
            </summary>
        </member>
        <member name="P:Sandbox.Package.LatestNewsPost">
            <summary>
            The latest news post created by this package
            </summary>
        </member>
        <member name="T:Sandbox.Package.Organization">
            <summary>
            Represents an organization on Asset Party. Organization owns packages.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Ident">
            <summary>
            Unique string that identifies this organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Title">
            <summary>
            Full or "nice" name of this organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.SocialTwitter">
            <summary>
            Link to Twitter of this organization, if set.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.SocialWeb">
            <summary>
            Link to the website of this organization, if set.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Description">
            <summary>
            Description of this organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Thumb">
            <summary>
            Link to the thumbnail image of this organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Created">
            <summary>
            When the organization was created.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.VersionId">
            <summary>
            Unique index of this revision.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.FileCount">
            <summary>
            Number of files in this revision.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.TotalSize">
            <summary>
            Total size of all the files in this revision, in bytes.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.Summary">
            <summary>
            A summary of the changes in this revision.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.Created">
            <summary>
            When this revision was created.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.EngineVersion">
            <summary>
            Engine version of this revision.
            TODO: How exactly is this different from <see cref="P:Sandbox.Package.EngineVersion"/>?
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.Manifest">
            <summary>
            Manifest of the revision, describing what files are available. For this to be available
            you should call DownloadManifestAsync first.
            </summary>
        </member>
        <member name="M:Sandbox.Package.IRevision.DownloadManifestAsync(System.Threading.CancellationToken)">
            <summary>
            The manifest will not be immediately available until you've downloaded it.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Revision">
            <summary>
            Information about the current package revision/version.
            </summary>
        </member>
        <member name="M:Sandbox.Package.IsNamed(System.String)">
            <summary>
            Returns true if the org and ident of the passed in ident matches this package
            </summary>
        </member>
        <member name="P:Sandbox.Package.Interaction">
            <summary>
            Describes the authenticated user's interactions with this package. This is only available
            clientside for specific users in order to show things like play history state, favourite
            status and whether they have rated the item or not.
            </summary>
        </member>
        <member name="P:Sandbox.Package.LoadingScreen">
            <summary>
            If this package is a game, it can provide media to show on the loading screen
            </summary>
        </member>
        <member name="P:Sandbox.Package.LoadingScreenSetup.MediaUrl">
            <summary>
            The URL to an image or video to use as a loading screen. The extension should reveal its type.
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetValue``1(System.String,``0)">
            <summary>
            Get a data value. These are usually set on the backend, and are package type specific. These are
            generally values that are used to configure behaviour in the menu system.
            </summary>
        </member>
        <member name="M:Sandbox.Package.FilterFileDownloads(Sandbox.ManifestSchema.File)">
            <summary>
            Don't blindly download every file in the manifest. We can filter them here.
            </summary>
        </member>
        <member name="M:Sandbox.Package.Download(System.Threading.CancellationToken,Sandbox.PackageLoadOptions)">
            <summary>
            Download a package to a temporary location and return a filesystem with its contents
            </summary>
        </member>
        <member name="M:Sandbox.Package.CheckFileCrc(System.String,Sandbox.ManifestSchema.File,System.Threading.CancellationToken)">
            <summary>
            Make sure this manifest file entry is what it says it is
            </summary>
        </member>
        <member name="M:Sandbox.Package.DownloadFileAsync(Sandbox.Package.FileDownloadEntry,Sandbox.PackageFileSystem,Sandbox.Utility.DataProgress.Callback,System.Threading.CancellationToken)">
            <summary>
            Download an individual file
            </summary>
        </member>
        <member name="M:Sandbox.Package.MountAsync(System.Boolean)">
            <summary>
            Download and mount this package. If withCode is true we'll try to load the assembly if it exists.
            </summary>
        </member>
        <member name="T:Sandbox.Package.Facet">
            <summary>
            Describes a facet of a group of items, with a limited
            number of each facet with their total item counts
            </summary>
        </member>
        <member name="M:Sandbox.Package.Facet.#ctor(System.String,System.String,Sandbox.Package.Facet.Entry[])">
            <summary>
            Describes a facet of a group of items, with a limited
            number of each facet with their total item counts
            </summary>
        </member>
        <member name="T:Sandbox.Package.Facet.Entry">
            <summary>
            A facet entry consists of a name, display information and the number of items inside
            </summary>
        </member>
        <member name="M:Sandbox.Package.Facet.Entry.#ctor(System.String,System.String,System.String,System.Int32,System.Collections.Generic.List{Sandbox.Package.Facet.Entry})">
            <summary>
            A facet entry consists of a name, display information and the number of items inside
            </summary>
        </member>
        <member name="T:Sandbox.Package.FindResult">
            <summary>
            A result from the call to FindAsync
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Milliseconds">
            <summary>
            The amount of time the query took
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Packages">
            <summary>
            A list of packages retrieved
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.TotalCount">
            <summary>
            The total amount of packages
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Facets">
            <summary>
            Facets particular to this search
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Tags">
            <summary>
            A list of tags relevant to this search
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Orders">
            <summary>
            A list of sort orders. There may be other sort orders, but we provide a list here that can
            be easily used to save rewriting the same code over and over.
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Properties">
            <summary>
            Binary options
            </summary>
        </member>
        <member name="T:Sandbox.Package.TagEntry">
            <summary>
            Represents a tag along with the count of items it contains
            </summary>
        </member>
        <member name="M:Sandbox.Package.TagEntry.#ctor(System.String,System.Int32)">
            <summary>
            Represents a tag along with the count of items it contains
            </summary>
        </member>
        <member name="T:Sandbox.Package.SortOrder">
            <summary>
            Describes a sort order which can be used with the package/find api
            </summary>
        </member>
        <member name="M:Sandbox.Package.SortOrder.#ctor(System.String,System.String,System.String)">
            <summary>
            Describes a sort order which can be used with the package/find api
            </summary>
        </member>
        <member name="T:Sandbox.Package.PackageProperty">
            <summary>
            A binary category used to divide into two categories. For example, Work In Progress.
            </summary>
        </member>
        <member name="M:Sandbox.Package.PackageProperty.#ctor(System.String,System.String,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            A binary category used to divide into two categories. For example, Work In Progress.
            </summary>
        </member>
        <member name="T:Sandbox.Package.ListResult">
            <summary>
            Represents the actual response from the api
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Title">
            <summary>
            The name of this group
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Groupings">
            <summary>
            The groups of packages
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Grouping.Title">
            <summary>
            The title of this group
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Grouping.Icon">
            <summary>
            The icon of this group
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Grouping.Style">
            <summary>
            The style of this group
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Grouping.QueryString">
            <summary>
            Link to get a full list of this category
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Grouping.Packages">
            <summary>
            The packages in this group
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetMeta``1(System.String,``0)">
            <summary>
            Get metadata value from this package for given key. This will be specific to each <see cref="T:Sandbox.Package.Type"/>.
            </summary>
            <typeparam name="T">Type of the metadata value. This should be something that can be serialized by JSON.</typeparam>
            <param name="keyName">The name of the key to look up.</param>
            <param name="defaultValue">Default value to return when requested key was not present in the package's metadata.</param>
        </member>
        <member name="M:Sandbox.Package.GetCachedMeta``1(System.String,``0)">
            <summary>
            <see cref="M:Sandbox.Package.GetMeta``1(System.String,``0)"/> but with cache.
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetCachedMeta``1(System.String,System.Func{``0})">
            <summary>
            <see cref="M:Sandbox.Package.GetMeta``1(System.String,``0)"/> but with cache.
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetIdent(System.Boolean,System.Boolean)">
            <summary>
            Get the full ident with your choice of fidelity
            </summary>
        </member>
        <member name="M:Sandbox.Package.IsMounted">
            <summary>
            Check if the package is installed and mounted
            </summary>
        </member>
        <member name="M:Sandbox.Package.ClearCache(System.String)">
            <summary>
            Remove a specific package from the cache
            </summary>
        </member>
        <member name="M:Sandbox.Package.TryParseIdent(System.String,System.ValueTuple{System.String,System.String,System.Nullable{System.Int32},System.Boolean}@)">
            <summary>
            Parse a package ident into parts. There are a few different formats you can pass to this.
            
             - org/package
             - org.package
             - org.package#version
             - https://sbox.game/org/package
             - https://sbox.game/org/package#version
             
             If package version isn't specified version will be null
            
            </summary>
        </member>
        <member name="M:Sandbox.Package.FormatIdent(System.String,System.String,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Produces a package ident of the form <c><paramref name="org"/>.<paramref name="package"/>[#<paramref name="local"/>|#<paramref name="version"/>]</c>.
            </summary>
        </member>
        <member name="M:Sandbox.Package.FetchAsync(System.String,System.Boolean)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="M:Sandbox.Package.FetchAsync(System.String,System.Boolean,System.Boolean)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="M:Sandbox.Package.TryGetCached(System.String,Sandbox.Package@,System.Boolean)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="M:Sandbox.Package.Fetch(System.String,System.Boolean)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetCachedTitle(System.String)">
            <summary>
            If we have this package information, try to get its name
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetMockPackages(System.String)">
            <summary>
            These packages are created from local addons, and should be the only way 99% of systems interact with local addons.
            </summary>
        </member>
        <member name="M:Sandbox.Package.FindAsync(System.String,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Retrieve a list of packages
            </summary>
        </member>
        <member name="M:Sandbox.Package.ListAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Retrieve a list of packages, organised into groups, for discovery
            </summary>
        </member>
        <member name="M:Sandbox.Package.SortByReferences(System.Collections.Generic.IEnumerable{Sandbox.Package})">
            <summary>
            Sort the given list of packages so that referenced packages are ordered before the packages that reference them.
            </summary>
            <param name="unordered">Unordered list of packages.</param>
            <returns>A new enumerable, ordered to maintain references.</returns>
        </member>
        <member name="M:Sandbox.Package.SortByReferences``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Sandbox.Package})">
            <summary>
            Sort the given list of items so that referenced packages are ordered before the packages that reference them.
            </summary>
            <param name="unordered">Unordered list of items with a corresponding package.</param>
            <param name="getPackageFunc">Delegate that maps each item to its corresponding package.</param>
            <returns>A new enumerable, ordered to maintain references.</returns>
        </member>
        <member name="M:Sandbox.Package.FetchVersions(System.String,System.Threading.CancellationToken)">
            <summary>
            Get package version list
            </summary>
        </member>
        <member name="T:Sandbox.LoadedAssembly">
            <summary>
            An assembly that has been loaded into a PackageLoader.
            </summary>
        </member>
        <member name="P:Sandbox.LoadedAssembly.ModifiedAssembly">
            <summary>
            If not null, this is an assembly that was created by Fast Hotload
            </summary>
        </member>
        <member name="T:Sandbox.PackageLoader">
            <summary>
            Handles the loading of package assemblies into a loadcontext.
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoader.AccessControl">
            <summary>
            The library used to load assemblies
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoader.ToolsMode">
            <summary>
            In tools mode we don't register events unless they're from a tools project
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoader.DisableAccessControl">
            <summary>
            Disables access control on all loaded local packages, but not remote packages.
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.#ctor(System.String,System.Reflection.Assembly,System.Boolean)">
            <summary>
            Called on Game Loop Init
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.TestAccessControl(System.IO.Stream,Sandbox.TrustedBinaryStream@)">
            <summary>
            Make sure we should be able to load this dll
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.TryFastHotload(Sandbox.LoadedAssembly,Sandbox.LoadedAssembly)">
            <summary>
            If successful, will change outgoing in place and return true
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.HasOldReferencedAssemblyUnloaded(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            Return true if, between <paramref name="incoming"/> and <paramref name="outgoing"/>,
            package references are added or removed, or a package reference changes version and wasn't fast-hotloaded itself.
            If either is the case, the incoming assembly can't be fast-hotloaded because the types it references have changed.
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.EmitFastHotloadEvent(Sandbox.LoadedAssembly)">
            <summary>
            Trigger a switch event
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.TriggerRegisterEvent(Sandbox.LoadedAssembly)">
            <summary>
            Trigger a switch event
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.TriggerUnregisterEvent(Sandbox.LoadedAssembly)">
            <summary>
            Trigger a switch event
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.GetLoadedAssemblies(System.String,System.Boolean,System.Boolean)">
            <summary>
            Called by Enroller to get the assemblies associated with a package. If deep is true then
            this should return all assemblies needed by this package and its dependencies.
            </summary>
        </member>
        <member name="T:Sandbox.PackageLoader.Enroller">
            <summary>
            Holds a list of assemblies with the intention of enrolling them into
            services like TypeLibrary, Event. Handles deduplication and switching due to 
            hotloading etc..
            </summary>
        </member>
        <member name="F:Sandbox.PackageLoader.Enroller.loaded">
            <summary>
            All of the assembles loaded into this enroller
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.GetLoadedAssemblies">
            <summary>
            Get all of the loaded assemblies. This is only to be used when sending 
            assemblies to children.
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.OnHotloadEvent(Sandbox.LoadedAssembly)">
            <summary>
            Called by PackageLoader when the assembly has undergone a fast hotload
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.OnRegisterEvent(Sandbox.LoadedAssembly)">
            <summary>
            Called after hotload, to register a swapped assembly
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.OnUnregisterEvent(Sandbox.LoadedAssembly)">
            <summary>
            Called after hotload, to register a swapped assembly
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.Add(Sandbox.LoadedAssembly)">
            <summary>
            Called internally on all the assemblies when a package is loaded.
            This then calls down to all of the listeners, to let them know.
            </summary>
        </member>
        <member name="T:Sandbox.PackageLoadOptions">
            <summary>
            General options that are usable whenever we load a package
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoadOptions.Default">
            <summary>
            Mounts assets from the package, but does not compile or load any code.
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoadOptions.PackageIdent">
            <summary>
            The ident of the package to load
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoadOptions.ContextTag">
            <summary>
            A group tag for this package, so we can unload all packages using this tag
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoadOptions.CancellationToken">
            <summary>
            For cancelling the task
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoadOptions.AllowLocalPackages">
            <summary>
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoadOptions.SkipAssetDownload">
            <summary>
            If true we will only download the code files (.bin) and not the assets.
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoadOptions.Loading">
            <summary>
            Loading progress callbacks
            </summary>
        </member>
        <member name="T:Sandbox.PackageManager.ActivePackage">
            <summary>
            Describes a package that is currently mounted. Mounted packages are shared between client, server and editor.
            We keep track of which host is using which package using Tags.
            </summary>
        </member>
        <member name="P:Sandbox.PackageManager.ActivePackage.ProjectSettings">
            <summary>
            The project settings folder
            </summary>
        </member>
        <member name="P:Sandbox.PackageManager.ActivePackage.Localization">
            <summary>
            The project's localization folder
            </summary>
        </member>
        <member name="F:Sandbox.PackageManager.ActivePackage.memoryFileSystem">
            <summary>
            Mounted on FileSystem, this is where the codearchive is mounted to
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.ActivePackage.DownloadAsync(System.Threading.CancellationToken,Sandbox.PackageLoadOptions)">
            <summary>
            Set the filesystem up from this downloaded asset
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.ActivePackage.Delete">
            <summary>
            Called to unmount and remove this package from being active
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.CmdList">
            <summary>
            List all currently active packages
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.CmdAdd(System.String,System.String)">
            <summary>
            Install a package in the specific context
            </summary>
            <param name="package">The package ident</param>
            <param name="context">The context (ie, client, server)</param>
        </member>
        <member name="M:Sandbox.PackageManager.CmdWipe(System.String)">
            <summary>
            Unmount all packages that use a specific tag. This is usually done on leaving a game for client and server
            </summary>
        </member>
        <member name="E:Sandbox.PackageManager.OnPackageInstalledToContext">
            <summary>
            Called when a new package is installed
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.InstallAsync(Sandbox.PackageLoadOptions)">
            <summary>
            Install a package
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.InstallProjects(Sandbox.Project[],System.Threading.CancellationToken)">
            <summary>
            Install all of the projects as packages
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.Find(System.String)">
            <summary>
            Retrieve a package by ident.
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.Find(System.String,System.Boolean,System.Boolean)">
            <summary>
            Retrieve a package by ident and minimum download mode.
            </summary>
        </member>
        <member name="M:Sandbox.PackageRevision.DownloadManifestAsync(System.Threading.CancellationToken)">
            <summary>
            The manifest might not be immediately available until you've downloaded it
            </summary>
        </member>
        <member name="M:Sandbox.RemotePackage.GetValue``1(System.String,``0)">
            <summary>
            Get a data value. These are usually set on the backend, and are package type specific. These are
            generally values that are used to configure behaviour in the menu system.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioEngine">
            <summary>
            A mix frame size is 512 samples
            A second is made up of 44100 samples
            This means one frame is about 11.6ms
            So as long as mixing takes less than 10ms we're okay
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.ChannelCount">
            <summary>
            How many output channels do we have? Generally 2, but if they have a 7.1 setup it can be more.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.SecondsPerSample">
            <summary>
            How many seconds one sample lasts
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.SamplingRate">
            <summary>
            The engine's output sampling rate. This doesn't change.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.MixBufferSize">
            <summary>
            The size of one 
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioEngine.Tick">
            <summary>
            Called every frame. 
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioMeter">
            <summary>
            Allows the capture and monitor of an audio source
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioMeter.Frame.VoiceCount">
            <summary>
            The amount of individual voices playing
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioSampler">
            <summary>
            A wrapper around CAudioMixer, which is used in c++ to read from a wav etc.
            This has two parts. 
            
             o Sample - reads the samples, advances the index
             o GetSamples - returns the samples.
             
            The reason it's coded like this is because each mix frame we read all samples, then
            the mixers can do whatever they want with them. So rather than have the mixers fight
            over reading and advancing, they can all get the samples if they want to.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioSampler.Sample(System.Single)">
            <summary>
            Read samples to our internal buffer and advance the index. 
            Pitch should be default 1.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioSampler.GetLastReadSamples">
            <summary>
            Get the last read samples. This is called by the mixers.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.MixBuffer">
            <summary>
            Contains 512 samples of audio data, this is used when mixing a single channel
            </summary>
        </member>
        <member name="F:Sandbox.Audio.MixBuffer._external">
            <summary>
            If true, this buffer pointer is managed by something else
            </summary>
        </member>
        <member name="F:Sandbox.Audio.MixBuffer._locked">
            <summary>
            This is locked from being disposed
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixBuffer.Silence">
            <summary>
            Silence this buffer
            </summary>
        </member>
        <member name="P:Sandbox.Audio.MixBuffer.Buffer">
            <summary>
            Get direct access to the memory
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixBuffer.CopyFrom(Sandbox.Audio.MixBuffer)">
            <summary>
            Set this buffer to this value 
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixBuffer.MixFrom(Sandbox.Audio.MixBuffer,System.Single)">
            <summary>
            Mix this buffer with another
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixBuffer.MixFrom(Sandbox.Audio.MultiChannelBuffer,System.Single)">
            <summary>
            Mix this buffer with another
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixBuffer.Scale(System.Single)">
            <summary>
            Scale the buffer by volume
            </summary>
        </member>
        <member name="T:Sandbox.Audio.MultiChannelBuffer">
            <summary>
            Holds up to 8 mix buffers, which usually represent output speakers.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.MultiChannelBuffer.ChannelCount">
            <summary>
            How many channels do we have
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.Dispose">
            <summary>
            Delete and release all resources. Cannot be used again.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.Get(Sandbox.Audio.AudioChannel)">
            <summary>
            Get MixBuffer number i
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.Get(System.Int32)">
            <summary>
            Get MixBuffer number i
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.Silence">
            <summary>
            Silence all buffers
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.CopyFrom(Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Set this buffer to this value 
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.CopyFromUpmix(Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Copies from one buffer to the other. If the other has less channels, we'll upmix
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.MixFrom(Sandbox.Audio.MultiChannelBuffer,System.Single)">
            <summary>
            Mix the target buffer into this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.Scale(System.Single)">
            <summary>
            Scale volume of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.SendToOutput">
            <summary>
            Send to device output
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.ToMono(Sandbox.Audio.MixBuffer,System.Single)">
            <summary>
            Mix each channel into the single buffer, using passed in volume
            </summary>
        </member>
        <member name="T:Sandbox.Audio.DspInstance">
            <summary>
            An instance of a DspPreset. The actual processor creates one of these from
            a DspPreset, and then uses it to process the audio buffers.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.DspPreset">
            <summary>
            Defines a DSP preset. This is a collection of DSP processors that can be applied to a sound.
            These originate from Half-Life 1's DSP system, and give that iconic Source Engine Sound.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.DspPresetHandle">
            <summary>
            A handle to a DspPreset
            </summary>
        </member>
        <member name="T:Sandbox.Audio.Listener">
            <summary>
            Listens for sounds in a scene.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Listener.Active">
            <summary>
            Currently active listeners.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Listener.Removed">
            <summary>
            Listener's that have been removed this frame.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Listener.RemoveQueue">
            <summary>
            For the mixing thread to know which listeners have been removed.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Listener.Transform">
            <summary>
            Listener's world transform, where we are listening to sounds from.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Listener.MixTransform">
            <summary>
            Mixer thread safe transform.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Listener.Position">
            <summary>
            Listener's world position, where we are listening to sounds from.
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Listener.Scene">
            <summary>
            Scene this listener belongs to.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Listener.GetActive(System.Collections.Generic.List{Sandbox.Audio.Listener})">
            <summary>
            Get active sound listener states.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.Mixer">
            <summary>
            Takes a bunch of sound, changes its volumes, mixes it together, outputs it
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Meter">
            <summary>
            Allows monitoring of the output of the mixer
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Id">
            <summary>
            Unique identifier for this object, for lookup, deserialization etc
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._outputBuffer">
            <summary>
            Final mixed output buffer containing audio from all listeners.
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._outputBuffers">
            <summary>
            Per-listener audio buffers mixed into the final output buffer.
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._usedListeners">
            <summary>
            Tracks which listener buffers were used during the current frame.
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._listeners">
            <summary>
            We don't want to access sound listeners directly, because it might keep changing
            in the other thread. This is a local copy for us to use.
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._removedListeners">
            <summary>
            Id of listeners that have been removed so we can dispose of their buffers.
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._voiceCount">
            <summary>
            The current voices playing on this mixer
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Output">
            <summary>
            Final mixed output buffer containing audio from all listeners.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Name">
            <summary>
            The display name for this mixer
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Volume">
            <summary>
            Scale the volume of our output by this amount
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.MaxVoices">
            <summary>
            The maximum amount of voices to play at one time on this mixer
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.OverrideOcclusion">
            <summary>
            If true then this mixer will use custom occlusion tags. If false we'll use what our parent uses.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.OcclusionTags">
            <summary>
            The tags which occlude our physics
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.GetOcclusionTags">
            <summary>
            Get an array of occlusion tags our sounds want to hit. May return null if there are none defined!
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Spacializing">
            <summary>
            When 0 the sound will come out of all speakers, when 1 it will be fully spacialized
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.DistanceAttenuation">
            <summary>
            Sounds get quieter as they go further away
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Occlusion">
            <summary>
            How much these sounds can get occluded
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.AirAbsorption">
            <summary>
            How much the air absorbs energy from the sound
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Solo">
            <summary>
            Should this be the only mixer that is heard?
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Mute">
            <summary>
            Is this mixer muted?
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.IsMaster">
            <summary>
            The default mixer gets all sounds that don't have a mixer specifically assigned
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.StartMixing(System.Collections.Generic.IReadOnlyList{Sandbox.Audio.Listener},System.Collections.Generic.IReadOnlyList{Sandbox.Audio.Listener})">
            <summary>
            Called at the start of the mixing frame
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.MixChildren(System.Collections.Generic.List{Sandbox.SoundHandle})">
            <summary>
            Mix the child mixes
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.MixVoices(System.Collections.Generic.List{Sandbox.SoundHandle})">
            <summary>
            Mix the incoming voices into the mix
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.FinishMixing">
            <summary>
            Mixing is finished. Clean up and finalize
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.MixVoice(Sandbox.SoundHandle)">
            <summary>
            Mix a single voice
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.ConvertToBinaural(Sandbox.Audio.SteamAudioSource,Sandbox.Audio.Listener,Sandbox.SoundHandle,Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            This will spatialize the voice based on its location
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.StopAll(System.Single)">
            <summary>
            Stop all sound handles using this mixer
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.FindMixerByName(Sandbox.Audio.Mixer,System.String)">
            <summary>
            We might want to do a fast lookup at some point
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.FindMixerByGuid(Sandbox.Audio.Mixer,System.Guid)">
            <summary>
            We might want to do a fast lookup at some point
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._processorList">
            <summary>
            Private, because we want to make this as thread safe as possible
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.AddProcessor(Sandbox.Audio.AudioProcessor)">
            <summary>
            Add a processor to the list
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.ClearProcessors">
            <summary>
            Add a processor to the list
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.RemoveProcessor(Sandbox.Audio.AudioProcessor)">
            <summary>
            Add a processor to the list
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.ProcessorCount">
            <summary>
            The amount of processors
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.GetProcessors">
            <summary>
            Get the current processor list
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.GetProcessor``1">
            <summary>
            Get the first processor of a specific type, or null if not found
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.ApplyProcessors">
            <summary>
            Actually apply the processors to the output buffer
            </summary>
        </member>
        <member name="T:Sandbox.Audio.MixerHandle">
            <summary>
            A handle to a Mixer
            </summary>
        </member>
        <member name="T:Sandbox.Audio.MixingThread">
            <summary>
            This is a real thread! We need to be very careful about what this accesses, and how.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixingThread.SampleVoices(System.Collections.Generic.List{Sandbox.SoundHandle})">
            <summary>
            Read one sample from each voice
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixingThread.FinishVoices(System.Collections.Generic.List{Sandbox.SoundHandle})">
            <summary>
            Mark any finished voices as finished
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioProcessor">
            <summary>
            Takes a bunch of samples and processes them. It's common for these to be chained together.
            It's also common for the processor to store state between calls.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioProcessor.Enabled">
            <summary>
            Is this processor active?
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioProcessor.Mix">
            <summary>
            Should we fade the influence of this processor in?
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioProcessor.Listener">
            <summary>
            The listener's position in this frame.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.Process(Sandbox.Audio.MultiChannelBuffer,Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Should process input into output
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.ProcessInPlace(Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Will process the buffer, and copy it back to output
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.ProcessEachChannel(Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Called internally to process each channel in a buffer
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.ProcessSingleChannel(Sandbox.Audio.AudioChannel,System.Span{System.Single})">
            <summary>
            For implementations that process each channel individually
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioProcessor.ListenerState">
            <summary>
            One of these is created for every listener that uses an audio processor.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.ListenerState.OnDestroy">
            <summary>
            Called when audio processor or the listener is removed.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioProcessor.TargetListener">
            <summary>
            Optionally target a listener, this processor will only run for a specific listener.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.SetListener(Sandbox.Audio.Listener)">
            <summary>
            Set current state for listener.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.RemoveListeners(System.Collections.Generic.IReadOnlyList{Sandbox.Audio.Listener})">
            <summary>
            Remove any states associated with these listeners.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioChannel">
            <summary>
            Represents an audio channel, between 0 and 7. This is used to index into buffers.
            This is used rather than an int to avoid unfortuate bugs.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.PerChannel`1">
            <summary>
            Stores a variable per channel
            </summary>
        </member>
        <member name="M:Sandbox.Audio.PerChannel`1.Get(Sandbox.Audio.AudioChannel)">
            <summary>
            Get the value in a channel
            </summary>
        </member>
        <member name="M:Sandbox.Audio.PerChannel`1.Set(Sandbox.Audio.AudioChannel,`0)">
            <summary>
            Set the value in a channel
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioProcessor`1">
            <summary>
            Audio processor that allows per listener state.
            </summary>
        </member>
        <member name="F:Sandbox.Audio.AudioProcessor`1._states">
            <summary>
            Per listener states.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioProcessor`1.CurrentState">
            <summary>
            Current state for listener.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor`1.SetListener(Sandbox.Audio.Listener)">
            <summary>
            Set current state for listener.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor`1.RemoveListeners(System.Collections.Generic.IReadOnlyList{Sandbox.Audio.Listener})">
            <summary>
            Remove any states associated with these listeners.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor`1.OnRemovedInternal">
            <summary>
            Destroy and clear all states.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.HighPassProcessor">
            <summary>
            Just a test - don't count on this sticking around
            </summary>
        </member>
        <member name="P:Sandbox.Audio.HighPassProcessor.Cutoff">
            <summary>
            Cutoff frequency of the high-pass filter (0 to 1, where 1 is Nyquist frequency).
            </summary>
        </member>
        <member name="M:Sandbox.Audio.HighPassProcessor.ProcessSingleChannel(Sandbox.Audio.AudioChannel,System.Span{System.Single})">
            <summary>
            Processes each channel individually using a simple one-pole high-pass filter.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.LowPassProcessor">
            <summary>
            Just a test - don't count on this sticking around
            </summary>
        </member>
        <member name="P:Sandbox.Audio.LowPassProcessor.Cutoff">
            <summary>
            Cutoff frequency for the low-pass filter (normalized 0 to 1).
            </summary>
        </member>
        <member name="M:Sandbox.Audio.LowPassProcessor.ProcessSingleChannel(Sandbox.Audio.AudioChannel,System.Span{System.Single})">
            <summary>
            Processes a single audio channel with a low-pass filter.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.DirectSource.Snap">
            <summary>
            Stop any lerping and jump straight to the target occlusion
            </summary>
        </member>
        <member name="M:Sandbox.Audio.DirectSource.ComputeOcclusion(Vector3,Vector3,System.Single,Sandbox.Audio.Mixer,Sandbox.PhysicsWorld)">
            <summary>
            Compute how occluded a sound is. Returns 0 if fully occluded, 1 if not occluded
            </summary>
        </member>
        <member name="T:Sandbox.Audio.SteamAudioSource">
            <summary>
            A source for the "direct" group of effects. This gets added to the SteamAudio scene and
            is simulated for things like occlusion.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.SteamAudioSource.ApplyDirectMix(Sandbox.Audio.Listener@,Sandbox.Audio.MultiChannelBuffer,Sandbox.Audio.MultiChannelBuffer,System.Single,System.Single)">
            <summary>
            Buffers should be mono in, mono out
            </summary>
        </member>
        <member name="M:Sandbox.Audio.SteamAudioSource.ApplyBinauralMix(Vector3,System.Single,Sandbox.Audio.MultiChannelBuffer,Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Buffers should be mono in, stereo out
            </summary>
        </member>
        <member name="M:Sandbox.Audio.SteamAudioSource.UpdateFrom(Sandbox.SoundHandle,Sandbox.PhysicsWorld,Vector3)">
            <summary>
            Called by the sound handle at the appropriate times to update the native source
            </summary>
        </member>
        <member name="T:Sandbox.Sound">
            <summary>
            Single source for creating sounds
            </summary>
        </member>
        <member name="P:Sandbox.Sound.Listener">
            <summary>
            Sound listener of the active scene.
            </summary>
        </member>
        <member name="P:Sandbox.Sound.MasterVolume">
            <summary>
            The user's preference for their field of view
            </summary>
        </member>
        <member name="M:Sandbox.Sound.Preload(System.String)">
            <summary>
            Precaches sound files associated with given sound event by name.
            This helps avoid stutters on first load of each sound file.
            </summary>
        </member>
        <member name="P:Sandbox.Sound.DspNames">
            <summary>
            Get a list of available DSP names
            </summary>
        </member>
        <member name="M:Sandbox.Sound.UncompressVoiceData(System.Byte[],System.Action{System.Memory{System.Int16}})">
            <summary>
            Uncompress the voice data
            </summary>
        </member>
        <member name="P:Sandbox.Sound.VoiceSampleRate">
            <summary>
            The sample rate for voice data
            </summary>
        </member>
        <member name="M:Sandbox.Sound.Play(Sandbox.SoundEvent,Vector3)">
            <summary>
            Play a sound and set its position
            </summary>
        </member>
        <member name="M:Sandbox.Sound.Play(System.String,Vector3)">
            <summary>
            Play a sound and set its position
            </summary>
        </member>
        <member name="M:Sandbox.Sound.Play(System.String,Sandbox.Audio.Mixer)">
            <summary>
            Play a sound and set its mixer
            </summary>
        </member>
        <member name="T:Sandbox.SoundHandle">
            <summary>
            A handle to a sound that is currently playing. You can use this to control the sound's position, volume, pitch etc.
            </summary>
        </member>
        <member name="F:Sandbox.SoundHandle._CreatedTime">
            <summary>
            RealTime that this sound was created
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Empty">
            <summary>
            An empty, do nothing sound, that we can return to avoid NREs
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Position">
            <summary>
            Position of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Rotation">
            <summary>
            The direction the sound is facing
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Transform">
            <summary>
            This sound's transform
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Volume">
            <summary>
            Volume of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Name">
            <summary>
            A debug name to help identify the sound
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.SpacialBlend">
            <summary>
            How 3d the sound should be. 0 means no 3d, 1 means fully
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Distance">
            <summary>
            How many units the sound can be heard from.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Falloff">
            <summary>
            The falloff curve for the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Fadeout">
            <summary>
            The fadeout curve for when the sound stops.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Pitch">
            <summary>
            Pitch of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.IsPlaying">
            <summary>
            Whether the sound is currently playing or not.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Paused">
            <summary>
            Whether the sound is currently paused or not.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Finished">
            <summary>
            Sound is done
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Reflections">
            <summary>
            Enable the sound reflecting off surfaces
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Occlusion">
            <summary>
            Allow this sound to be occluded by geometry etc
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.OcclusionRadius">
            <summary>
            The radius of this sound's occlusion, allow for partial occlusion
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.DistanceAttenuation">
            <summary>
            Should the sound fade out over distance
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.AirAbsorption">
            <summary>
            Should the sound get absorbed by air, so it sounds different at distance
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Transmission">
            <summary>
            Should the sound transmit through walls, doors etc
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.TargetMixer">
            <summary>
            Which mixer do we want to write to
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.SampleRate">
            <summary>
            How many samples per second?
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.TimeUntilFinished">
            <summary>
            Keep playing silently for a second or two, to finish reverb effect
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.TimeUntilFaded">
            <summary>
            Keep playing until faded out
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.IsFading">
            <summary>
            Have we started fading out?
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.IsStopped">
            <summary>
            True if the sound has been stopped
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Time">
            <summary>
            The current time of the playing sound in seconds.
            Note: for some formats seeking may be expensive, and some may not support it at all.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.ListenLocal">
            <summary>
            Place the listener at 0,0,0 facing 1,0,0.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Loopback">
            <summary>
            If true, then this sound won't be played unless voice_loopback is 1. The assumption is that it's the 
            local user's voice. Amplitude and visme data will still be available!
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Amplitude">
            <summary>
            Measure of audio loudness.
            </summary>
        </member>
        <member name="M:Sandbox.SoundHandle.WantsDefaultMixer">
            <summary>
            Return true if this has no mixer specified, so will use the default mixer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SoundHandle.IsTargettingMixer(Sandbox.Audio.Mixer)">
            <summary>
            Return true if we want to play on this mixer. Will return true if we have no
            mixer specified, and the provided mixer is the default.
            </summary>
        </member>
        <member name="M:Sandbox.SoundHandle.TickInternal">
            <summary>
            This is called on the main thread for all active voices
            </summary>
        </member>
        <member name="M:Sandbox.SoundHandle.Update">
            <summary>
            Called to push changes to a sound immediately, rather than waiting for the next tick.
            You should call this if you make changes to a sound.
            </summary>
        </member>
        <member name="M:Sandbox.SoundHandle.OnActive">
            <summary>
            Before we're added to the active list, we need to get some stuff straight
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.FollowParent">
            <summary>
            Update our position every frame relative to our parent
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LocalTransform">
            <summary>
            If we're following a parent, our position will be this relative to them.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Parent">
            <summary>
            If set with a parent and <cref name="FollowParent"/> is true, we will update our position to match the parent's world position. You can use <cref name="LocalTransform"/> to set an offset from the parent's position.
            Setting a parent also allows you to use GameObject.StopAllSounds on the parent to stop all sounds that are following it.
            This is set automatically when calling <cref name="GameObject.PlaySound"/> on a GameObject, but you can set it manually if you want to change the parent of an existing sound handle.
            </summary>
        </member>
        <member name="M:Sandbox.SoundHandle.ClearParent">
            <summary>
            Clear our parent - stop following
            </summary>
        </member>
        <member name="M:Sandbox.SoundHandle.SetParent(Sandbox.GameObject)">
            <summary>
            Tell the SoundHandle to follow this GameObject's position
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSync">
            <summary>
            Access lipsync processing.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.Visemes">
            <summary>
            A list of 15 lipsync viseme weights. Requires <see cref="P:Sandbox.SoundHandle.LipSyncAccessor.Enabled"/> to be true.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.FrameNumber">
            <summary>
            Count from start of recognition.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.FrameDelay">
            <summary>
            Frame delay in milliseconds.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.LaughterScore">
            <summary>
            Laughter score for the current audio frame.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.Enabled">
            <summary>
            Enables lipsync processing.
            </summary>
        </member>
        <member name="P:Sandbox.SoundStream.SampleRate">
            <summary>
            Number of samples per second, as set during its creation.
            </summary>
        </member>
        <member name="P:Sandbox.SoundStream.Channels">
            <summary>
            Number of audio channels, as set during its creation.
            </summary>
        </member>
        <member name="M:Sandbox.SoundStream.Play(System.Single,System.Single)">
            <summary>
            Play sound of the stream.
            </summary>
        </member>
        <member name="M:Sandbox.SoundStream.Play(System.Single,System.Single,System.Single)">
            <summary>
            Play sound of the stream.
            </summary>
        </member>
        <member name="T:Sandbox.Speech.SpeechRecognitionResult">
            <summary>
            A result from speech recognition.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.SpeechRecognitionResult.Confidence">
            <summary>
            From 0-1 how confident are we that this is the correct result?
            </summary>
        </member>
        <member name="P:Sandbox.Speech.SpeechRecognitionResult.Text">
            <summary>
            The text result from speech recognition.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.SpeechRecognitionResult.Success">
            <summary>
            Did we successfully find a match?
            </summary>
        </member>
        <member name="T:Sandbox.Speech.Recognition.OnSpeechResult">
            <summary>
            Called when we have a result from speech recognition.
            </summary>
            <param name="result"></param>
        </member>
        <member name="P:Sandbox.Speech.Recognition.IsListening">
            <summary>
            Whether or not we are currently listening for speech.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.Recognition.IsSupported">
            <summary>
            Whether or not speech recognition is supported and a language is available.
            </summary>
        </member>
        <member name="M:Sandbox.Speech.Recognition.Start(Sandbox.Speech.Recognition.OnSpeechResult,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Start listening for speech to recognize as text. When speech has been recognized the callback
            will be invoked, the callback will also be invoked if recognition fails.
            </summary>
            <param name="callback">
            A callback that will be invoked when recognition has finished.
            </param>
            <param name="choices">
            An array of possible choices. If specified, the closest match will be chosen and passed to
            the callback.
            </param>
        </member>
        <member name="M:Sandbox.Speech.Recognition.Stop">
            <summary>
            Stop any active listening for speech.
            </summary>
        </member>
        <member name="T:Sandbox.Speech.Synthesizer">
            <summary>
            A speech synthesis stream. Lets you write text into speech and output it to a <see cref="T:Sandbox.SoundHandle"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.Synthesizer.OnVisemeReachedEvent">
            <summary>
            Called by SpeechSynthesizer to populate viseme data.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.Synthesizer.InstalledVoices">
            <summary>
            Gets a list of currently installed voices on the user's system.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.Synthesizer.CurrentVoice">
            <summary>
            Gets the current voice being used by <see cref="F:Sandbox.Speech.Synthesizer.SpeechSynthesizer"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.TrySetVoice(System.String)">
            <summary>
            Tries to set the voice to a matching voice name installed on the user's system.
            </summary>
            <param name="voiceName"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.TrySetVoice(System.String,System.String)">
            <summary>
            Tries to set the voice matching gender and age criteria.
            </summary>
            <param name="gender"></param>
            <param name="age"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.WithText(System.String)">
            <summary>
            Adds some text to the speech.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.OnVisemeReached(System.Action{System.Int32,System.TimeSpan})">
            <summary>
            Registers an action to fetch all viseme data.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.WithRate(System.Int32)">
            <summary>
            Sets the playback rate of the synthesizer.
            </summary>
            <param name="rate"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.WithBreak">
            <summary>
            Adds a break to the speech.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.Play">
            <summary>
            Takes info from <see cref="F:Sandbox.Speech.Synthesizer.Builder"/> and creates a <see cref="T:System.Speech.Synthesis.SpeechSynthesizer"/>, outputting to a stream object.
            Using <see cref="T:Sandbox.Speech.Synthesizer.AudioStreamHelpers"/> we then read all the PCM samples, and write it to a SoundStream.
            This means it'll work like any other sound.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Sandbox.Speech.Synthesizer.AudioStreamHelpers">
            <summary>
            A collection of helper methods to help read PCM samples. Taken mostly from https://github.com/Facepunch/sbox-arcade/
            </summary>
        </member>
        <member name="P:Sandbox.Command.IsSaved">
            <summary>
            Saved into config file
            </summary>
        </member>
        <member name="P:Sandbox.Command.IsProtected">
            <summary>
            If true then this cannot be interacted with via game code
            </summary>
        </member>
        <member name="P:Sandbox.Command.IsServer">
            <summary>
            If true then this command can only be run on the server
            </summary>
        </member>
        <member name="P:Sandbox.Command.IsAdmin">
            <summary>
            If true then this command can only be run by a server administrator
            </summary>
        </member>
        <member name="P:Sandbox.Command.IsReplicated">
            <summary>
            Server value is replicated to clients
            </summary>
        </member>
        <member name="P:Sandbox.Command.IsHidden">
            <summary>
            Not visible in auto complete and find
            </summary>
        </member>
        <member name="P:Sandbox.Command.IsUserInfo">
            <summary>
            Client values are sent to the server, accessible via Connection userinfo
            </summary>
        </member>
        <member name="P:Sandbox.Command.IsCheat">
            <summary>
            Can't access unless sv_cheats is 1
            </summary>
        </member>
        <member name="M:Sandbox.Command.SetVariableFromCommandLine">
            <summary>
            If we have a command line version of the command then set it and return true
            </summary>
        </member>
        <member name="M:Sandbox.ManagedCommand.GetAutoComplete(System.String)">
            <summary>
            Todo: Add support for managed commands to return shit here
            Todo: We could maybe do this in a cool way, using parameters?
                  So that for example, we could list players if it's a player etc
            </summary>
        </member>
        <member name="T:Sandbox.ConsoleSystem">
            <summary>
            A library to interact with the Console System.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.SetValue(System.String,System.Object)">
            <summary>
            Try to set a console variable. You will only be able to set variables that you have permission to set.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.GetValue(System.String,System.String)">
            <summary>
            Get a console variable's value as a string.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.OnChangePropertySet``1(Sandbox.WrappedPropertySet{``0}@)">
            <summary>
            Invoke a method when a property with [Change] is changed.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.OnWrappedSet``1(Sandbox.WrappedPropertySet{``0}@)">
            <summary>
            When we update a ConVar in code, call the ConsoleSystem.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.OnWrappedGet``1(Sandbox.WrappedPropertyGet{``0}@)">
            <summary>
            When we query a convar property
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.Run(System.String)">
            <summary>
            Run this command. This should be a single command.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.Run(System.String,System.Object[])">
            <summary>
            Run this command, along with the arguments. We'll automatically convert them to strings and handle quoting.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.RunInternal(Sandbox.ConsoleSystem.ConsoleCommand)">
            <summary>
            Actually do the business of trying to run a command. Will return (not throw) an exception
            object if an exception is thrown of command isn't found.
            </summary>
        </member>
        <member name="P:Sandbox.ConVarSystem.ConVarChanged">
            <summary>
            Called when the ConVar is changed.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.AddAssembly(System.Reflection.Assembly,System.String,System.String)">
            <summary>
            Add this assembly to the console library, which will scan it for console commands and make them available.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.RemoveAssembly(System.Reflection.Assembly)">
            <summary>
            Remove this assembly and its console commands.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.AddCommand(Sandbox.Command)">
            <summary>
            Add this command to the library. Any existing commands named the same will be over-written.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.AddConVar(Sandbox.Command)">
            <summary>
            Add this ConVar to the library. Any existing commands named the same will be over-written.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.GetValue(System.String,System.String,System.Boolean)">
            <summary>
            Get a ConVar value as a string.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.GetInt(System.String,System.Int32,System.Boolean)">
            <summary>
            Get a ConVar value as an integer. If the ConVar value is a boolean, this will return
            the value in its integer form.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.GetFloat(System.String,System.Single,System.Boolean)">
            <summary>
            Get a ConVar value as a float.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.SetValue(System.String,System.String,System.Boolean)">
            <summary>
            Try to set a ConVar. You will only be able to set variables that you have permission to set.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.SetInt(System.String,System.Int32,System.Boolean)">
            <summary>
            Try to set a ConVar. You will only be able to set variables that you have permission to set.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.SetFloat(System.String,System.Single,System.Boolean)">
            <summary>
            Try to set a ConVar. You will only be able to set variables that you have permission to set.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.SaveAll">
            <summary>
            Save all the convars.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.RunSingle(System.String)">
            <summary>
            Run a single command. [command] [args]
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.Run(System.String)">
            <summary>
            Run a potential string of commands, seperated by newlines or ;
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.OnConVarChanged``1(System.String,``0,``0)">
            <summary>
            Should be called any time a ConVar is changed. This should be called from two places, the managed side and the native side.
            Managed side comes from when the property value actually changes. The native side comes from a on change callback.
            CAVEAT: This will only get called for ConVars that use CODEGEN!
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.RegisterNativeVar(NativeEngine.ConVar)">
            <summary>
            Called from native as a result of calling RefreshNativeVariables
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.RegisterNativeCommand(NativeEngine.ConCommand)">
            <summary>
            Called from native as a result of calling RefreshNativeVariables
            </summary>
        </member>
        <member name="P:Sandbox.CookieItem.DeleteAt">
             <summary>
             If set to non 0, this key will be deleted at/after given time.
             This is useful in case you didn't open your game for more than 30 days (which is the default expiry time),
             and then you lose all your cookies because they all are expired and get deleted on launch.
            
             This way you have a 24 hour grace period.
             </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Dispose">
            <summary>
            Not public, not IDisposable. Don't want people to be able to do this from game.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.SetString(System.String,System.String)">
            <summary>
            Set a cookie to be stored between sessions. The cookie will expire one month
            from when it was set.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.GetString(System.String,System.String)">
            <summary>
            Get a stored session cookie.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.TryGetString(System.String,System.String@)">
            <summary>
            Get a stored session cookie.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Get``1(System.String,``0)">
            <summary>
            Load JSON encodable data from cookies
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Set``1(System.String,``0)">
            <summary>
            Set JSON encodable object to data
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Remove(System.String)">
            <summary>
            Removes a cookie from the cache entirely
            </summary>
            <param name="key"></param>
        </member>
        <member name="T:Sandbox.AssetDownloadCache">
            <summary>
            Downloadeded assets go in the ".source2/assets" folder, where they are symlinked on demand
            for use by the engine.
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.Reset">
            <summary>
            Remove all symlinks, clear the filesystem
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.StoreFile(System.String,System.UInt64,System.Byte[])">
            <summary>
            We have downloaded an asset file. Store it for reuse in the future
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.TryMountFile(System.String,System.UInt64,System.Boolean@)">
            <summary>
            Try to mount the downloaded file with this path and crc. If it doesn't exist, return false
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.CreateCacheFilename(System.String,System.UInt64)">
            <summary>
            Makes sure the directory exists, and returns the relative path to this file
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.GetAbsolutePath(System.String,System.UInt64)">
            <summary>
            Generate the absolute path for this, whether it exists or not
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.IsLegalDownload(System.String)">
            <summary>
            Is a file an legal download or not (filter out executables etc)
            </summary>
        </member>
        <member name="P:Sandbox.EngineFileSystem.LibraryContent">
            <summary>
            Content from libraries. This only exists in editor.
            </summary>
        </member>
        <member name="P:Sandbox.EngineFileSystem.Assets">
            <summary>
            For tools, maintain a list of mounted addon content paths
            </summary>
        </member>
        <member name="P:Sandbox.EngineFileSystem.Temporary">
            <summary>
            A place to write files temporarily. This is stored in memory so 
            cleaning up after yourself is a good idea (!)
            </summary>
        </member>
        <member name="P:Sandbox.EngineFileSystem.EditorTemporary">
            <summary>
            The .source2/temp folder
            </summary>
        </member>
        <member name="P:Sandbox.EngineFileSystem.ProjectSettings">
            <summary>
            The folder holding the project's settings files
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.Initialize(System.String)">
            <summary>
            Don't try to use the filesystem until you've called this!
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.InitializeConfigFolder(System.String)">
            <summary>
            Setup Config parameter
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.InitializeAddonsFolder(System.String)">
            <summary>
            Setup Addons parameter (there's no reason for this to exist now?)
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.InitializeDownloadsFolder(System.String)">
            <summary>
            Setup Download folder
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.InitializeDataFolder(System.String)">
            <summary>
            Setup Addons parameter (there's no reason for this to exist now?)
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.Shutdown">
            <summary>
            Should only be called at the very death
            </summary>
        </member>
        <member name="T:Sandbox.FileSystem">
            <summary>
            A filesystem that can be accessed by the game.
            </summary>
        </member>
        <member name="M:Sandbox.FileSystem.NormalizeFilename(System.String)">
            <summary>
            Normalizes given file path so the game's filesystem can understand it. Fixes slashes and lowercases the file path.
            </summary>
            <param name="filepath">The file path to normalize</param>
            <returns>The normalized file path</returns>
        </member>
        <member name="P:Sandbox.FileSystem.Mounted">
            <summary>
            All mounted content.
            </summary>
        </member>
        <member name="P:Sandbox.FileSystem.Data">
            <summary>
            A subset of <see cref="P:Sandbox.FileSystem.OrganizationData"/> for custom gamemode data.
            </summary>
        </member>
        <member name="P:Sandbox.FileSystem.OrganizationData">
            <summary>
            A filesystem for custom data, per gamemode's organization.
            </summary>
        </member>
        <member name="F:Sandbox.FileSystem.Cache">
            <summary>
            A cached keystore that can be used for anything. This is stored in a global cache folder, and may be deleted at any time.
            </summary>
        </member>
        <member name="T:Sandbox.KeyStore">
            <summary>
            Allows storing files by hashed keys, rather than by actual filename. This is sometimes useful.
            </summary>
        </member>
        <member name="M:Sandbox.KeyStore.CreateGlobalCache">
            <summary>
            Creates a keystore which is in a global cache position. The folder can be 
            deleted at any time, and it's all fine and no-one cares.
            </summary>
        </member>
        <member name="M:Sandbox.KeyStore.Set(System.String,System.Byte[])">
            <summary>
            Store a bunch of bytes
            </summary>
        </member>
        <member name="M:Sandbox.KeyStore.Get(System.String)">
            <summary>
            Get stored bytes, or return null
            </summary>
        </member>
        <member name="M:Sandbox.KeyStore.TryGet(System.String,System.Byte[]@)">
            <summary>
            Get stored bytes, or return false
            </summary>
        </member>
        <member name="M:Sandbox.KeyStore.Exists(System.String)">
            <summary>
            Check if a key exists
            </summary>
        </member>
        <member name="M:Sandbox.KeyStore.Remove(System.String)">
            <summary>
            Remove a key
            </summary>
        </member>
        <member name="T:Sandbox.PackageFileSystem">
            <summary>
            A filesystem that redirects a package's local paths to the actual files in a download cache
            </summary>
        </member>
        <member name="M:Sandbox.PackageFileSystem.AddFile(System.String,System.UInt64)">
            <summary>
            Add a file to this redirect system
            </summary>
        </member>
        <member name="F:Sandbox.HotloadManager.PerTypeAssertThresholdMillis">
            <summary>
            Assert if any one type takes more than this duration to process, AND more than
            <see cref="F:Sandbox.HotloadManager.PerTypeAssertThresholdFraction"/> of the total time.
            </summary>
        </member>
        <member name="F:Sandbox.HotloadManager.PerTypeAssertThresholdFraction">
            <summary>
            Assert if any one type takes more than this fraction of the total time to process,
            AND more than <see cref="F:Sandbox.HotloadManager.PerTypeAssertThresholdMillis"/>.
            </summary>
        </member>
        <member name="M:Sandbox.HotloadManager.DoSwap">
            <summary>
            Does the actual hotload
            </summary>
        </member>
        <member name="M:Sandbox.HotloadManager.Replace(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            Lets the hotload system know that something has changed. If we detect that we are
            replacing a dll (instead of just adding one) we'll queue up a swap. We should still
            call this even if <paramref name="oldAssembly"/> or <paramref name="newAssembly"/>
            is null, since that will tell the hotload system to start / stop watching static
            members of the assembly.
            </summary>
        </member>
        <member name="P:Sandbox.Controller.Gyroscope">
            <summary>
            Gets a sensor reading from the device's gyroscope (if it has one)
            </summary>
        </member>
        <member name="P:Sandbox.Controller.Accelerometer">
            <summary>
            Gets a sensor reading from the device's accelerometer (if it has one)
            </summary>
        </member>
        <member name="P:Sandbox.Controller.LEDColor">
            <summary>
            Sets the color of the gamepad if supported
            </summary>
        </member>
        <member name="P:Sandbox.Controller.ControllerType">
            <summary>
            What type of controller is this?
            </summary>
        </member>
        <member name="P:Sandbox.Controller.GlyphVendor">
            <summary>
            Which glyph vendor are we using for this controller?
            - default "The default vendor type, which uses Xbox glyphs"
            - playstation
            - switch 
            </summary>
        </member>
        <member name="M:Sandbox.Controller.Rumble(System.Int32,System.Int32,System.Int32)">
            <summary>
            Rumbles the controller.
            </summary>
            <param name="leftMotor">The speed of the left motor, between 0 and 0xFFFF</param>
            <param name="rightMotor">The speed of the right motor, between 0 and 0xFFFF</param>
            <param name="duration">The duration of the vibration in ms</param>
        </member>
        <member name="M:Sandbox.Controller.RumbleTriggers(System.Int32,System.Int32,System.Int32)">
            <summary>
            Rumbles the controller's triggers (if supported)
            </summary>
            <param name="leftTrigger">The speed of the left trigger motor, between 0 and 0xFFFF</param>
            <param name="rightTrigger">The speed of the right trigger motor, between 0 and 0xFFFF</param>
            <param name="duration">The duration of the vibration in ms</param>
        </member>
        <member name="M:Sandbox.Controller.StopAllHaptics">
            <summary>
            Stops all rumble and haptic events on this controller.
            </summary>
        </member>
        <member name="M:Sandbox.Controller.StopAllVibrations">
            <summary>
            Stop all vibration events on this controller.
            </summary>
        </member>
        <member name="M:Sandbox.Controller.TriggerHapticEffect(Sandbox.HapticEffect,System.Single,System.Single,System.Single)">
            <summary>
            Trigger a vibration based on a predefined <see cref="T:Sandbox.HapticPattern"/>.
            All <see cref="T:Sandbox.HapticPattern"/>s are normalized (start at 0, peak at 1).
            </summary>
            <param name="effect">The pattern to use</param>
            <param name="lengthScale">The amount to scale the pattern's length by.</param>
            <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
            <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
        </member>
        <member name="P:Sandbox.Controller.All">
            <summary>
            A list of all of the controllers, active and inactive.
            </summary>
        </member>
        <member name="P:Sandbox.Controller.First">
            <summary>
            Get the first controller that's connected (shortcut)
            </summary>
        </member>
        <member name="P:Sandbox.Controller.InputContext">
            <summary>
            The input context for this controller.
            </summary>
        </member>
        <member name="F:Sandbox.Controller.AXIS_RANGE">
            SDL reports values between this range
        </member>
        <member name="M:Sandbox.Controller.GetAxis(NativeEngine.GameControllerAxis,System.Single)">
            <summary>
            Get an axis
            </summary>
            <param name="axis"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="T:Sandbox.Controller.InputAxis">
            <summary>
            An axis
            </summary>
        </member>
        <member name="T:Sandbox.Input">
            <summary>
            Allows querying of player button presses and other inputs.
            </summary>
        </member>
        <member name="P:Sandbox.Input.CurrentPlayerScope">
            <summary>
            What's our current player index (for input scoping)?
            -1 is the default behavior, where it'll accept keyboard AND gamepad inputs.
            Anything above that, is targeting a specific controller.
            </summary>
        </member>
        <member name="P:Sandbox.Input.ControllerCount">
            <summary>
            How many controllers are active right now?
            </summary>
        </member>
        <member name="P:Sandbox.Input.EnableVirtualCursor">
            <summary>
            Whether or not the Virtual Cursor should show when using a controller. Disable this to control the cursor manually.
            </summary>
        </member>
        <member name="P:Sandbox.Input.CurrentController">
            <summary>
            Tries to find the current controller to use.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetAnalog(Sandbox.InputAnalog)">
            <summary>
            An analog input, when fetched, is between -1 and 1 (0 being default)
            </summary>
        </member>
        <member name="M:Sandbox.Input.ProcessControllerInput(System.Int32)">
            <summary>
            Processes controller inputs based on a player index (for input scoping). This can be called many times a frame.
            </summary>
        </member>
        <member name="M:Sandbox.Input.PlayerScope(System.Int32)">
            <summary>
            Push a specific player scope to be active
            </summary>
        </member>
        <member name="P:Sandbox.Input.UsingController">
            <summary>
            Was the last button pressed a game controller button?
            </summary>
        </member>
        <member name="P:Sandbox.Input.MissingActions">
            <summary>
            Missing action names that we've warned about already.
            This gets cleared when actions are initialized again.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetActionIndex(System.String)">
            <summary>
            We pack actions bit-by-bit in CUserCmd, using the index (which is shared between realms) to map it to an action.
            This is an accessor to grab that index easily from its action.
            </summary>
            <param name="actionName"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Input.GetActionIndex(Sandbox.InputAction)">
            <inheritdoc cref="M:Sandbox.Input.GetActionIndex(System.String)"/>
        </member>
        <member name="P:Sandbox.Input.EscapePressed">
            <summary>
            True if escape was pressed
            </summary>
        </member>
        <member name="M:Sandbox.Input.Down(System.String,System.Boolean)">
            <summary>
            Action is currently pressed down
            </summary>
        </member>
        <member name="M:Sandbox.Input.Pressed(System.String)">
            <summary>
            Action wasn't pressed but now it is
            </summary>
        </member>
        <member name="M:Sandbox.Input.Released(System.String)">
            <summary>
            Action was pressed but now it isn't
            </summary>
        </member>
        <member name="M:Sandbox.Input.SetAction(Sandbox.InputAction,System.Boolean)">
            <inheritdoc cref="M:Sandbox.Input.SetAction(System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Input.SetAction(System.String,System.Boolean)">
            <inheritdoc cref="M:Sandbox.Input.SetAction(System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Input.Clear(System.String)">
            <summary>
            Remove this action, so it's no longer being pressed.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Sandbox.Input.ClearActions">
            <summary>
            Clears the current input actions, so that none of them are active.
            </summary>
        </member>
        <member name="M:Sandbox.Input.ReleaseActions">
            <summary>
            Clears the current input actions, so that none of them are active. Unlike ClearActions
            this will unpress the buttons, so they won't be active again until they're pressed again.
            </summary>
        </member>
        <member name="M:Sandbox.Input.ReleaseAction(System.String)">
            <summary>
            Releases the action, and it won't be active again until it's pressed again.
            </summary>
        </member>
        <member name="M:Sandbox.Input.SetAction(System.Int32,System.Boolean)">
            <summary>
            Activates / Deactivates an action when building input.
            </summary>
            <param name="index"></param>
            <param name="down"></param>
        </member>
        <member name="M:Sandbox.Input.OnButton(NativeEngine.ButtonCode,System.String,System.Boolean)">
            <summary>
            Called when a compatible button is pressed.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetActions">
            <summary>
            Copies all input actions to be used publicly
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sandbox.Input.ActionNames">
            <summary>
            Names of all actions from the current game's input settings.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetGroupName(System.String)">
            <summary>
            Finds the <see cref="P:Sandbox.InputAction.GroupName"/> of the given action.
            </summary>
            <param name="action">Action name to find the group name of.</param>
        </member>
        <member name="M:Sandbox.Input.ReadConfig(Sandbox.InputSettings)">
            <summary>
            Read the config from this source
            </summary>
        </member>
        <member name="P:Sandbox.Input.CurrentContext">
            <summary>
            The current input context, pushed using Context.Push
            </summary>
        </member>
        <member name="P:Sandbox.Input.Contexts">
            <summary>
            Get all of the contexts
            </summary>
        </member>
        <member name="P:Sandbox.Input.Suppressed">
            <summary>
            If the input is suppressed then everything will act like there is no input
            </summary>
        </member>
        <member name="T:Sandbox.Input.Context">
            <summary>
            Allows tracking states of button changes and input deltas in a custom period (such as a tick) rather
            than in a per frame manner. This allows frame and tick to have legit data.
            </summary>
        </member>
        <member name="M:Sandbox.Input.Context.Flip">
            <summary>
            Copy accumulated values. Flip previous actions to current actions etc.
            </summary>
        </member>
        <member name="M:Sandbox.Input.Context.Push">
            <summary>
            Make this the current active context. You can optionally use the returned
            IDisposable to restore back to the previous context when you're done.
            </summary>
        </member>
        <member name="P:Sandbox.Input.VR">
            <summary>
            Virtual Reality specific input data.
            </summary>
        </member>
        <member name="P:Sandbox.Input.MouseDelta">
            <summary>
            Movement delta from the mouse.
            </summary>
        </member>
        <member name="P:Sandbox.Input.MouseWheel">
            <summary>
            The state of the mouse wheel.
            </summary>
        </member>
        <member name="P:Sandbox.Input.MouseCursorVisible">
            <summary>
            True if the mouse cursor is visible (using UI etc)
            </summary>
        </member>
        <member name="P:Sandbox.Input.AnalogLook">
            <summary>
            Analog look value from the default input device. This is scaled by Preferences.Sensitivity - so you don't need to scale it afterwards.
            </summary>
        </member>
        <member name="P:Sandbox.Input.AnalogMove">
            <summary>
            Analog move value from the default input device.
            </summary>
        </member>
        <member name="M:Sandbox.Input.Process">
            <summary>
            Called multiple times between ticks.
            </summary>
        </member>
        <member name="P:Sandbox.Input.MotionData">
            <summary>
            Current state of the current input device's motion sensor(s) if supported.
            This is only supported on: Dualshock 4+, Switch Controllers, Steam Controller, Steam Deck.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetButtonOrigin(Sandbox.InputAction,System.Boolean)">
            <inheritdoc cref="M:Sandbox.Input.GetButtonOrigin(System.String,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Input.GetButtonOrigin(System.String,System.Boolean)">
            <summary>
            Returns the name of a key bound to this InputAction
            <example>For example:
            <code>Input.GetButtonOrigin( "Undo" )</code>
            could return <c>SPACE</c> if using keyboard or <c>A Button</c> when using a controller.
            </example>
            </summary>
        </member>
        <member name="M:Sandbox.Input.LoadGlyphTexture(System.String,Sandbox.InputGlyphSize,System.Boolean)">
            <summary>
            Tries to load a glyph texture, will seek the current vendor controller (Xbox, PlayStation, Nintendo) and fall back to Xbox if not found.
            </summary>
            <param name="file"></param>
            <param name="size"></param>
            <param name="outline"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Input.GetButtonName(System.String)">
            <summary>
            Some keys can't be parsed by files because they're symbols, so we change them into something readable
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Input.GetGlyph(System.String,Sandbox.InputGlyphSize,System.Boolean)">
            <summary>
            Get a glyph texture from the controller bound to the action.
            If no binding is found will return an 'UNBOUND' glyph.
            </summary>
            <remarks>You should update your UI with this every frame, it's very cheap to call and context can change.</remarks>
        </member>
        <member name="M:Sandbox.Input.GetGlyph(System.String,Sandbox.InputGlyphSize,Sandbox.GlyphStyle)">
            <inheritdoc cref="M:Sandbox.Input.GetGlyph(System.String,Sandbox.InputGlyphSize,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Input.GetGlyph(Sandbox.InputAnalog,Sandbox.InputGlyphSize,System.Boolean)">
            <summary>
            Get a glyph texture from an analog input on a controller.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetButtonOrigin(Sandbox.InputAnalog)">
            <summary>
            Returns the name of the analog axis bound to this <see cref="T:Sandbox.InputAnalog"/>.
            <example>For example:
            <code>Input.GetButtonOrigin( InputAnalog.Move )</code>
            could return <c>Left Joystick</c>
            </example>
            </summary>
        </member>
        <member name="M:Sandbox.Input.TriggerHaptics(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Trigger a haptic event on supported controllers including Xbox trigger impulse rumble.
            </summary>
            <remarks>
            SDL will translate these commands into haptic pulses that should work on all controller types.
            </remarks>
            <param name="leftMotor">The speed of the left motor, between 0.0 and 1.0.</param>
            <param name="rightMotor">The speed of the right motor, between 0.0 and 1.0.</param>
            <param name="leftTrigger">(Xbox One controller only) The speed of the left trigger motor, between 0.0 and 1.0.</param>
            <param name="rightTrigger">(Xbox One controller only) The speed of the right trigger motor, between 0.0 and 1.0.</param>
            <param name="duration">How long (in milliseconds) should we apply this for?</param>
        </member>
        <member name="M:Sandbox.Input.TriggerHaptics(Sandbox.HapticEffect,System.Single,System.Single,System.Single)">
            <summary>
            Trigger haptics based on a predefined <see cref="T:Sandbox.HapticEffect"/>.
            All <see cref="T:Sandbox.HapticEffect"/>s are normalized (start at 0, peak at 1).
            </summary>
            <param name="pattern">The pattern to use</param>
            <param name="lengthScale">The amount to scale the pattern's length by.</param>
            <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
            <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
        </member>
        <member name="M:Sandbox.Input.TriggerHaptics(Sandbox.HapticEffect,System.Single,System.Single)">
            <summary>
            Trigger haptics based on a predefined <see cref="T:Sandbox.HapticEffect"/>.
            All <see cref="T:Sandbox.HapticEffect"/>s are normalized (start at 0, peak at 1).
            </summary>
            <param name="pattern">The pattern to use</param>
            <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
            <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
        </member>
        <member name="M:Sandbox.Input.StopAllHaptics">
            <summary>
            Stop all vibration events on the current controller.
            </summary>
        </member>
        <member name="M:Sandbox.Input.Keyboard.Down(System.String)">
            <summary>
            Keyboard key is held down
            </summary>
        </member>
        <member name="M:Sandbox.Input.Keyboard.Pressed(System.String)">
            <summary>
            Keyboard key wasn't pressed but now it is
            </summary>
        </member>
        <member name="M:Sandbox.Input.Keyboard.Released(System.String)">
            <summary>
            Keyboard key was pressed but now it isn't
            </summary>
        </member>
        <member name="T:Sandbox.InputAnalog">
            <summary>
            An analog input, when fetched, is between -1 and 1 (0 being default)
            </summary>
        </member>
        <member name="T:Sandbox.InputMotionData">
            <summary>
            Represents the current state of a device's motion sensor(s).
            </summary>
        </member>
        <member name="F:Sandbox.InputMotionData.Gyroscope">
            <summary>
            The raw value from the input device's gyroscope.
            </summary>
        </member>
        <member name="F:Sandbox.InputMotionData.Accelerometer">
            <summary>
            The raw value from the input device's accelerometer.
            </summary>
        </member>
        <member name="T:Sandbox.GamepadCode">
            <summary>
            Game controller codes, driven from SDL.
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.SwitchLeftMenu">
            <summary>
            Normally the small button on the left side of a gamepad
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.Guide">
            <summary>
            The big button in the middle of a gamepad, usually with the logo on it
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.SwitchRightMenu">
            <summary>
            This is automatically used as the escape key in all games
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.LeftJoystickButton">
            <summary>
            The button when you press down on the stick
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.RightJoystickButton">
            <summary>
            The button when you press down on the stick
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.SwitchLeftBumper">
            <summary>
            Also known as the left bumper, or LB, or L1
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.SwitchRightBumper">
            <summary>
            Also known as the right bumper, or RB, or R1
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.Misc1">
            <summary>
            This is a button that doesn't have a specific name, like the share button on some controllers
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.Paddle1">
            <summary>
            Extra button on the back of some gamepads, like the Xbox Elite
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.Paddle2">
            <summary>
            Extra button on the back of some gamepads, like the Xbox Elite
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.Paddle3">
            <summary>
            Extra button on the back of some gamepads, like the Xbox Elite
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.Paddle4">
            <summary>
            Extra button on the back of some gamepads, like the Xbox Elite
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.LeftTrigger">
            <summary>
            Also known as LT, or L2
            </summary>
        </member>
        <member name="F:Sandbox.GamepadCode.RightTrigger">
            <summary>
            Also known as RT, or R2
            </summary>
        </member>
        <member name="T:Sandbox.HapticEffect">
            <summary>
            Contains a haptic effect, which consists of patterns for the controller and triggers.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.SoftImpact">
            <summary>
            A haptic pattern that represents a light, soft impact.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.HardImpact">
            <summary>
            A haptic pattern that represents a hard, sudden impact.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.Rumble">
            <summary>
            Applies a simple rumble to the controller.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.RumbleLeftTrigger">
            <summary>
            Applies a simple rumble to the left trigger.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.RumbleRightTrigger">
            <summary>
            Applies a simple rumble to the right trigger.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.Heartbeat">
            <summary>
            A haptic effect that feels like a heartbeat.
            </summary>
        </member>
        <member name="T:Sandbox.HapticPattern">
            <summary>
            Contains a haptic pattern, which consists of frequency and amplitude values that can change over time.
            </summary>
        </member>
        <member name="M:Sandbox.HapticPattern.#ctor(System.Single,Sandbox.Curve,Sandbox.Curve)">
            <summary>
            Contains a haptic pattern, which consists of frequency and amplitude values that can change over time.
            </summary>
        </member>
        <member name="P:Sandbox.HapticPattern.SoftImpact">
            <summary>
            A haptic pattern that represents a light, soft impact.
            </summary>
        </member>
        <member name="P:Sandbox.HapticPattern.HardImpact">
            <summary>
            A haptic pattern that represents a hard, sudden impact.
            </summary>
        </member>
        <member name="P:Sandbox.HapticPattern.Rumble">
            <summary>
            A haptic pattern that represents a constant low-frequency rumble.
            </summary>
        </member>
        <member name="P:Sandbox.HapticPattern.Heartbeat">
            <summary>
            A haptic pattern that feels like a heartbeat.
            </summary>
        </member>
        <member name="T:Sandbox.HapticTarget">
            <summary>
            Places you can trigger haptics on
            </summary>
        </member>
        <member name="F:Sandbox.HapticTarget.Controller">
            <summary>
            Controller
            </summary>
        </member>
        <member name="F:Sandbox.HapticTarget.LeftTrigger">
            <summary>
            Left impulse trigger (Xbox)
            </summary>
        </member>
        <member name="F:Sandbox.HapticTarget.RightTrigger">
            <summary>
            Right impulse trigger (Xbox)
            </summary>
        </member>
        <member name="F:Sandbox.InputGlyphSize.Small">
            <summary>
            Small 32x32 ( Keyboard glyphs can be wider for long key names )
            </summary>
        </member>
        <member name="F:Sandbox.InputGlyphSize.Medium">
            <summary>
            Medium 128x128 ( Keyboard glyphs can be wider for long key names )
            </summary>
        </member>
        <member name="F:Sandbox.InputGlyphSize.Large">
            <summary>
            Large 256x256 ( Keyboard glyphs can be wider for long key names )
            </summary>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.ToPixels(Sandbox.InputGlyphSize)">
            <summary>
            Translates this enum to pixel size.
            </summary>
        </member>
        <member name="F:Sandbox.GlyphStyle.Knockout">
            <summary>
            Face buttons will have colored labels/outlines on a knocked out background
            Rest of inputs will have white detail/borders on a knocked out background
            </summary>
        </member>
        <member name="F:Sandbox.GlyphStyle.Light">
            <summary>
            Black detail/borders on a white background
            </summary>
        </member>
        <member name="F:Sandbox.GlyphStyle.Dark">
            <summary>
            White detail/borders on a black background
            </summary>
        </member>
        <member name="M:Sandbox.GlyphStyle.WithNeutralColorABXY">
            <summary>
            ABXY Buttons will match the base style color instead of their normal associated color
            </summary>
        </member>
        <member name="M:Sandbox.GlyphStyle.WithSolidABXY">
            <summary>
            ABXY Buttons will have a solid fill
            </summary>
        </member>
        <member name="T:Sandbox.GlyphStyleMask">
            <summary>
            Internal bit flags for glyph styles, matches Steam Input ones.
            </summary>
        </member>
        <member name="T:Sandbox.InputAction">
            <summary>
            An input action defined by a game project.
            </summary>
        </member>
        <member name="P:Sandbox.InputAction.Name">
            <summary>
            The name of the input action. Used by Input.Down|Pressed|Released.
            </summary>
        </member>
        <member name="P:Sandbox.InputAction.GroupName">
            <summary>
            A group name for this input when showing in a binding system
            </summary>
        </member>
        <member name="P:Sandbox.InputAction.Title">
            <summary>
            A friendly name for this input action when showing in a binding system
            </summary>
        </member>
        <member name="P:Sandbox.InputAction.KeyboardCode">
            <summary>
            The key or key combo we'll be watching for.
            </summary>
        </member>
        <member name="P:Sandbox.InputAction.GamepadCode">
            <summary>
            What gamepad button should this action map to?
            </summary>
        </member>
        <member name="T:Sandbox.MouseButtons">
            <summary>
            State of mouse buttons being pressed or not.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.None">
            <summary>
            No buttons are being pressed.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Left">
            <summary>
            Left mouse button is being pressed.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Right">
            <summary>
            Right mouse button is being pressed.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Middle">
            <summary>
            Middle mouse button (mouse wheel) is being pressed in.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Back">
            <summary>
            The "back" mouse button (mouse4) being pressed in.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Forward">
            <summary>
            The "forward" mouse button (mouse5) being pressed in.
            </summary>
        </member>
        <member name="T:Sandbox.LanguageContainer">
            <summary>
            A container for the current language, allowing access to translated phrases and language information.
            </summary>
        </member>
        <member name="P:Sandbox.LanguageContainer.SelectedCode">
            <summary>
            The abbreviation for the language the user wants. This is set by the user in the options menu.
            </summary>
        </member>
        <member name="P:Sandbox.LanguageContainer.Current">
            <summary>
            Information about the current selected language. Will default to English if the current language isn't found.
            </summary>
        </member>
        <member name="M:Sandbox.LanguageContainer.OnFileChanged">
            <summary>
            Called when a localization file has changed (and we should reload)
            </summary>
        </member>
        <member name="M:Sandbox.LanguageContainer.GetPhrase(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Look up a phrase
            </summary>
            <param name="textToken">The token used to identify the phrase</param>
            <param name="data">Key values of data used by the string. Example: {Variable} -> { "Variable", someVar }</param>
            <returns>If found will return the phrase, else will return the token itself</returns>
        </member>
        <member name="T:Sandbox.Language">
            <summary>
            Allows access to translated phrases, allowing the translation of gamemodes etc
            </summary>
        </member>
        <member name="P:Sandbox.Language.SelectedCode">
            <summary>
            The abbreviation for the language the user wants. This is set by the user in the options menu.
            </summary>
        </member>
        <member name="P:Sandbox.Language.Current">
            <summary>
            Information about the current selected language. Will default to English if the current language isn't found.
            </summary>
        </member>
        <member name="M:Sandbox.Language.GetPhrase(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Look up a phrase
            </summary>
            <param name="textToken">The token used to identify the phrase</param>
            <param name="data">Key values of data used by the string. Example: {Variable} -> { "Variable", someVar }</param>
            <returns>If found will return the phrase, else will return the token itself</returns>
        </member>
        <member name="T:Sandbox.MovieMaker.TrackBinder">
            <summary>
            Controls which <see cref="T:Sandbox.MovieMaker.ITrackTarget"/>s from a scene are controlled by which <see cref="T:Sandbox.MovieMaker.ITrack"/> from a <see cref="T:Sandbox.MovieMaker.IMovieClip"/>.
            Can be serialized to save which tracks are bound to which targets.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.#ctor(Sandbox.Scene)">
            <summary>
            Controls which <see cref="T:Sandbox.MovieMaker.ITrackTarget"/>s from a scene are controlled by which <see cref="T:Sandbox.MovieMaker.ITrack"/> from a <see cref="T:Sandbox.MovieMaker.IMovieClip"/>.
            Can be serialized to save which tracks are bound to which targets.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.TrackBinder.Scene">
            <summary>
            The scene this binder is targeting.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.Get(Sandbox.MovieMaker.ITrack)">
            <summary>
            Gets or creates a target that maps to the given <paramref name="track"/>.
            The target might not be bound to anything in the scene yet, use <see cref="P:Sandbox.MovieMaker.ITrackTarget.IsBound"/> to check.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.Get(Sandbox.MovieMaker.IReferenceTrack)">
            <inheritdoc cref="M:Sandbox.MovieMaker.TrackBinder.Get(Sandbox.MovieMaker.ITrack)"/>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.Get``1(Sandbox.MovieMaker.IReferenceTrack{``0})">
            <inheritdoc cref="M:Sandbox.MovieMaker.TrackBinder.Get(Sandbox.MovieMaker.ITrack)"/>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.Get(Sandbox.MovieMaker.IPropertyTrack)">
            <inheritdoc cref="M:Sandbox.MovieMaker.TrackBinder.Get(Sandbox.MovieMaker.ITrack)"/>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.Get``1(Sandbox.MovieMaker.IPropertyTrack{``0})">
            <inheritdoc cref="M:Sandbox.MovieMaker.TrackBinder.Get(Sandbox.MovieMaker.ITrack)"/>
        </member>
        <member name="P:Sandbox.MovieMaker.TrackBinder.Default">
            <summary>
            Gets the default binder for the active scene.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.GetTrackIds(Sandbox.GameObject)">
            <summary>
            Finds track IDs currently explicitly bound to the given <paramref name="gameObject"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.GetTrackIds(Sandbox.Component)">
            <summary>
            Finds track IDs currently explicitly bound to the given <paramref name="component"/>.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.TrackBinder.GameObjectReference">
            <summary>
            Target that references a <see cref="T:Sandbox.GameObject"/> in a scene.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.GameObjectReference.#ctor(Sandbox.MovieMaker.ITrackReference{Sandbox.GameObject},System.String,Sandbox.MovieMaker.TrackBinder,System.Guid,System.Nullable{System.Guid})">
            <summary>
            Target that references a <see cref="T:Sandbox.GameObject"/> in a scene.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.GameObjectReference.AutoBind">
            <summary>
            If our parent object is bound, try to bind to a child object with a matching name.
            If we have no parent, look up by referenceId, or default to a root object with the right name.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.TrackBinder.ComponentReference`1">
            <summary>
            Target that references a <see cref="T:Sandbox.Component"/> in a scene.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.ComponentReference`1.#ctor(Sandbox.MovieMaker.ITrackReference{Sandbox.GameObject},Sandbox.MovieMaker.TrackBinder,System.Guid)">
            <summary>
            Target that references a <see cref="T:Sandbox.Component"/> in a scene.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.TrackBinder.ComponentReference`1.AutoBind">
            <summary>
            If our parent object is bound, try to bind to a component with a matching type.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Properties.AnimParamProperty`1">
            <summary>
            Reads / writes an anim graph parameter on a <see cref="T:Sandbox.SkinnedModelRenderer"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.AnimParamProperty`1.#ctor(Sandbox.MovieMaker.ITrackProperty{Sandbox.SkinnedModelRenderer.ParameterAccessor},System.String)">
            <summary>
            Reads / writes an anim graph parameter on a <see cref="T:Sandbox.SkinnedModelRenderer"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.AnimParamPropertyFactory.GetTargetType(Sandbox.MovieMaker.ITrackProperty{Sandbox.SkinnedModelRenderer.ParameterAccessor},System.String)">
            <summary>
            Any property in a <see cref="T:Sandbox.SkinnedModelRenderer.ParameterAccessor"/> is an anim graph parameter, but we
            can only determine the type if it actually exists.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Properties.LookAtProperty">
            <summary>
            Procedural property inside <see cref="T:Sandbox.GameObject"/>, that makes the object look at a world position.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.LookAtProperty.#ctor(Sandbox.MovieMaker.ITrackReference{Sandbox.GameObject})">
            <summary>
            Procedural property inside <see cref="T:Sandbox.GameObject"/>, that makes the object look at a world position.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Properties.MemberProperty`1">
            <summary>
            Movie property that references a field or property contained in another <see cref="T:Sandbox.MovieMaker.ITrackTarget"/>.
            For example, a property in a <see cref="T:Sandbox.Component"/>.
            </summary>
            <typeparam name="T">Value type stored in the property.</typeparam>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.MemberProperty`1.#ctor(Sandbox.MovieMaker.ITrackTarget,Sandbox.MemberDescription)">
            <summary>
            Movie property that references a field or property contained in another <see cref="T:Sandbox.MovieMaker.ITrackTarget"/>.
            For example, a property in a <see cref="T:Sandbox.Component"/>.
            </summary>
            <typeparam name="T">Value type stored in the property.</typeparam>
        </member>
        <member name="P:Sandbox.MovieMaker.Properties.MemberProperty`1.IsValid">
            <summary>
            True if <see cref="P:Sandbox.MovieMaker.Properties.MemberProperty`1.Member"/> still exists. Can become false after a hotload that removed the member.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.Properties.MemberProperty`1.IsActive">
            <summary>
            Default behaviour is to check if the parent is active. We need a special case for properties bound to
            <see cref="P:Sandbox.GameObject.Enabled"/> or <see cref="P:Sandbox.Component.Enabled"/>, otherwise we'd never be able to record them
            being false.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Properties.MorphProperty">
            <summary>
            Reads / writes a morph parameter on a <see cref="T:Sandbox.SkinnedModelRenderer"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.MorphProperty.#ctor(Sandbox.MovieMaker.ITrackProperty{Sandbox.SkinnedModelRenderer.MorphAccessor},System.String)">
            <summary>
            Reads / writes a morph parameter on a <see cref="T:Sandbox.SkinnedModelRenderer"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.MorphPropertyFactory.PropertyExists(Sandbox.MovieMaker.ITrackProperty{Sandbox.SkinnedModelRenderer.MorphAccessor},System.String)">
            <summary>
            Any property inside a <see cref="T:Sandbox.SkinnedModelRenderer.MorphAccessor"/> is a morph.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Properties.ITrackPropertyFactory">
            <summary>
            Used by <see cref="T:Sandbox.MovieMaker.TrackBinder"/> to create <see cref="T:Sandbox.MovieMaker.ITrackProperty"/> instances that allow <see cref="T:Sandbox.MovieMaker.ITrack"/>s
            to modify values in a scene.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.Properties.ITrackPropertyFactory.Order">
            <summary>
            Used to sort the order that factories are considered when trying to create a property.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.Properties.ITrackPropertyFactory.CategoryName">
            <summary>
            When listing properties to add, what category should we use for properties from this factory?
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory.GetPropertyNames(Sandbox.MovieMaker.ITrackTarget)">
            <summary>
            Lists all available property names provided by this factory from a given <paramref name="parent"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory.GetTargetType(Sandbox.MovieMaker.ITrackTarget,System.String)">
            <summary>
            Decides if this factory can create a property given a <paramref name="parent"/> target and <paramref name="name"/>.
            Returns any non-<see langword="null"/> type if this factory can create such a property, after which <see cref="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory.CreateProperty``1(Sandbox.MovieMaker.ITrackTarget,System.String)"/>
            will be called using that type.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory.CreateProperty``1(Sandbox.MovieMaker.ITrackTarget,System.String)">
            <summary>
            Create a property with the given <paramref name="parent"/>, <paramref name="name"/>, and property value type <typeparamref name="T"/>.
            The target type was previously returned by <see cref="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory.GetTargetType(Sandbox.MovieMaker.ITrackTarget,System.String)"/>, or read from a deserialized track.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Properties.ITrackPropertyFactory`1">
            <summary>
            An <see cref="T:Sandbox.MovieMaker.Properties.ITrackPropertyFactory"/> that only creates properties nested inside a particular <typeparamref name="TParent"/>
            target type.
            </summary>
            <typeparam name="TParent">Parent target type that this factory's properties are always nested inside.</typeparam>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory`1.GetTargetType(`0,System.String)">
            <inheritdoc cref="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory.GetTargetType(Sandbox.MovieMaker.ITrackTarget,System.String)"/>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory`1.CreateProperty``1(`0,System.String)">
            <inheritdoc cref="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory.CreateProperty``1(Sandbox.MovieMaker.ITrackTarget,System.String)"/>
        </member>
        <member name="T:Sandbox.MovieMaker.Properties.ITrackPropertyFactory`2">
            <summary>
            An <see cref="T:Sandbox.MovieMaker.Properties.ITrackPropertyFactory"/> that only creates properties nested inside a particular <typeparamref name="TParent"/>
            target type, and that always have the same property value type <typeparamref name="TValue"/>.
            </summary>
            <typeparam name="TParent">Parent target type that this factory's properties are always nested inside.</typeparam>
            <typeparam name="TValue">Property value type for properties created by this factory.</typeparam>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory`2.PropertyExists(`0,System.String)">
            <summary>
            Returns true if this factory can create a property with the given <paramref name="parent"/> and <paramref name="name"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.ITrackPropertyFactory`2.CreateProperty(`0,System.String)">
            <summary>
            Creates a property with the given <paramref name="parent"/> and <paramref name="name"/>.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Properties.UnknownProperty`1">
            <summary>
            Fallback property that can never be bound.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Properties.UnknownProperty`1.#ctor(Sandbox.MovieMaker.ITrackTarget,System.String)">
            <summary>
            Fallback property that can never be bound.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Properties.Unknown">
            <summary>
            Dummy type for <see cref="T:Sandbox.MovieMaker.Properties.ITrackPropertyFactory`1"/> to return if it matches
            a track, but doesn't know what target type it maps to.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.ITrackTarget">
            <summary>
            <para>
            Something in the scene that is being controlled by an <see cref="T:Sandbox.MovieMaker.ITrack"/>.
            This could be a <see cref="T:Sandbox.GameObject"/> or <see cref="T:Sandbox.Component"/> reference, or a property contained
            within another <see cref="T:Sandbox.MovieMaker.ITrackTarget"/>.
            </para>
            <para>
            These targets are created using <see cref="M:Sandbox.MovieMaker.TrackBinder.Get(Sandbox.MovieMaker.ITrack)"/>.
            </para>
            <para>
            If <see cref="P:Sandbox.MovieMaker.ITrackTarget.IsBound"/> is true, this target is connected to a live instance of something in the scene,
            so accessing it will affect that connected instance.
            </para>
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackTarget.Name">
            <summary>
            Name of this target, for debugging and editing.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackTarget.TargetType">
            <summary>
            Value type of this target.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackTarget.IsBound">
            <summary>
            If true, this target is connected to a real object in the scene, so can be accessed.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackTarget.IsActive">
            <summary>
            If true, the target is bound and active in the scene hierarchy.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackTarget.Value">
            <summary>
            If bound, the current value of this target in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackTarget.Parent">
            <summary>
            Component / game object / property that contains this target, if from a nested track.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.ITrackTarget`1">
            <inheritdoc cref="T:Sandbox.MovieMaker.ITrackTarget"/>
            <typeparam name="T">Target value type.</typeparam>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackTarget`1.Value">
            <inheritdoc cref="P:Sandbox.MovieMaker.ITrackTarget.Value"/>
        </member>
        <member name="T:Sandbox.MovieMaker.ITrackReference">
            <summary>
            A target referencing a <see cref="T:Sandbox.GameObject"/> or <see cref="T:Sandbox.Component"/> in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackReference.Id">
            <summary>
            The <see cref="P:Sandbox.MovieMaker.IReferenceTrack.Id"/> of the reference track this target was created from.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackReference.Parent">
            <summary>
            Optional game object target that contains this one, if from a nested track.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.ITrackReference.Bind(Sandbox.IValid)">
            <summary>
            Explicitly this reference to a particular object in the scene, or null to force it to stay unbound.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.ITrackReference.Reset">
            <summary>
            Clear any explicit binding, so this reference will auto-bind based on its name, type, and parent.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.ITrackReference`1">
            <inheritdoc cref="T:Sandbox.MovieMaker.ITrackReference"/>
            <typeparam name="T">Reference value type.</typeparam>
        </member>
        <member name="M:Sandbox.MovieMaker.ITrackReference`1.Bind(`0)">
            <inheritdoc cref="M:Sandbox.MovieMaker.ITrackReference.Bind(Sandbox.IValid)"/>
        </member>
        <member name="T:Sandbox.MovieMaker.ITrackProperty">
            <summary>
            A target referencing a member property or field of another target.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackProperty.Parent">
            <summary>
            Target that this member belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackProperty.CanWrite">
            <summary>
            False if this member is readonly.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackProperty.Value">
            <summary>
            If bound, gets or sets the current value of this member.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.ITrackProperty.Update(Sandbox.MovieMaker.IPropertyTrack,Sandbox.MovieMaker.MovieTime)">
            <summary>
            If bound and writable, update this property's value from the
            given <paramref name="track"/> at the given <paramref name="time"/>.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.ITrackProperty`1">
            <inheritdoc cref="T:Sandbox.MovieMaker.ITrackProperty"/>
            <typeparam name="T">Property value type.</typeparam>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackProperty`1.Value">
            <inheritdoc cref="P:Sandbox.MovieMaker.ITrackProperty.Value"/>
        </member>
        <member name="M:Sandbox.MovieMaker.ITrackProperty`1.Update(Sandbox.MovieMaker.IPropertyTrack{`0},Sandbox.MovieMaker.MovieTime)">
            <inheritdoc cref="M:Sandbox.MovieMaker.ITrackProperty.Update(Sandbox.MovieMaker.IPropertyTrack,Sandbox.MovieMaker.MovieTime)"/>
        </member>
        <member name="T:Sandbox.MovieMaker.IMovieClip">
            <summary>
            A collection of <see cref="T:Sandbox.MovieMaker.ITrack"/>s describing properties changing over time and actions being invoked.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.IMovieClip.Tracks">
            <summary>
            All tracks within the clip.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.IMovieClip.Duration">
            <summary>
            How long this clip takes to fully play.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.IMovieClip.GetTrack(System.Guid)">
            <summary>
            Attempts to get a reference track with the given <paramref name="trackId"/>.
            </summary>
            <returns>The matching track, or <see langword="null"/> if not found.</returns>
        </member>
        <member name="M:Sandbox.MovieMaker.IMovieClip.GetTracks(Sandbox.MovieMaker.MovieTime)">
            <summary>
            Get tracks that are active at the given <paramref name="time"/>.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.ITrack">
            <summary>
            Maps to a <see cref="T:Sandbox.MovieMaker.ITrackTarget"/> in a scene, and describes how it changes over time.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrack.Name">
            <summary>
            Property or object name, used when auto-binding this track in a scene.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrack.TargetType">
            <summary>
            What type of object or property is this track targeting.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrack.Parent">
            <summary>
            Tracks can be nested, which means child tracks can auto-bind to targets in the scene
            if their parent is bound.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.IReferenceTrack">
            <summary>
            Maps to an <see cref="T:Sandbox.MovieMaker.ITrackReference"/> in a scene, which binds to a <see cref="T:Sandbox.GameObject"/>
            or <see cref="T:Sandbox.Component"/>.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.IReferenceTrack.Id">
            <summary>
            ID for referencing this track. Must be unique in the containing <see cref="T:Sandbox.MovieMaker.IMovieClip"/>,
            but different clips can share tracks as long as they have identical names, types,
            and parent tracks.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.IReferenceTrack.Parent">
            <inheritdoc cref="P:Sandbox.MovieMaker.ITrack.Parent"/>
        </member>
        <member name="T:Sandbox.MovieMaker.IReferenceTrack`1">
            <inheritdoc cref="T:Sandbox.MovieMaker.IPropertyTrack"/>
            <typeparam name="T">Reference value type, must match <see cref="P:Sandbox.MovieMaker.ITrack.TargetType"/>.</typeparam>
        </member>
        <member name="T:Sandbox.MovieMaker.IActionTrack">
            <summary>
            Unused, will describe running actions in the scene.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.IPropertyTrack">
            <summary>
            Controls an <see cref="T:Sandbox.MovieMaker.ITrackProperty"/> in the scene. Defines what value that property should have
            at each moment of time.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.IPropertyTrack.TryGetValue(Sandbox.MovieMaker.MovieTime,System.Object@)">
            <summary>
            For a given <paramref name="time"/>, does this track want to control its mapped property.
            If so, also outputs the desired property value.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.IPropertyTrack`1">
            <inheritdoc cref="T:Sandbox.MovieMaker.IPropertyTrack"/>
            <typeparam name="T">Property value type.</typeparam>
        </member>
        <member name="M:Sandbox.MovieMaker.IPropertyTrack`1.TryGetValue(Sandbox.MovieMaker.MovieTime,`0@)">
            <summary>
            For a given <paramref name="time"/>, does this track want to control its mapped property.
            If so, also outputs the desired property value.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.ITrackBlock">
            <summary>
            A time region where something happens in a movie track.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.ITrackBlock.TimeRange">
            <summary>
            Start and end time of this block.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.IPropertySignal">
            <summary>
            Describes a value that changes over time.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.IPropertySignal.PropertyType">
            <summary>
            What type of value does this signal describe?
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.IPropertySignal.GetValue(Sandbox.MovieMaker.MovieTime)">
            <summary>
            What value does this signal have at the given time?
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.IPropertySignal`1">
            <inheritdoc cref="T:Sandbox.MovieMaker.IPropertySignal`1"/>
        </member>
        <member name="M:Sandbox.MovieMaker.IPropertySignal`1.GetValue(Sandbox.MovieMaker.MovieTime)">
            <inheritdoc cref="M:Sandbox.MovieMaker.IPropertySignal.GetValue(Sandbox.MovieMaker.MovieTime)"/>
        </member>
        <member name="T:Sandbox.MovieMaker.IPropertyBlock">
            <summary>
            A <see cref="T:Sandbox.MovieMaker.IPropertySignal"/> with a defined start and end time.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.IPropertyBlock`1">
            <summary>
            A <see cref="T:Sandbox.MovieMaker.IPropertySignal`1"/> with a defined start and end time.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.ClipExtensions">
            <summary>
            Helper methods for working with <see cref="T:Sandbox.MovieMaker.IMovieClip"/> and <see cref="T:Sandbox.MovieMaker.ITrack"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.GetDepth(Sandbox.MovieMaker.ITrack)">
            <summary>
            How deeply are we nested? Root tracks have depth <c>0</c>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.GetTrack(Sandbox.MovieMaker.IMovieClip,System.String[])">
            <summary>
            Searches <paramref name="clip"/> for a track with the given <paramref name="path"/>,
            starting from the root level of the clip.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.GetTrack(Sandbox.MovieMaker.Compiled.MovieClip,System.String[])">
            <inheritdoc cref="M:Sandbox.MovieMaker.ClipExtensions.GetTrack(Sandbox.MovieMaker.IMovieClip,System.String[])"/>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.GetReference``1(Sandbox.MovieMaker.IMovieClip,System.String[])">
            <summary>
            Searches <paramref name="clip"/> for a track with the given <paramref name="path"/>,
            starting from the root level of the clip.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.GetReference``1(Sandbox.MovieMaker.Compiled.MovieClip,System.String[])">
            <inheritdoc cref="M:Sandbox.MovieMaker.ClipExtensions.GetReference``1(Sandbox.MovieMaker.IMovieClip,System.String[])"/>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.GetProperty``1(Sandbox.MovieMaker.IMovieClip,System.String[])">
            <summary>
            Searches <paramref name="clip"/> for a property track with the given <paramref name="path"/>,
            starting from the root level of the clip.
            </summary>
            <typeparam name="T">Property value type.</typeparam>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.GetProperty``1(Sandbox.MovieMaker.Compiled.MovieClip,System.String[])">
            <inheritdoc cref="M:Sandbox.MovieMaker.ClipExtensions.GetProperty``1(Sandbox.MovieMaker.IMovieClip,System.String[])"/>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.Update(Sandbox.MovieMaker.IMovieClip,Sandbox.MovieMaker.MovieTime,Sandbox.MovieMaker.TrackBinder)">
            <summary>
            For each track in the given <paramref name="clip"/> that we have a mapped property for,
            set the property value to whatever value is stored in that track at the given <paramref name="time"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.Update(Sandbox.MovieMaker.IPropertyTrack,Sandbox.MovieMaker.MovieTime,Sandbox.MovieMaker.TrackBinder)">
            <summary>
            If we have a mapped property for <paramref name="track"/>, set the property value to whatever value
            is stored in the track at the given <paramref name="time"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.ClipExtensions.Update``1(Sandbox.MovieMaker.IPropertyTrack{``0},Sandbox.MovieMaker.MovieTime,Sandbox.MovieMaker.TrackBinder)">
            <inheritdoc cref="M:Sandbox.MovieMaker.ClipExtensions.Update(Sandbox.MovieMaker.IPropertyTrack,Sandbox.MovieMaker.MovieTime,Sandbox.MovieMaker.TrackBinder)"/>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.ICompiledBlock">
            <summary>
            A block of time where something happens in an <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledTrack"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.ICompiledBlock.Shift(Sandbox.MovieMaker.MovieTime)">
            <summary>
            Move this block by the given time <paramref name="offset"/>.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.CompiledActionBlock">
            <summary>
            Unused, will describe starting / stopping an action in the scene.
            </summary>
            <param name="TimeRange">Start and end time of this block.</param>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledActionBlock.#ctor(Sandbox.MovieMaker.MovieTimeRange)">
            <summary>
            Unused, will describe starting / stopping an action in the scene.
            </summary>
            <param name="TimeRange">Start and end time of this block.</param>
        </member>
        <member name="P:Sandbox.MovieMaker.Compiled.CompiledActionBlock.TimeRange">
            <summary>Start and end time of this block.</summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.ICompiledPropertyBlock">
            <summary>
            Interface for blocks describing a property changing value over time.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.ICompiledPropertyBlock.Shift(Sandbox.MovieMaker.MovieTime)">
            <inheritdoc cref="M:Sandbox.MovieMaker.Compiled.ICompiledBlock.Shift(Sandbox.MovieMaker.MovieTime)"/>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.ICompiledPropertyBlock`1">
            <summary>
            Interface for blocks describing a property changing value over time.
            Typed version of <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledPropertyBlock"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.ICompiledPropertyBlock`1.Shift(Sandbox.MovieMaker.MovieTime)">
            <inheritdoc cref="M:Sandbox.MovieMaker.Compiled.ICompiledBlock.Shift(Sandbox.MovieMaker.MovieTime)"/>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.CompiledConstantBlock`1">
            <summary>
            This block has a single constant value for the whole duration.
            Useful for value types that can't be interpolated, and change infrequently.
            </summary>
            <typeparam name="T">Property value type.</typeparam>
            <param name="TimeRange">Start and end time of this block.</param>
            <param name="Value">Constant value.</param>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledConstantBlock`1.#ctor(Sandbox.MovieMaker.MovieTimeRange,`0)">
            <summary>
            This block has a single constant value for the whole duration.
            Useful for value types that can't be interpolated, and change infrequently.
            </summary>
            <typeparam name="T">Property value type.</typeparam>
            <param name="TimeRange">Start and end time of this block.</param>
            <param name="Value">Constant value.</param>
        </member>
        <member name="P:Sandbox.MovieMaker.Compiled.CompiledConstantBlock`1.TimeRange">
            <summary>Start and end time of this block.</summary>
        </member>
        <member name="P:Sandbox.MovieMaker.Compiled.CompiledConstantBlock`1.Value">
            <summary>Constant value.</summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.CompiledSampleBlock`1">
            <summary>
            This block contains an array of values sampled at uniform intervals.
            </summary>
            <typeparam name="T">Property value type.</typeparam>
            <param name="TimeRange">Start and end time of this block.</param>
            <param name="Offset">Time offset of the first sample.</param>
            <param name="SampleRate">How many samples per second.</param>
            <param name="Samples">Raw sample values.</param>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledSampleBlock`1.#ctor(Sandbox.MovieMaker.MovieTimeRange,Sandbox.MovieMaker.MovieTime,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            This block contains an array of values sampled at uniform intervals.
            </summary>
            <typeparam name="T">Property value type.</typeparam>
            <param name="TimeRange">Start and end time of this block.</param>
            <param name="Offset">Time offset of the first sample.</param>
            <param name="SampleRate">How many samples per second.</param>
            <param name="Samples">Raw sample values.</param>
        </member>
        <member name="P:Sandbox.MovieMaker.Compiled.CompiledSampleBlock`1.TimeRange">
            <summary>Start and end time of this block.</summary>
        </member>
        <member name="P:Sandbox.MovieMaker.Compiled.CompiledSampleBlock`1.Offset">
            <summary>Time offset of the first sample.</summary>
        </member>
        <member name="P:Sandbox.MovieMaker.Compiled.CompiledSampleBlock`1.SampleRate">
            <summary>How many samples per second.</summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.MovieClip">
            <summary>
            An immutable compiled <see cref="T:Sandbox.MovieMaker.IMovieClip"/> designed to be serialized.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.Compiled.MovieClip.Empty">
            <summary>
            A clip with no tracks.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.Compiled.MovieClip.Tracks">
            <inheritdoc cref="P:Sandbox.MovieMaker.IMovieClip.Tracks"/>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.MovieClip.GetTrack(System.Guid)">
            <inheritdoc cref="M:Sandbox.MovieMaker.IMovieClip.GetTrack(System.Guid)"/>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.MovieClip.RootGameObject(System.String,System.Nullable{System.Guid})">
            <summary>
            Create a root <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledReferenceTrack"/> that targets a <see cref="T:Sandbox.GameObject"/> with
            the given <paramref name="name"/>. To create a nested track, use <see cref="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.GameObject(Sandbox.MovieMaker.Compiled.CompiledReferenceTrack{Sandbox.GameObject},System.String,System.Nullable{System.Guid},System.Nullable{System.Guid})"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.MovieClip.RootComponent(System.Type,System.Nullable{System.Guid})">
            <summary>
            Create a root <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledReferenceTrack"/> that targets a <see cref="T:Sandbox.Component"/> with
            the given <paramref name="type"/>. To create a nested track, use <see cref="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.Component(Sandbox.MovieMaker.Compiled.CompiledReferenceTrack{Sandbox.GameObject},System.Type,System.Nullable{System.Guid},System.Nullable{System.Guid})"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.MovieClip.RootComponent``1(System.Nullable{System.Guid})">
            <summary>
            Create a root <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledReferenceTrack"/> that targets a <see cref="T:Sandbox.Component"/> with
            the type <typeparamref name="T"/>. To create a nested track, use <see cref="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.Component``1(Sandbox.MovieMaker.Compiled.CompiledReferenceTrack{Sandbox.GameObject},System.Nullable{System.Guid})"/>.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.CompiledClipExtensions">
            <summary>
            Helper methods for working with <see cref="T:Sandbox.MovieMaker.Compiled.MovieClip"/>, <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledTrack"/>, or <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledBlock"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.GameObject(Sandbox.MovieMaker.Compiled.CompiledReferenceTrack{Sandbox.GameObject},System.String,System.Nullable{System.Guid},System.Nullable{System.Guid})">
            <summary>
            Create a nested <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledReferenceTrack"/> that targets a <see cref="T:Sandbox.GameObject"/> with
            the given <paramref name="name"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.Component(Sandbox.MovieMaker.Compiled.CompiledReferenceTrack{Sandbox.GameObject},System.Type,System.Nullable{System.Guid},System.Nullable{System.Guid})">
            <summary>
            Create a nested <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledReferenceTrack"/> that targets a <see cref="T:Sandbox.Component"/> with
            the given <paramref name="type"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.Component``1(Sandbox.MovieMaker.Compiled.CompiledReferenceTrack{Sandbox.GameObject},System.Nullable{System.Guid})">
            <summary>
            Create a nested <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledReferenceTrack"/> that targets a <see cref="T:Sandbox.Component"/> with
            the type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.Property``1(Sandbox.MovieMaker.Compiled.ICompiledTrack,System.String,System.Collections.Generic.IEnumerable{Sandbox.MovieMaker.Compiled.ICompiledPropertyBlock{``0}})">
            <summary>
            Create a nested <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledPropertyTrack"/> that targets a property with the given <paramref name="name"/>
            in the parent track.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.Property(Sandbox.MovieMaker.Compiled.ICompiledTrack,System.String,System.Type,System.Collections.Generic.IEnumerable{Sandbox.MovieMaker.Compiled.ICompiledPropertyBlock})">
            <summary>
            Create a nested <see cref="T:Sandbox.MovieMaker.Compiled.ICompiledPropertyTrack"/> that targets a property with the given <paramref name="name"/>
            in the parent track.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.WithConstant``1(Sandbox.MovieMaker.Compiled.CompiledPropertyTrack{``0},Sandbox.MovieMaker.MovieTimeRange,``0)">
            <summary>
            Returns a clone of <paramref name="track"/> with an appended <see cref="T:Sandbox.MovieMaker.Compiled.CompiledConstantBlock`1"/> with the given
            <paramref name="timeRange"/> and <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.WithSamples``1(Sandbox.MovieMaker.Compiled.CompiledPropertyTrack{``0},Sandbox.MovieMaker.MovieTimeRange,System.Int32,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a clone of <paramref name="track"/> with an appended <see cref="T:Sandbox.MovieMaker.Compiled.CompiledSampleBlock`1"/> with the given
            <paramref name="timeRange"/>, <paramref name="sampleRate"/>, and list of sample <paramref name="values"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledClipExtensions.Sample``1(System.Collections.Generic.IReadOnlyList{``0},Sandbox.MovieMaker.MovieTime,System.Int32,Sandbox.MovieMaker.IInterpolator{``0})">
            <summary>
            Interpreting <paramref name="samples"/> as an array of samples taken at a given <paramref name="sampleRate"/>, read
            a sample from the array at the given <paramref name="time"/> offset from the first sample. Optionally uses <paramref name="interpolator"/>
            to interpolate between samples.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.ICompiledTrack">
            <inheritdoc cref="T:Sandbox.MovieMaker.ITrack"/>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.ICompiledReferenceTrack">
            <inheritdoc cref="T:Sandbox.MovieMaker.IReferenceTrack"/>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.CompiledActionTrack">
            <inheritdoc cref="T:Sandbox.MovieMaker.IActionTrack"/>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledActionTrack.#ctor(System.String,System.Type,Sandbox.MovieMaker.Compiled.ICompiledTrack,System.Collections.Immutable.ImmutableArray{Sandbox.MovieMaker.Compiled.CompiledActionBlock})">
            <inheritdoc cref="T:Sandbox.MovieMaker.IActionTrack"/>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.ICompiledPropertyTrack">
            <inheritdoc cref="T:Sandbox.MovieMaker.IPropertyTrack"/>
        </member>
        <member name="T:Sandbox.MovieMaker.Compiled.CompiledPropertyTrack`1">
            <inheritdoc cref="T:Sandbox.MovieMaker.IPropertyTrack`1"/>
        </member>
        <member name="M:Sandbox.MovieMaker.Compiled.CompiledPropertyTrack`1.#ctor(System.String,Sandbox.MovieMaker.Compiled.ICompiledTrack,System.Collections.Immutable.ImmutableArray{Sandbox.MovieMaker.Compiled.ICompiledPropertyBlock{`0}})">
            <inheritdoc cref="T:Sandbox.MovieMaker.IPropertyTrack`1"/>
        </member>
        <member name="T:Sandbox.MovieMaker.MoviePlayer">
            <summary>
            Plays a <see cref="T:Sandbox.MovieMaker.IMovieClip"/> in a <see cref="T:Sandbox.Scene"/> to animate properties over time.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.MoviePlayer.Binder">
            <summary>
            Maps <see cref="T:Sandbox.MovieMaker.ITrack"/>s to game objects, components, and property <see cref="T:Sandbox.MovieMaker.ITrackTarget"/>s in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.MoviePlayer.Resource">
            <summary>
            Contains a <see cref="T:Sandbox.MovieMaker.IMovieClip"/> to play. Can be a <see cref="T:Sandbox.MovieMaker.MovieResource"/> or <see cref="T:Sandbox.MovieMaker.EmbeddedMovieResource"/>.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.MoviePlayer.Play">
            <summary>
            Play the current movie from the start.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.MoviePlayer.Play(Sandbox.MovieMaker.MovieResource)">
            <summary>
            Play the specified movie from the start.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.MoviePlayer.UpdatePosition">
            <summary>
            Apply the movie clip to the scene at the current time position.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.MoviePlayer.UpdateAnimationPlaybackRate(Sandbox.MovieMaker.IMovieClip)">
            <summary>
            Set the <see cref="P:Sandbox.SkinnedModelRenderer.PlaybackRate"/> of all bound renderers.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.IMovieResource">
            <summary>
            A container for a <see cref="T:Sandbox.MovieMaker.Compiled.MovieClip"/>, including optional <see cref="P:Sandbox.MovieMaker.IMovieResource.EditorData"/>.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.IMovieResource.Compiled">
            <summary>
            Compiled movie clip.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.IMovieResource.EditorData">
            <summary>
            Editor-only data used to generate <see cref="P:Sandbox.MovieMaker.IMovieResource.Compiled"/>.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.MovieResource">
            <summary>
            A movie clip created with the MoviePlayer component.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.MovieResource.Compiled">
            <inheritdoc />
        </member>
        <member name="P:Sandbox.MovieMaker.MovieResource.EditorData">
            <inheritdoc />
        </member>
        <member name="T:Sandbox.MovieMaker.EmbeddedMovieResource">
            <summary>
            An <see cref="T:Sandbox.MovieMaker.IMovieClip"/> embedded in a property.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.EmbeddedMovieResource.Compiled">
            <inheritdoc />
        </member>
        <member name="P:Sandbox.MovieMaker.EmbeddedMovieResource.EditorData">
            <inheritdoc />
        </member>
        <member name="T:Sandbox.MovieMaker.IInterpolator`1">
            <summary>
            Interpolates between two values of the same type.
            </summary>
            <typeparam name="T">Value type to interpolate.</typeparam>
        </member>
        <member name="M:Sandbox.MovieMaker.IInterpolator`1.Interpolate(`0,`0,System.Single)">
            <summary>
            Interpolate between two values.
            </summary>
            <param name="a">Value to return when <paramref name="t"/> is <c>0</c>.</param>
            <param name="b">Value to return when <paramref name="t"/> is <c>1</c>.</param>
            <param name="t">Fraction between <c>0</c> and <c>1</c> (inclusive).</param>
        </member>
        <member name="T:Sandbox.MovieMaker.Interpolator">
            <summary>
            Helper for accessing <see cref="T:Sandbox.MovieMaker.IInterpolator`1"/> implementations,
            for interpolating between two values of the same type
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.Interpolator.GetDefault``1">
            <summary>
            Attempts to find a default interpolator for type <typeparamref name="T"/>,
            returning <see langword="null"/> if not found.
            </summary>
            <typeparam name="T">Value type to interpolate.</typeparam>
        </member>
        <member name="T:Sandbox.MovieMaker.DefaultInterpolator">
            <summary>
            Interpolator for common types.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.MovieTime">
            <summary>
            Represents a duration of time in a movie. Uses fixed point so precision is consistent at any absolute time.
            Defaults to <see cref="P:Sandbox.MovieMaker.MovieTime.Zero"/>.
            </summary>
        </member>
        <member name="F:Sandbox.MovieMaker.MovieTime.TickRate">
            <summary>
            How many <see cref="P:Sandbox.MovieMaker.MovieTime.Ticks"/> per second. This value should nicely divide into
            common frame rates.
            </summary>
        </member>
        <member name="P:Sandbox.MovieMaker.MovieTime.SupportedFrameRates">
            <summary>
            Frame rates <c>&lt;= 120</c> that can be perfectly represented by <see cref="F:Sandbox.MovieMaker.MovieTime.TickRate"/>, in ascending order.
            Venturing outside these rates will lead to some frames being slightly different durations than others.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.MovieTime.GetFrameIndex(System.Int32)">
            <summary>
            Given a <paramref name="frameRate"/>, how many frames have passed before reaching
            this time.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.MovieTime.GetFrameIndex(System.Int32,Sandbox.MovieMaker.MovieTime@)">
            <summary>
            Given a <paramref name="frameRate"/>, how many frames have passed before reaching
            this time, and how far into the current frame are we.
            </summary>
        </member>
        <member name="M:Sandbox.MovieMaker.MovieTime.GetFrameCount(System.Int32)">
            <summary>
            Given a <paramref name="frameRate"/>, how many frames would need to be allocated
            to represent every moment of time up until now. This is always at least <c>1</c>,
            and will be <c>1</c> more than <see cref="M:Sandbox.MovieMaker.MovieTime.GetFrameIndex(System.Int32)"/> unless this time
            is exactly on a frame boundary.
            </summary>
        </member>
        <member name="T:Sandbox.MovieMaker.MovieTimeRange">
            <summary>
            Represents a segment of time, given by <see cref="P:Sandbox.MovieMaker.MovieTimeRange.Start"/> and <see cref="P:Sandbox.MovieMaker.MovieTimeRange.End"/> times.
            </summary>
            <param name="Start">Minimum time in the range.</param>
            <param name="End">Maximum time in the range.</param>
        </member>
        <member name="M:Sandbox.MovieMaker.MovieTimeRange.#ctor(Sandbox.MovieMaker.MovieTime,Sandbox.MovieMaker.MovieTime)">
            <summary>
            Represents a segment of time, given by <see cref="P:Sandbox.MovieMaker.MovieTimeRange.Start"/> and <see cref="P:Sandbox.MovieMaker.MovieTimeRange.End"/> times.
            </summary>
            <param name="Start">Minimum time in the range.</param>
            <param name="End">Maximum time in the range.</param>
        </member>
        <member name="P:Sandbox.MovieMaker.MovieTimeRange.Start">
            <summary>Minimum time in the range.</summary>
        </member>
        <member name="P:Sandbox.MovieMaker.MovieTimeRange.End">
            <summary>Maximum time in the range.</summary>
        </member>
        <member name="P:Sandbox.Network.ServerInfo.IsDeveloperHost">
            <summary>
            If true then this host is being run from an editor, as such the assemblies
            are sent via network tables and loading assemblies from the package is not required.
            </summary>
        </member>
        <member name="T:Sandbox.Network.ServerCommand">
            <summary>
            A console command was run on a client but is being forwarded to the server. This is the message
            that contains the details of that command.
            </summary>
        </member>
        <member name="T:Sandbox.Network.UserInfoUpdate">
            <summary>
            A UserInfo ConVar value was changed on a client. This message is intended for the host so that they
            can propagate this change to all clients.
            </summary>
        </member>
        <member name="T:Sandbox.Network.LogMsg">
            <summary>
            A simple log message packet. This is used by <see cref="M:Sandbox.Connection.SendLog(Sandbox.LogLevel,System.String)"/> when logging
            to another client's console.
            </summary>
        </member>
        <member name="T:Sandbox.Network.ReconnectMsg">
            <summary>
            Sent to the server to tell clients to reconnect. This is sent when
            the server is changing games, or maps, and wants the current players
            to follow them to the new game, or map.
            We send the Game and Map to the best of our knowledge, so the client
            can maybe preload them, while we are.
            </summary>
        </member>
        <member name="M:Sandbox.Network.ConnectionInfoManager.Get(System.Guid)">
            <summary>
            Get info for this connection
            </summary>
        </member>
        <member name="T:Sandbox.Network.ConnectionInfo">
            <summary>
            Information about a connection. The difference between this and the actual connections is that
            this can be networked between clients, so all clients have the same information about each other.
            This is going to be required in p2p games, where players need to take over hosting from each other.
            In a game like Rust, with a dedicated server, this won't need to be networked to other clients.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionInfo.UserData">
            <summary>
            Key values that come straight from the user. Can't be trusted, they could send anything. Used
            for things like preferences, avatar clothing etc.
            </summary>
        </member>
        <member name="F:Sandbox.Network.ConnectionInfo._localMock">
            <summary>
            When a user isn't connected to a server, or hosting a server, the
            client info table doesn't exist. So we provide info here for the
            local connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.Ping">
            <summary>
            Current ping for this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.OutPacketsPerSecond">
            <summary>
            How many packets per second we're sending to this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.OutBytesPerSecond">
            <summary>
            How many bytes per second we're sending to this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.InPacketsPerSecond">
            <summary>
            How many packets per second we're receiving from this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.InBytesPerSecond">
            <summary>
            How many bytes per second we're receiving from this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.SendRateBytesPerSecond">
            <summary>
            Estimate rate that we believe we can send data to this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.ConnectionQuality">
            <summary>
            From 0 to 1 how good is our connection to this?
            </summary>
        </member>
        <member name="T:Sandbox.Network.GameNetworkSystem">
            <summary>
            An instance of this is created by the NetworkSystem when a server is joined, or created.
            You should not try to create this manually.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.AcceptConnection(Sandbox.Connection,System.String@)">
            <summary>
            Called on the host to decide whether to accept a <see cref="T:Sandbox.Connection"/>.
            </summary>
            <param name="channel"></param>
            <param name="reason">The reason to display to the client.</param>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnInitialize">
            <summary>
            Called when the network system should handle initialization.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnConnected(Sandbox.Connection)">
            <summary>
            A client has connected to the server but hasn't fully finished joining yet.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnJoined(Sandbox.Connection)">
            <summary>
            Fully joined the server. Can be called when changing the map too. The game should usually create
            some object for the player to control here.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnLeave(Sandbox.Connection)">
            <summary>
            A client has disconnected from the server.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnBecameHost(Sandbox.Connection)">
            <summary>
            The host left the server and you are now in charge.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnHostChanged(Sandbox.Connection,Sandbox.Connection)">
            <summary>
            The current host has been changed.
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.IsHostBusy">
            <summary>
            Whether the host is busy right now. This can be used to determine if
            the host can be changed.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.Push">
            <summary>
            Allows to push some kind of scope when reading network messages. This is useful if you
            need to adjust Time.Now etc.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.Tick">
            <summary>
            Called every frame
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnHeartbeat(System.Single)">
            <summary>
            A heartbeat has been received from the host. We should make sure our times are in sync.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnDeltaSnapshotMessage(Sandbox.Network.InternalMessageType,Sandbox.ByteStream,Sandbox.Connection)">
            <summary>
            A delta snapshot message has been received from another connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.IsHost">
            <summary>
            True if we can be considered the host of this session. Either we're not connected to a server, or we are and we are the host.
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.IsClient">
            <summary>
            True if we're connected to a server and not the host.
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.IsConnecting">
            <summary>
            True if we're currently connecting to the server
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.IsActive">
            <summary>
            True if we're currently connected etc
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnLoadedScene(System.String)">
            <summary>
            Called after we've loaded a new scene.
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyInformation.IsFull">
            <summary>
            True if this lobby is full (Members >= MaxMembers).
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyInformation.IsHidden">
            <summary>
            True if this lobby should be hidden from server lists.
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyInformation.ContainsFriends">
            <summary>
            Return true if this lobby contains a friend.
            </summary>
        </member>
        <member name="P:Sandbox.Network.DedicatedServer.Data">
            <summary>
            All metadata for this dedicated server.
            </summary>
        </member>
        <member name="P:Sandbox.Network.DedicatedServer.Name">
            <summary>
            The current name of the dedicated server.
            </summary>
        </member>
        <member name="P:Sandbox.Network.DedicatedServer.MapName">
            <summary>
            The current map name of the dedicated server.
            </summary>
        </member>
        <member name="M:Sandbox.Network.DedicatedServer.SetData(System.String,System.String)">
            <summary>
            Set data for this dedicated server. This data is used when querying or filtering servers. Uses game tags
            internally, which have a hardcoded character limit enforced by Steam.
            </summary>
        </member>
        <member name="M:Sandbox.Network.DedicatedServer.GetData(System.String)">
            <summary>
            Get data for this dedicated server. This data is used when querying or filtering servers.
            </summary>
        </member>
        <member name="T:Sandbox.Network.InternalMessageType">
            <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.HeartbeatPing">
            <summary>
            A small message sent from the host to the client, and then returned to measure latency and keep
            everything in sync.
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.Chunk">
            <summary>
            Is multiple chunks of the same message
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.Packed">
            <summary>
            Is a struct packed using TypeLibrary
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.DeltaSnapshot">
            <summary>
            Is a delta snapshot message
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.DeltaSnapshotCluster">
            <summary>
            Is a delta snapshot cluster message
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.DeltaSnapshotAck">
            <summary>
            Is a delta snapshot acknowledgement
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.DeltaSnapshotClusterAck">
            <summary>
            Is a delta snapshot cluster acknowledgement
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.Request">
            <summary>
            A request, this is a guid, then another message
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.Response">
            <summary>
            A response, this is a guid, then another message
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyConfig.DestroyWhenHostLeaves">
            <summary>
            Whether to automatically destroy this lobby when the host leaves. This is only
            applicable to P2P lobbies.
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyConfig.AutoSwitchToBestHost">
            <summary>
            Whether to periodically switch to the best possible host candidate. This is only
            applicable to P2P lobbies.
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyConfig.Hidden">
            <summary>
            Whether to hide this lobby from appearing in the server list. It will still be
            queryable programatically, so long as the <see cref="P:Sandbox.Network.LobbyConfig.Privacy"/> mode allows it.
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyConfig.Privacy">
            <summary>
            Determines who is able to connect to this lobby. This will be public by default.
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyConfig.MaxPlayers">
            <summary>
            The maximum amount of players this lobby can hold. By default, this will be
            the Max Players set in the current Game Package's project settings.
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyConfig.Name">
            <summary>
            The name of this lobby. If this isn't set, a default lobby name will be chosen instead.
            </summary>
        </member>
        <member name="F:Sandbox.Network.LobbyPrivacy.Public">
            <summary>
            This lobby is open to everyone.
            </summary>
        </member>
        <member name="F:Sandbox.Network.LobbyPrivacy.Private">
            <summary>
            Nobody can join this lobby unless they are invited.
            </summary>
        </member>
        <member name="F:Sandbox.Network.LobbyPrivacy.FriendsOnly">
            <summary>
            Only friends can join this lobby.
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSocket.AutoDispose">
            <summary>
            Whether this socket should be disposed automatically when the network system
            it belongs to is disconnected.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.ProcessMessagesInThread">
            <summary>
            This is called on a worker thread and should handle any threaded processing of messages.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.Initialize(Sandbox.Network.NetworkSystem)">
            <summary>
            Called when everything has just been hooked up to the network system.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.OnConnectionInfoUpdated(Sandbox.Network.NetworkSystem)">
            <summary>
            ConnectionInfo table has been updated
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.OnSessionFailed(Sandbox.SteamId)">
            <summary>
            Called when a session has failed with a user. Steam Networking Messages will invoke this callback
            if an attempt to send a message to a user failed because of a broken session.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.SetData(System.String,System.String)">
            <summary>
            Set data about this socket. For example, this might be used to change whether a lobby
            should be visible for players depending on the game state.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.SetServerName(System.String)">
            <summary>
            Set the name of the server. This will be displayed to other players when they
            query servers.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.SetMapName(System.String)">
            <summary>
            Set the current map name. This will be displayed to other players when they
            query servers.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.Tick(Sandbox.Network.NetworkSystem)">
            <summary>
            Called once a second
            </summary>
        </member>
        <member name="T:Sandbox.Network.NetworkSystem">
            <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
            <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
            <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSystem.IsConnecting">
            <summary>
            True if we're currently connecting to the server. We're not yet spawned etc.
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSystem.IsDeveloperHost">
            <summary>
            If true then this host is sending assemblies and other files via network tables
            and as such, does not need to load assemblies from the package (if it even exists).
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.IsHandshaking">
            <summary>
            Get whether there are any connections still doing the handshake process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.FindConnection(System.Guid)">
            <summary>
            Find a connection by its unique id.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.StartHandshake(Sandbox.Connection)">
            <summary>
            Start the handshaking process with the specified client <see cref="P:Sandbox.Network.NetworkSystem.Connection"/>.
            </summary>
            <param name="channel"></param>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.RestartHandshake">
            <summary>
            Restart the handshaking process. This could be used if the host changed
            while we're connecting.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.AddConnection(Sandbox.Connection,Sandbox.UserInfo)">
            <summary>
            Called from the host to add a connection to the ConnectionInfo table
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnServerDisconnection(System.Int32,System.String)">
            <summary>
            We were disconnected from the server. This will almost always be when we're on a dedicated server
            and it has closed down.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnConnectionInfoUpdated">
            <summary>
            Called any time we suspect the connection info might have changed, which
            lets us tell the sockets/connections to update any information they hold.
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSystem.IsHost">
            <summary>
            Are we the owner of this network system? True if we're hosting
            the server, or we're the current owner of a p2p system.
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSystem.IsDisconnected">
            <summary>
            Has this network system been disconnected?
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSystem.IsHostBusy">
            <summary>
            Whether the host is busy right now. This can be used to determine if
            the host can be changed.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnLogMsg(Sandbox.Network.LogMsg,Sandbox.Connection,System.Guid)">
            <summary>
            We have received a log message from another client.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnUserInfoUpdate(Sandbox.Network.UserInfoUpdate,Sandbox.Connection,System.Guid)">
            <summary>
            We have received a UserInfo ConVar value update from a client.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnServerCommand(Sandbox.Network.ServerCommand,Sandbox.Connection,System.Guid)">
            <summary>
            We have received a console command from a client that should be run on the server.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnReceiveHostStats(Sandbox.Network.HostStats,Sandbox.Connection,System.Guid)">
            <summary>
            We have received network / performance stats from the server.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnReceiveServerName(Sandbox.Network.ServerNameMsg,Sandbox.Connection,System.Guid)">
            <summary>
            We have received a changed server name.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnReceiveMapName(Sandbox.Network.MapNameMsg,Sandbox.Connection,System.Guid)">
            <summary>
            We have received a changed map name.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnReceiveServerData(Sandbox.Network.ServerDataMsg,Sandbox.Connection,System.Guid)">
            <summary>
            We have received changed data from the server.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnReconnectMsg(Sandbox.Network.ReconnectMsg,Sandbox.Connection,System.Guid)">
            <summary>
            The server has told us to reconnect
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnTargetedInternalMessage(Sandbox.Network.TargetedInternalMessage,Sandbox.Connection,System.Guid)">
            <summary>
            We have received a message intended for a different connection.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnTargetedMessage(Sandbox.Network.TargetedMessage,Sandbox.Connection,System.Guid)">
            <summary>
            We have received a message intended for a different connection.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.Tick">
            <summary>
            Called to read and process incoming messages.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.On_Handshake_ServerInfo(Sandbox.Network.ServerInfo,Sandbox.Connection,System.Guid)">
            <summary>
            Server says hello to the client. It tells the client some basic information about itself.
            The client can determine here whether they still want to join or not.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.ProcessMessagesInThread">
            <summary>
            Process any incoming or outgoing messages. This would usually be called on a worker thread unless
            threaded networking is disabled.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.Broadcast(Sandbox.ByteStream,Sandbox.Connection.ChannelState,System.Nullable{Sandbox.Connection.Filter},Sandbox.NetFlags)">
            <summary>
            Send a message to all connections. You can optionally pass in a filter to determine who actually receives the message.
            </summary>
            <param name="msg">The message to send.</param>
            <param name="minimumState">The minumum state the connection must be to receive the message.</param>
            <param name="filter">If specified, the connection must pass this filter to receive the message.</param>
            <param name="flags">Network message flags that may dictate how the message is sent.</param>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.Broadcast``1(``0,Sandbox.Connection.ChannelState,System.Nullable{Sandbox.Connection.Filter},Sandbox.NetFlags)">
            <summary>
            Broadcast a packed message to all connections.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.GetFilteredConnections(Sandbox.Connection.ChannelState,System.Nullable{Sandbox.Connection.Filter})">
            <summary>
            Get a list of connections that meet a specific criteria.
            </summary>
            <param name="minimumState">The minumum state the connection must be to receive the message.</param>
            <param name="filter">If specified, the connection must pass this filter to receive the message.</param>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.InstallStringTables">
            <summary>
            String tables should all get installed at this point.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.InstallTable(Sandbox.Network.StringTable)">
            <summary>
            Install a network table. If we're the host then this table will
            be sent to all clients.. but only if they have the same named network
            table installed.
            </summary>
        </member>
        <member name="F:Sandbox.Network.StringTable.MaxSnapshotEntrySize">
            <summary>
            The maximum size of a snapshot entry in megabytes.
            </summary>
        </member>
        <member name="F:Sandbox.Network.StringTable.OnChangeOrAdd">
            <summary>
            Called when a table entry is changed or added from the network
            </summary>
        </member>
        <member name="F:Sandbox.Network.StringTable.OnSnapshot">
            <summary>
            The table has been fully replaced. Anything or everything could have changed.
            </summary>
        </member>
        <member name="F:Sandbox.Network.StringTable.OnRemoved">
            <summary>
            Called when a table entry is removed by the network
            </summary>
        </member>
        <member name="F:Sandbox.Network.StringTable.PostNetworkUpdate">
            <summary>
            Called after a network update of the table is complete. Not called after snapshots!
            </summary>
        </member>
        <member name="M:Sandbox.Network.StringTable.Entry.Read``1">
            <summary>
            Read an unmanaged struct from the data
            </summary>
        </member>
        <member name="T:Sandbox.Network.EmptyConnection">
            <summary>
            An empty connection that can be used for testing and optimizing processing.
            Messages can not actually be sent to it, and it won't receive any either. Other clients
            will be unaware of it.
            </summary>
        </member>
        <member name="T:Sandbox.Network.LocalConnection">
            <summary>
            A mock channel. Allows passing this to RPCs when they're being called locally.
            </summary>
        </member>
        <member name="T:Sandbox.Network.MockConnection">
            <summary>
            A mock channel. Allows passing this to RPCs when they're being called locally. Mock connections
            will also exist for other clients when connected to a dedicated server. If we try to send a message
            to one, we'll route that message through the server instead.
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamLobbyConnection">
            <summary>
            A direct connection to a peer in a lobby.
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamLobbySocket">
            <summary>
            A fake socket that wraps around a Steam lobby.
            </summary>
        </member>
        <member name="F:Sandbox.Network.SteamLobbySocket.nextTryFindHost">
            <summary>
            The time until we should try to find a new host.
            </summary>
        </member>
        <member name="P:Sandbox.Network.SteamLobbySocket.HostSteamId">
            <summary>
            The SteamId of the host of this lobby.
            </summary>
        </member>
        <member name="P:Sandbox.Network.SteamLobbySocket.LobbySteamId">
            <summary>
            The SteamId of the host of this lobby.
            </summary>
        </member>
        <member name="P:Sandbox.Network.SteamLobbySocket.LobbyMemberCount">
            <summary>
            How many cunts are in this lobby.
            </summary>
        </member>
        <member name="F:Sandbox.Network.SteamLobbySocket.Owner">
            <summary>
            Current owner of this lobby.
            </summary>
        </member>
        <member name="F:Sandbox.Network.SteamLobbySocket.SteamLobby">
            <summary>
            The underlying Steam lobby.
            </summary>
        </member>
        <member name="F:Sandbox.Network.SteamLobbySocket.config">
            <summary>
            Current config of this lobby.
            </summary>
        </member>
        <member name="M:Sandbox.Network.SteamLobbySocket.SendMessage(System.UInt64,System.Byte[]@,System.Int32)">
            <summary>
            Enqueue a message to be sent to a user on a different thread.
            </summary>
            <param name="steamId"></param>
            <param name="data"></param>
            <param name="flags"></param>
        </member>
        <member name="M:Sandbox.Network.SteamLobbySocket.ProcessIncomingMessages(ISteamNetworkingMessages@,System.Int32)">
            <summary>
            Process any incoming messages from Steam networking and enqueue them to be
            handled by the main thread.
            </summary>
            <param name="net"></param>
            <param name="channel"></param>
        </member>
        <member name="M:Sandbox.Network.SteamLobbySocket.ProcessOutgoingMessage(ISteamNetworkingMessages,Sandbox.Network.SteamLobbySocket.OutgoingMessage@)">
            <summary>
            Send any queued outgoing messages via Steam Networking API. 
            </summary>
        </member>
        <member name="M:Sandbox.Network.SteamLobbySocket.ProcessMessagesInThread">
            <summary>
            Send any queued outgoing messages and process any incoming messages to be queued for handling
            on the main thread.
            </summary>
        </member>
        <member name="M:Sandbox.Network.SteamLobbySocket.SetConnectionId(System.UInt64,Sandbox.Network.ConnectionInfo)">
            <summary>
            Make sure this steamid has this connection id
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.IdConnection">
            <summary>
            A connection to a SteamId. This can be a SteamId of an individual Steam user
            or an assigned SteamId for a game server.
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.IpConnection">
            <summary>
            A connection to an IP and port.
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.SocketConnection">
            <summary>
            A connection from a listen socket.
            </summary>
        </member>
        <member name="M:Sandbox.Network.SteamNetwork.Connection.ProcessMessagesInThread">
            <summary>
            Send any queued outgoing messages and process any incoming messages to be queued for handling
            on the main thread.
            </summary>
        </member>
        <member name="M:Sandbox.Network.SteamNetwork.Connection.ProcessIncomingMessages(ISteamNetworkingSockets)">
            <summary>
            Process any incoming messages from Steam networking and enqueue them to be
            handled by the main thread.
            </summary>
            <param name="net"></param>
        </member>
        <member name="M:Sandbox.Network.SteamNetwork.Connection.ProcessOutgoingMessage(Sandbox.Network.OutgoingSteamMessage@)">
            <summary>
            Send any queued outgoing messages via Steam Networking API. 
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Sandbox.Network.SteamNetwork.RunCallbacks">
            <summary>
            This gets called by the SteamAPI, so only really need to call this in unit tests.
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.IdListenSocket">
            <summary>
            A socket that listens on a SteamId and virtual port.
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.IpListenSocket">
            <summary>
            A socket that listens on an IP address and port.
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.Socket">
            <summary>
            A listen socket, one socket to many. We should really use this just for dedicated servers.
            </summary>
        </member>
        <member name="M:Sandbox.Network.SteamNetwork.Socket.SendMessage(Sandbox.Network.HSteamNetConnection,System.Byte[]@,System.Int32)">
            <summary>
            Enqueue a message to be sent to a user on a different thread.
            </summary>
            <param name="connection"></param>
            <param name="data"></param>
            <param name="flags"></param>
        </member>
        <member name="M:Sandbox.Network.SteamNetwork.Socket.ProcessMessagesInThread">
            <summary>
            Send any queued outgoing messages and process any incoming messages to be queued for handling
            on the main thread.
            </summary>
        </member>
        <member name="M:Sandbox.Network.SteamNetwork.Socket.ProcessIncomingMessages(ISteamNetworkingSockets@)">
            <summary>
            Process any incoming messages from Steam networking and enqueue them to be
            handled by the main thread.
            </summary>
            <param name="net"></param>
        </member>
        <member name="M:Sandbox.Network.SteamNetwork.Socket.ProcessOutgoingMessage(Sandbox.Network.OutgoingSteamMessage@)">
            <summary>
            Send any queued outgoing messages via Steam Networking API. 
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Sandbox.Network.HSteamNetConnection">
            <summary>
            A handle to a connection.
            </summary>
        </member>
        <member name="T:Sandbox.Network.HSteamListenSocket">
            <summary>
            A handle to a listen socket
            </summary>
        </member>
        <member name="T:Sandbox.Network.HSteamNetPollGroup">
            <summary>
            A handle to a poll group
            </summary>
        </member>
        <member name="T:Sandbox.Network.TcpChannel">
            <summary>
            A listen socket, one socket to many. We should really use this just dedicated servers imo.
            </summary>
        </member>
        <member name="M:Sandbox.Network.TcpChannel.SendThread(System.Threading.CancellationToken)">
            <summary>
            Send the network data in a thread. This prevents the client from freezing
            up when running a client and server in the same process. In reality this only
            really happens in unit tests, but better safe than sorry.
            </summary>
        </member>
        <member name="T:Sandbox.Network.TcpSocket">
            <summary>
            A listen socket over TCP. For testing locally.
            </summary>
        </member>
        <member name="T:Sandbox.Networking">
            <summary>
            Global manager to hold and tick the singleton instance of NetworkSystem.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.SetData(System.String,System.String)">
            <summary>
            Set data about the current server or lobby. Other players can query this
            when searching for a game. Note: for now, try to keep the key and value as short
            as possible, Steam enforce a character limit on server tags, so it could be possible
            to reach that limit when running a Dedicated Server. In the future we'll store this
            stuff on our backend, so that won't be a problem.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.GetData(System.String,System.String)">
            <summary>
            Get data about the current server or lobby. This data can be used for filtering
            when querying lobbies.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.ServerName">
            <summary>
            The name of the server you are currently connected to.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.MapName">
            <summary>
            The name of the map being used on the server you're connected to.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.MaxPlayers">
            <summary>
            The maximum number of players allowed on the server you're connected to.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.LastConnectionString">
            <summary>
            The last connection string used to connect to a server.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.HostStats">
            <summary>
            Get the latest host stats such as bandwidth used and the current frame rate.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.IsHost">
            <summary>
            True if we can be considered the host of this session. Either we're not connected to a server, or we are host of a server.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.IsClient">
            <summary>
            True if we're currently connected to a server, and we are not the host
            </summary>
        </member>
        <member name="P:Sandbox.Networking.IsConnecting">
            <summary>
            True if we're currently connecting to the server
            </summary>
        </member>
        <member name="P:Sandbox.Networking.IsActive">
            <summary>
            True if we're currently connecting to the server
            </summary>
        </member>
        <member name="P:Sandbox.Networking.IsDisconnecting">
            <summary>
            True if we're currently disconnecting from the server
            </summary>
        </member>
        <member name="P:Sandbox.Networking.HostConnection">
            <summary>
            The connection of the current network host.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.IsHostBusy">
            <summary>
            Whether the host is busy right now. This can be used to determine if
            the host can be changed.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.Connections">
            <summary>
            A list of connections that are currently on this server. If you're not on a server
            this will return only one connection (Connection.Local). Some games restrict the 
            connection list - in which case you will get an empty list.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.UpdateServerName(System.String)">
            <summary>
            Internally update the server name without propagating to sockets.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Sandbox.Networking.GetSteamRelayStatus(System.String@)">
            <summary>
            Get the status of our connection to the Steam Datagram Relay service.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Networking.Reset">
            <summary>
            Reset any static members to their defaults or clear them.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.JoinBestLobby(System.String)">
            <summary>
            Try to join the best lobby. Return true on success.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.EditorLobbyPrivacy">
            <summary>
            When creating a lobby from the editor, we'll use this override for the lobby privacy.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.CreateLobby(Sandbox.Network.LobbyConfig)">
            <summary>
            Will create a new lobby with the specified <see cref="T:Sandbox.Network.LobbyConfig"/> to
            customize the lobby further.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.CreateLobby">
            <summary>
            Will create a new lobby.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.Disconnect">
            <summary>
            Disconnect from current multiplayer session.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.Connect(System.String)">
            <summary>
            Will try to determine the right method for connection, and then try to connect.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.TryConnectSteamId(Sandbox.SteamId)">
            <summary>
            Will try to connect to a server. Will return false if failed to connect.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.QueryLobbies">
            <summary>
            Get all lobbies for the current game.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.QueryLobbies(System.String)">
            <summary>
            Get all lobbies for a specific game.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.QueryLobbies(System.String,System.String)">
            <summary>
            Get all lobbies for a specific game and map.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.QueryLobbies(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Get all lobbies that match the specified filters.
            </summary>
            <param name="filters"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Networking.StartReconnecting(Sandbox.Network.ReconnectMsg)">
            <summary>
            The client has been told to reconnect to the server. So disconnect and keep trying to connect.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.Reconnect(Sandbox.Network.ReconnectMsg,System.String)">
            <summary>
            The client has been told to reconnect to the server. Keep trying for 30 seconds.
            </summary>
        </member>
        <member name="M:Sandbox.Debug.Networking.AddEmptyConnection">
            <summary>
            Add an empty connection for debugging purposes. This connection cannot receive or send data and
            it won't be visible to other clients.
            </summary>
        </member>
        <member name="P:Sandbox.UserInfo.Local">
            <summary>
            Build info for the local user, which will then get sent to the server and possibly shared between all clients
            </summary>
        </member>
        <member name="T:Sandbox.Connection">
            <summary>
            A connection, usually to a server or a client.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.OnReceiveServerInfo(Sandbox.UserInfo@,Sandbox.Network.ServerInfo)">
            <summary>
            Called when we receive <see cref="T:Sandbox.Network.ServerInfo"/> from this <see cref="T:Sandbox.Connection"/>.
            </summary>
            <param name="userInfo">Our outgoing <see cref="T:Sandbox.UserInfo"/> data.</param>
            <param name="serverInfo"></param>
            <returns>Whether or not we want to continue to connect.</returns>
        </member>
        <member name="M:Sandbox.Connection.OnReceiveUserInfo(Sandbox.UserInfo)">
            <summary>
            Called when we receive <see cref="T:Sandbox.UserInfo"/> from this <see cref="T:Sandbox.Connection"/>.
            </summary>
            <param name="info"></param>
            <returns>Whether or not we want to allow this connection</returns>
        </member>
        <member name="M:Sandbox.Connection.HasPermission(System.String)">
            <summary>
            Get whether this connection has a specific permission.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.Id">
            <summary>
            This connection's unique identifier.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.HandshakeId">
            <summary>
            A unique identifier that is set when the connection starts handshaking. This identifier will
            be passed into all handshake messages, so that if a new handshaking process starts while one
            is already active, old handshake messages will be ignored.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.System">
            <summary>
            The <see cref="T:Sandbox.Network.NetworkSystem"/> this connection belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.CanSpawnObjects">
            <summary>
            Can this connection spawn networked objects?
            </summary>
        </member>
        <member name="P:Sandbox.Connection.CanRefreshObjects">
            <summary>
            Can this connection refresh networked objects that they own?
            </summary>
        </member>
        <member name="P:Sandbox.Connection.IsConnecting">
            <summary>
            True if this channel is still currently connecting.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.IsActive">
            <summary>
            True if this channel is fully connnected and fully logged on.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.MessagesSent">
            <summary>
            How many messages have been sent to this connection?
            </summary>
        </member>
        <member name="P:Sandbox.Connection.MessagesRecieved">
            <summary>
            How many messages have been received from this connection?
            </summary>
        </member>
        <member name="M:Sandbox.Connection.Kick(System.String)">
            <summary>
            Kick this <see cref="T:Sandbox.Connection"/> from the server. Only the host can kick clients.
            </summary>
            <param name="reason">The reason to display to this client.</param>
        </member>
        <member name="M:Sandbox.Connection.SendLog(Sandbox.LogLevel,System.String)">
            <summary>
            Log a message to the console for this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.Stats">
            <summary>
            Get stats about this connection such as bandwidth usage and how many packets are being
            sent and received.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.SendMessage``1(``0)">
            <summary>
            Send a message to this connection.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.ProcessMessagesInThread">
            <summary>
            This is called on a worker thread and should handle any threaded processing of messages.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.State">
            <summary>
            Current internal progression of this connection.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.GenerateConnectionId">
            <summary>
            Generate an ID for this connection. This is called by the server to allocate
            the connection an identifier. We're avoiding sequential, allocated ids because
            who needs to deal with that bullshit.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.UpdateFrom(Sandbox.Network.ChannelInfo)">
            <summary>
            Update this channel's info. Usually called from the host.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.Tick(Sandbox.Network.NetworkSystem)">
            <summary>
            Called once a second.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.Ping">
            <summary>
            The ping of this connection (in milliseconds.)
            </summary>
        </member>
        <member name="M:Sandbox.Connection.UpdateRtt(System.Single)">
            <summary>
            The server has worked out the round trip time on a connection using the heartbeat.
            We want to keep a sliding window of this timing and use it to predict the latency.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.PreInfo">
            <summary>
            The connection info before connection is added
            </summary>
        </member>
        <member name="P:Sandbox.Connection.PartyId">
            <summary>
            The Id of the party that this user is a part of. This can be used to compare to other users to 
            group them into parties.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.UpdateUserData(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            New, updated UserInfo data arrived. Replace our old data with this.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.SetUserData(System.String,System.String)">
            <summary>
            Set or update an individual UserInfo data key.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="F:Sandbox.Connection.Filter.FilterType.Include">
            <summary>
            Only include the connections in the filter when sending a message.
            </summary>
        </member>
        <member name="F:Sandbox.Connection.Filter.FilterType.Exclude">
            <summary>
            Exclude the connections in the filter when sending a message.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.Filter.IsRecipient(Sandbox.Connection)">
            <summary>
            Is the specified <see cref="T:Sandbox.Connection"/> a valid recipient?
            </summary>
        </member>
        <member name="M:Sandbox.Connection.SendRequest``1(``0)">
            <summary>
            Send a message to this connection, wait for a response
            </summary>
        </member>
        <member name="M:Sandbox.Connection.SendResponse``1(System.Guid,``0)">
            <summary>
            Send a response message to this connection.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.OnResponse(System.Guid,System.Object)">
            <summary>
            A response to a message has arrived, route it to the correct async function
            </summary>
        </member>
        <member name="P:Sandbox.Connection.Local">
            <summary>
            This is a "fake" connection for the local player. It is passed to RPCs when calling them
            locally etc.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.All">
            <summary>
            A list of connections that are currently on this server. If you're not on a server
            this will return only one connection (Connection.Local). Some games restrict the 
            connection list - in which case you will get an empty list.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.Host">
            <summary>
            The connection of the current network host.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.Find(System.Guid)">
            <summary>
            Find a <see cref="T:Sandbox.Connection"/> for a Connection Id.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.Reset">
            <summary>
            Reset any static members to their defaults or clear them.
            </summary>
        </member>
        <member name="F:Sandbox.NetFlags.Unreliable">
            <summary>
            Message will be sent unreliably. It may not arrive and it may be received out of order. But chances
            are that it will arrive on time and everything will be fine. This is good for sending position updates,
            or spawning effects. This is the fastest way to send a message. It is also the cheapest.
            </summary>
        </member>
        <member name="F:Sandbox.NetFlags.Reliable">
            <summary>
            Message will be sent reliably. Multiple attempts will be made until the recipient has received it. Use this for things
            like chat messages, or important events. This is the slowest way to send a message. It is also the most expensive.
            </summary>
        </member>
        <member name="F:Sandbox.NetFlags.SendImmediate">
            <summary>
            Message will not be grouped up with other messages, and will be sent immediately. This is most useful for things like 
            streaming voice data, where packets need to stream in real-time, rather than arriving with a bunch of other packets.
            </summary>
        </member>
        <member name="F:Sandbox.NetFlags.DiscardOnDelay">
            <summary>
            Message will be dropped if it can't be sent quickly. Only applicable to unreliable messages.
            </summary>
        </member>
        <member name="F:Sandbox.NetFlags.HostOnly">
            <summary>
            Only the host may call this action
            </summary>
        </member>
        <member name="F:Sandbox.NetFlags.OwnerOnly">
            <summary>
            Only the owner may call this action
            </summary>
        </member>
        <member name="F:Sandbox.NetFlags.UnreliableNoDelay">
            <summary>
            Message will be sent unreliably, not grouped up with other messages and will be dropped if it can't be sent quickly.
            </summary>
        </member>
        <member name="T:Sandbox.RpcMode">
            <summary>
            Specifies who can invoke an action over the network.
            </summary>
        </member>
        <member name="F:Sandbox.RpcMode.Broadcast">
            <summary>
            Send to everyone
            </summary>
        </member>
        <member name="F:Sandbox.RpcMode.Owner">
            <summary>
            Send to the owner of this
            </summary>
        </member>
        <member name="F:Sandbox.RpcMode.Host">
            <summary>
            Only send to the host.
            </summary>
        </member>
        <member name="M:Sandbox.NetFlagExtensions.ToSteamFlags(Sandbox.NetFlags)">
            <summary>
            Convert these flags to an integer usable with the Steam Networking API.
            </summary>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.LargeNetworkFiles.Reset">
            <summary>
            Reset the string table.
            </summary>
        </member>
        <member name="M:Sandbox.LargeNetworkFiles.Refresh">
            <summary>
            Add all files from the network.
            </summary>
        </member>
        <member name="M:Sandbox.LargeNetworkFiles.AddFile(System.String)">
            <summary>
            Add a file to be networked.
            </summary>
        </member>
        <member name="M:Sandbox.LargeNetworkFiles.RemoveFile(System.String)">
            <summary>
            Remove a networked file.
            </summary>
        </member>
        <member name="T:Sandbox.ServerPackages">
            <summary>
            Manages the network string table "ServerPackages", which contains a list of packages that the client should
            have installed. During join the client will install these packages before loading in.
            </summary>
        </member>
        <member name="M:Sandbox.SmallNetworkFiles.Reset">
            <summary>
            Reset the string table.
            </summary>
        </member>
        <member name="M:Sandbox.SmallNetworkFiles.Refresh">
            <summary>
            Add all files from the network.
            </summary>
        </member>
        <member name="M:Sandbox.SmallNetworkFiles.AddFile(Sandbox.BaseFileSystem,System.String,System.Byte[])">
            <summary>
            Add a file to be networked.
            </summary>
        </member>
        <member name="M:Sandbox.SmallNetworkFiles.RemoveFile(System.String)">
            <summary>
            Remove a networked file.
            </summary>
        </member>
        <member name="T:Sandbox.UserPermission">
            <summary>
            A static class that handles user permissions.
            </summary>
        </member>
        <member name="T:Sandbox.UserPermission.User">
            <summary>
            Represents a user in the user permissions config.
            </summary>
        </member>
        <member name="M:Sandbox.UserPermission.Has(Sandbox.SteamId,System.String)">
            <summary>
            Get whether or not the specified <see cref="T:Sandbox.SteamId"/> has this permission.
            </summary>
        </member>
        <member name="M:Sandbox.UserPermission.Save">
            <summary>
            Save user permissions to disk.
            </summary>
        </member>
        <member name="M:Sandbox.UserPermission.Load">
            <summary>
            Load user permissions from disk. The file location should be <b>"config/users.json"</b>.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.BallSocketJoint">
            <summary>
            A ballsocket constraint.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.BallSocketJoint.Friction">
            <summary>
            Constraint friction.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.BallSocketJoint.SwingLimit">
            <summary>
            Maximum angle it should be allowed to swing to
            </summary>
        </member>
        <member name="T:Sandbox.Physics.FixedJoint">
            <summary>
            A generic "rope" type constraint.
            </summary>
            <remarks>
            TODO: How is this different from <see cref="T:Sandbox.Physics.SpringJoint"/>? Should they be merged?
            </remarks>
        </member>
        <member name="P:Sandbox.Physics.FixedJoint.SpringLinear">
            <summary>
            How springy and tight the joint will be in its movement.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.FixedJoint.SpringAngular">
            <summary>
            How springy and tight the joint will be in its rotation.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.HingeJoint">
            <summary>
            A hinge-like constraint.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.HingeJoint.MaxAngle">
            <summary>
            Maximum angle it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.HingeJoint.MinAngle">
            <summary>
            Minimum angle it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.HingeJoint.Friction">
            <summary>
            Hinge friction.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.PulleyJoint">
             <summary>
             A pulley constraint. Consists of 2 ropes which share same length, and the ratio changes via physics interactions.
            
             Typical setup looks like this:
             <code>
                @-----------------@
                |                 |
                |                 |
             Object A          Object B
             </code>
             </summary>
        </member>
        <member name="T:Sandbox.Physics.SliderJoint">
            <summary>
            A slider constraint, basically allows movement only on the arbitrary axis between the 2 constrained objects on creation.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SliderJoint.MaxLength">
            <summary>
            Maximum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SliderJoint.MinLength">
            <summary>
            Minimum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SliderJoint.Friction">
            <summary>
            Slider friction.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.SpringJoint">
            <summary>
            A rope-like constraint that is has springy/bouncy.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SpringJoint.SpringLinear">
            <summary>
            How springy and tight the joint will be
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SpringJoint.MaxLength">
            <summary>
            Maximum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SpringJoint.MinLength">
            <summary>
            Minimum length it should be allowed to go. At which point it acts a bit like a rod.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SpringJoint.MaxForce">
            <summary>
            Maximum force it should be allowed to go. Set to zero to only allow stretching.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SpringJoint.MinForce">
            <summary>
            Minimum force it should be allowed to go.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.PhysicsJoint">
            <summary>
            A physics constraint.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.Remove">
            <summary>
            Removes this joint.
            </summary>
        </member>
        <member name="E:Sandbox.Physics.PhysicsJoint.OnBreak">
            <summary>
            Called when the joint breaks.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.World">
            <summary>
            The <see cref="T:Sandbox.PhysicsWorld"/> this joint belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Body1">
            <summary>
            The source physics body this joint is attached to.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Body2">
            <summary>
            The target physics body this joint is constraining.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Point1">
            <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Physics.PhysicsJoint.Body1"/>
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Point2">
            <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Physics.PhysicsJoint.Body2"/>
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Collisions">
            <summary>
            Enables or disables collisions between the 2 constrained physics bodies.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Strength">
            <summary>
            Strength of the linear constraint. If it takes any more energy than this, it'll break.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.AngularStrength">
            <summary>
            Strength of the angular constraint. If it takes any more energy than this, it'll break.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateFixed(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint)">
            <summary>
            Creates an almost solid constraint between two physics bodies.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateLength(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint,System.Single)">
            <summary>
            Creates a constraint like a rope, where it has no minimum length but its max length is restrained.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateSpring(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint,System.Single,System.Single)">
            <summary>
            Creates a constraint that will try to stay the same length, like a spring, or a rod.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateSlider(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint,System.Single,System.Single)">
            <summary>
            Creates a slider constraint between two physics bodies via <see cref="T:Sandbox.Physics.PhysicsPoint"/>s.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateBallSocket(Sandbox.PhysicsBody,Sandbox.PhysicsBody,Vector3)">
            <summary>
            Creates a ball socket constraint.
            </summary>
            <param name="body1">The source physics body.</param>
            <param name="body2">The target physics body to constrain to.</param>
            <param name="origin">The origin of the hinge in world coordinates. The 2 bodies will rotate around this point.</param>
            <returns>The created ball socket joint.</returns>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateBallSocket(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint)">
            <summary>
            Creates a ball socket constraint.
            </summary>
            <param name="a">The source physics body.</param>
            <param name="b">The target physics body to constrain to.</param>
            <returns>The created ball socket joint.</returns>
        </member>
        <member name="T:Sandbox.Physics.PhysicsPoint">
            <summary>
            Used to describe a point on a physics body. This is used for things like joints where
            you want to pass in just a body, or sometimes you want to pass in a body with a specific
            location and rotation to attach to.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsPoint.Body">
            <summary>
            The physics body this point is attached to.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsPoint.LocalPosition">
            <summary>
            Position offset from the body's position.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsPoint.LocalRotation">
            <summary>
            Rotation offset from the body's position.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsPoint.LocalTransform">
            <summary>
            A transform relative to <see cref="F:Sandbox.Physics.PhysicsPoint.Body"/>, containing <see cref="F:Sandbox.Physics.PhysicsPoint.LocalPosition"/> and <see cref="F:Sandbox.Physics.PhysicsPoint.LocalRotation"/> with scale of 1.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsPoint.Transform">
            <summary>
            Transform of this point in world space.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsPoint.Local(Sandbox.PhysicsBody,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Describe an attachment using a position/rotation local to the body
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsPoint.World(Sandbox.PhysicsBody,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Describe an attachment using a position/rotation from the world
            </summary>
        </member>
        <member name="T:Sandbox.Physics.PhysicsSpring">
            <summary>
            Spring related settings for joints such as <see cref="T:Sandbox.Physics.FixedJoint"/>.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsSpring.Frequency">
            <summary>
            The stiffness of the spring
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsSpring.Damping">
            <summary>
            The damping ratio of the spring, usually between 0 and 1
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsSpring.Maximum">
            <summary>
            For weld joints only, maximum force. Not for breaking.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.CollisionRules">
            <summary>
            This is a JSON serializable description of the physics's collision rules. This allows us to send it
            to the engine - and store it in a string table (which is networked to the client). You shouldn't really
            ever have to mess with this, it's just used internally.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.CollisionRules.Result">
            <summary>
            Result of a collision between <see cref="T:Sandbox.Physics.CollisionRules.Pair">two objects</see>.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.CollisionRules.Result.Unset">
            <summary>
            Fallback to default behavior.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.CollisionRules.Result.Collide">
            <summary>
            Collide.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.CollisionRules.Result.Trigger">
            <summary>
            Do not collide, but trigger touch callbacks.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.CollisionRules.Result.Ignore">
            <summary>
            Do not collide.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.CollisionRules.Pair">
            <summary>
            A pair of case- and order-insensitive tags, used as a key to look up a <see cref="T:Sandbox.Physics.CollisionRules.Result"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.op_Implicit(System.ValueTuple{System.String,System.String})~Sandbox.Physics.CollisionRules.Pair">
            <summary>
            Initializes from a pair of tags.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Pair.Left">
            <summary>
            First of the two tags.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Pair.Right">
            <summary>
            Second of the two tags.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.#ctor(System.String,System.String)">
            <summary>
            Initializes from a pair of tags.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.Contains(System.String)">
            <summary>
            Returns true if either <see cref="P:Sandbox.Physics.CollisionRules.Pair.Left"/> or <see cref="P:Sandbox.Physics.CollisionRules.Pair.Right"/> matches the given tag.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.Equals(Sandbox.Physics.CollisionRules.Pair)">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.GetHashCode">
            <inheritdoc />
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Defaults">
            <summary>
            If no pair matching is found, this is what we'll use
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Pairs">
            <summary>
            What happens when a pair collides
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Tags">
            <summary>
            All tags with either an entry in <see cref="P:Sandbox.Physics.CollisionRules.Defaults"/> or <see cref="P:Sandbox.Physics.CollisionRules.Pairs"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.SerializedPairs">
            <summary>
            Gets or sets <see cref="P:Sandbox.Physics.CollisionRules.Pairs"/> in its serialized form for JSON.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.LeastColliding(Sandbox.Physics.CollisionRules.Result,Sandbox.Physics.CollisionRules.Result)">
            <summary>
            Selects the result with the highest precedence (least colliding).
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.GetCollisionRule(System.String,System.String)">
            <summary>
            Gets the specific collision rule for a pair of tags.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.GetCollisionRules(System.String)">
            <summary>
            For each known tag, what result does it have when tested against the given <paramref name="tag"/>?
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.GetCollisionRules(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            For each known tag, what result does it have when tested against the given set of <paramref name="tags"/>?
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Clean">
            <summary>
            Remove duplicates etc
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsSettings.UseFixedUpdate">
            <summary>
            If false, then instead of operating physics, and UpdateFixed in a fixed update frequency
            they will be called the same as Update - every frame, with a variable time delta.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsSettings.SubSteps">
            <summary>
            If you're seeing objects go through other objects or you have a low tickrate, you might want to increase the number of physics substeps.
            This breaks physics steps down into this many substeps. The default is 1 and works pretty good.
            Be aware that the number of physics ticks per second is going to be tickrate * substeps.
            So if you're ticking at 90 and you have SubSteps set to 1000 then you're going to do 90,000 steps per second. So be careful here.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsSettings.FixedUpdateFrequency">
            <summary>
            How many times a second FixedUpdate runs
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsSettings.MaxFixedUpdates">
            <summary>
            If the frame took longer than a FixedUpdate step, we need to run multiple
            steps for that frame, to catch up. How many are allowed? Too few, and the 
            simluation will run slower than the game. If you allow an unlimited amount
            then the frame time could snowball to infinity and never catch up.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsBody">
            <summary>
            Represents a physics object. An entity can have multiple physics objects. See <see cref="P:Sandbox.PhysicsBody.PhysicsGroup">PhysicsGroup</see>.
            A physics objects consists of one or more <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
            <summary>
            Represents a physics object. An entity can have multiple physics objects. See <see cref="P:Sandbox.PhysicsBody.PhysicsGroup">PhysicsGroup</see>.
            A physics objects consists of one or more <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GameObject">
            <summary>
            The GameObject that created this body
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Component">
            <summary>
            The component that created this body
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Hitbox">
            <summary>
            The Hitbox that this physics body represents
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Position">
            <summary>
            Position of this body in world coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.World">
            <summary>
            The physics world this body belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Rotation">
            <summary>
            Rotation of the physics body in world space.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Velocity">
            <summary>
            Linear velocity of this body in world space.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.AngularVelocity">
            <summary>
            Angular velocity of this body in world space.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.MassCenter">
            <summary>
            Center of mass for this physics body in world space coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.LocalMassCenter">
            <summary>
            Center of mass for this physics body relative to its <see cref="P:Sandbox.PhysicsBody.Position">origin</see>.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.OverrideMassCenter">
            <summary>
            Is this physics body mass calculated or set directly.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Mass">
            <summary>
            Mass of this physics body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GravityEnabled">
            <summary>
            Whether gravity is enabled for this body or not.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableCollisionSounds">
            <summary>
            Whether to play collision sounds 
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GravityScale">
            <summary>
            Scale the gravity relative to <see cref="P:Sandbox.PhysicsWorld.Gravity"/>. 2 is double the gravity, etc.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.UseController">
            <summary>
            If true we'll create a controller for this physics body. This is useful
            for keyframed physics objects that need to push things. The controller will
            sweep as the entity moves, rather than teleporting the object.. which works better
            when pushing dynamic objects etc.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableTouch">
            <summary>
            Enables Touch callbacks on all <see cref="T:Sandbox.PhysicsShape">PhysicsShapes</see> of this body.
            Returns true if ANY of the physics shapes have touch events enabled.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableTouchPersists">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsShape.EnableTouchPersists"/> on all shapes of this body.
            <br/><br/>
            Returns true if ANY of the physics shapes have persistent touch events enabled.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableSolidCollisions">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsShape.EnableSolidCollisions"/> on all shapes of this body.
            <br/><br/>
            Returns true if ANY of the physics shapes have solid collisions enabled.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.BodyType">
            <summary>
            Movement type of physics body, either Static, Keyframed, Dynamic
            Note: If this body is networked and dynamic, it will return Keyframed on the client
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.NavmeshBodyTypeOverride">
            <summary>
            The bodytype may change between edit and game time.
            For navmesh generation we always need to know the bodytype at game time.
            This override can be set to inform the navmesh generation of the correct game time bodytype.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.AutoSleep">
            <summary>
            Whether this body is allowed to automatically go into "sleep" after a certain amount of time of inactivity.
            <see cref="P:Sandbox.PhysicsBody.Sleeping"/> for more info on the sleep mechanic.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Transform">
            <summary>
            Transform of this physics body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.Move(Transform,System.Single)">
            <summary>
            Move to a new position. Unlike Transform, if you have `UseController` enabled, this will sweep the shadow
            to the new position, rather than teleporting there.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.ShapeCount">
            <summary>
            How many shapes belong to this body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Shapes">
            <summary>
            All shapes that belong to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddSphereShape(Vector3,System.Single,System.Boolean)">
            <summary>
            Add a sphere shape to this body.
            </summary>
            <param name="center">Center of the sphere, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="radius">Radius of the sphere.</param>
            <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
            <returns>The newly created shape, if any.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddSphereShape(Sandbox.Sphere@,System.Boolean)">
            <summary>
            Add a sphere shape to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddCapsuleShape(Vector3,Vector3,System.Single,System.Boolean)">
            <summary>
            Add a capsule shape to this body.
            </summary>
            <param name="center">Point A of the capsule, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="center2">Point B of the capsule, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="radius">Radius of the capsule end caps.</param>
            <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
            <returns>The newly created shape, or null on failure.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddBoxShape(Vector3,Rotation,Vector3,System.Boolean)">
            <summary>
            Add a box shape to this body.
            </summary>
            <param name="position">Center of the box, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="rotation">Rotation of the box, relative to <see cref="P:Sandbox.PhysicsBody.Rotation"/> of this body.</param>
            <param name="extent">The extents of the box. The box will extend from its center by this much in both negative and positive directions of each axis.</param>
            <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
            <returns>The newly created shape, or null on failure.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddBoxShape(BBox,Rotation,System.Boolean)">
            <summary>
            Add a box shape to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddHullShape(Vector3,Rotation,System.Collections.Generic.List{Vector3},System.Boolean)">
            <inheritdoc cref="M:Sandbox.PhysicsBody.AddHullShape(Vector3,Rotation,System.Span{Vector3},System.Boolean)"/>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddHullShape(Vector3,Rotation,System.Span{Vector3},System.Boolean)">
            <summary>
            Add a convex hull shape to this body.
            </summary>
            <param name="position">Center of the hull, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="rotation">Rotation of the hull, relative to <see cref="P:Sandbox.PhysicsBody.Rotation"/> of this body.</param>
            <param name="points">Points for the hull. They will be used to generate a convex shape.</param>
            <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
            <returns>The newly created shape, or null on failure.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddCylinderShape(Vector3,Rotation,System.Single,System.Single,System.Int32)">
            <summary>
            Add a cylinder shape to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddConeShape(Vector3,Rotation,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Add a cone shape to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddMeshShape(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
            <inheritdoc cref="M:Sandbox.PhysicsBody.AddMeshShape(System.Span{Vector3},System.Span{System.Int32})"/>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddMeshShape(System.Span{Vector3},System.Span{System.Int32})">
            <summary>
            Adds a mesh type shape to this physics body. Mesh shapes cannot be physically simulated!
            </summary>
            <param name="vertices">Vertices of the mesh.</param>
            <param name="indices">Indices of the mesh.</param>
            <returns>The created shape, or null on failure.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.ClearShapes">
            <summary>
            Remove all physics shapes, but not the physics body itself.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.RemoveShape(Sandbox.PhysicsShape)">
            <summary>
            Called from Shape.Remove()
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.RebuildMass">
            <summary>
            Meant to be only used on <b>dynamic</b> bodies, rebuilds mass from all shapes of this body based on their volume and <see cref="P:Sandbox.PhysicsBody.Surface">physics properties</see>, for cases where they may have changed.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.Remove">
            <summary>
            Completely removes this physics body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyImpulse(Vector3)">
            <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body at its center of mass.
            For continuous force (i.e. a moving car), use <see cref="M:Sandbox.PhysicsBody.ApplyForce(Vector3)"/>
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyImpulseAt(Vector3,Vector3)">
            <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body at given position.
            For continuous force (i.e. a moving car), use <see cref="M:Sandbox.PhysicsBody.ApplyForceAt(Vector3,Vector3)"/>
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyAngularImpulse(Vector3)">
            <summary>
            Applies instant angular impulse (i.e. a bullet impact) to this body.
            For continuous force (i.e. a moving car), use <see cref="M:Sandbox.PhysicsBody.ApplyTorque(Vector3)"/>
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyForce(Vector3)">
            <summary>
            Applies force to this body at the center of mass.
            This force will only be applied on the next physics frame and is scaled with physics timestep.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyForceAt(Vector3,Vector3)">
            <summary>
            Applies force to this body at given position.
            This force will only be applied on the next physics frame and is scaled with physics timestep.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyTorque(Vector3)">
            <summary>
            Applies angular velocity to this body.
            This force will only be applied on the next physics frame and is scaled with physics timestep.
            </summary>
            <param name="force"></param>
        </member>
        <member name="M:Sandbox.PhysicsBody.ClearForces">
            <summary>
            Clear accumulated linear forces (<see cref="M:Sandbox.PhysicsBody.ApplyForce(Vector3)"/> and <see cref="M:Sandbox.PhysicsBody.ApplyForceAt(Vector3,Vector3)"/>) during this physics frame that were not yet applied to the physics body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ClearTorque">
            <summary>
            Clear accumulated torque (angular force, <see cref="M:Sandbox.PhysicsBody.ApplyTorque(Vector3)"/>) during this physics frame that were not yet applied to the physics body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.GetVelocityAtPoint(Vector3)">
            <summary>
            Returns the world space velocity of a point of the object. This is useful for objects rotating around their own axis/origin.
            </summary>
            <param name="point">The point to test, in world coordinates.</param>
            <returns>Velocity at the given point.</returns>
        </member>
        <member name="P:Sandbox.PhysicsBody.Enabled">
            <summary>
            Whether this body is enabled or not. Disables collisions, physics simulation, touch events, trace queries, etc.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.MotionEnabled">
            <summary>
            Controls physics simulation on this body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Sleeping">
            <summary>
            Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            You can use this to wake the body up, or prematurely send it to sleep.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.SpeculativeContactEnabled">
            <summary>
            If enabled, this physics body will move slightly ahead each frame based on its velocities.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Parent">
            <summary>
            The physics body we are attached to, if any
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.SelfOrParent">
            <summary>
            A convenience property, returns <see cref="P:Sandbox.PhysicsBody.Parent">Parent</see>, or if there is no parent, returns itself.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.PhysicsGroup">
            <summary>
            The physics group we belong to.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.FindClosestPoint(Vector3)">
            <summary>
            Returns the closest point to the given one between all shapes of this body.
            </summary>
            <param name="vec">Input position.</param>
            <returns>The closest possible position on the surface of the physics body to the given position.</returns>
        </member>
        <member name="P:Sandbox.PhysicsBody.LinearDamping">
            <summary>
            Generic linear damping, i.e. how much the physics body will slow down on its own.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.AngularDamping">
            <summary>
            Generic angular damping, i.e. how much the physics body will slow down on its own.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Inertia">
            <summary>
            The diagonal elements of the local inertia tensor matrix.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.InertiaRotation">
            <summary>
            The orientation of the principal axes of local inertia tensor matrix.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.SetInertiaTensor(Vector3,Rotation)">
            <summary>
            Sets the inertia tensor using the given moments and rotation.
            </summary>
            <param name="inertia">Principal moments (Ixx, Iyy, Izz).</param>
            <param name="rotation">Rotation of the principal axes.</param>
        </member>
        <member name="M:Sandbox.PhysicsBody.ResetInertiaTensor">
            <summary>
            Resets the inertia tensor to its calculated values.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.GetBounds">
            <summary>
            Returns Axis-Aligned Bounding Box (AABB) of this physics body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Density">
            <summary>
            Returns average of densities for all physics shapes of this body. This is based on <see cref="P:Sandbox.PhysicsShape.SurfaceMaterial"/> of each shape.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.LastWaterEffect">
            <summary>
            Time since last water splash effect. Used internally.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.SurfaceMaterial">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsShape.SurfaceMaterial"/> on all child <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
            <returns>
            The most commonly occurring surface name between all <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s of this <see cref="T:Sandbox.PhysicsShape">PhysicsBody</see>.
            </returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.LocalPoint(Vector3)">
            <summary>
            Convenience function that returns a <see cref="T:Sandbox.Physics.PhysicsPoint"/> from a position relative to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.WorldPoint(Vector3)">
            <summary>
            Convenience function that returns a <see cref="T:Sandbox.Physics.PhysicsPoint"/> for this body from a world space position.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.MassCenterPoint">
            <summary>
            Returns a <see cref="T:Sandbox.Physics.PhysicsPoint"/> at the center of mass of this body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GroupName">
            <summary>
            What is this body called in the group?
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GroupIndex">
            <summary>
            Return the index of this body in its PhysicsGroup
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.CheckOverlap(Sandbox.PhysicsBody)">
            <summary>
            Checks if another body overlaps us, ignoring all collision rules
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.CheckOverlap(Sandbox.PhysicsBody,Transform)">
            <summary>
            Checks if another body overlaps us at a given transform, ignoring all collision rules
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.IsTouching(Sandbox.PhysicsBody,System.Boolean)">
            <summary>
            Checks if there's any contact points with another body
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.IsTouching(Sandbox.PhysicsShape,System.Boolean)">
            <summary>
            Checks if there's any contact points with another shape
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddShape(Sandbox.PhysicsGroupDescription.BodyPart.HullPart,Transform,System.Boolean)">
            <summary>
            Add a shape from a physics hull
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddShape(Sandbox.PhysicsGroupDescription.BodyPart.MeshPart,Transform,System.Boolean,System.Boolean)">
            <summary>
            Add a shape from a mesh hull
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBody.prevStepTransform">
            <summary>
            Transform, on previous step
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBody.stepTransform">
            <summary>
            Transform on current step
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.OnActive(Transform@,Vector3@,Vector3@)">
            <summary>
            Called on each active body after a "step"
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.GetLerpedTransform(System.Single)">
            <summary>
            When the physics world is run at a fixed timestep, getting the positions of bodies will not be smooth.
            You can use this function to get the lerped position between steps, to make things super awesome.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.SmoothMove(Vector3@,System.Single,System.Single)">
            <summary>
            Move body to this position in a way that cooperates with the physics system. This is quite
            good for things like grabbing and moving objects.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.SmoothMove(Transform@,System.Single,System.Single)">
            <summary>
            Move body to this position in a way that cooperates with the physics system. This is quite
            good for things like grabbing and moving objects.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.SmoothRotate(Rotation@,System.Single,System.Single)">
            <summary>
            Rotate the body to this position in a way that cooperates with the physics system.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBody.OnDirty">
            <summary>
            Called when anything significant changed about this physics object. Like its position,
            or its enabled status.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsGroup">
            <summary>
            Represents a set of <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> objects. Think ragdoll.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.World">
            <summary>
            The world in which this group belongs
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Pos">
            <summary>
            Returns position of the first physics body of this group, or zero vector if it has none.
            </summary>
            <remarks>
            TODO: How useful is this in its current form? Should it be removed, or at least renamed to Position?
            </remarks>
        </member>
        <member name="P:Sandbox.PhysicsGroup.MassCenter">
            <summary>
            Returns the center of mass for this group of physics bodies.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.AddVelocity(Vector3)">
            <summary>
            Adds given amount of velocity (<see cref="M:Sandbox.PhysicsBody.ApplyForce(Vector3)"/>) to all physics bodies in this group.
            </summary>
            <param name="vel">How much linear force to add?</param>
        </member>
        <member name="M:Sandbox.PhysicsGroup.AddAngularVelocity(Vector3)">
            <summary>
            Adds given amount of angular velocity to all physics bodies in this group.
            </summary>
            <param name="vel">How much angular force to add?</param>
        </member>
        <member name="M:Sandbox.PhysicsGroup.ApplyImpulse(Vector3,System.Boolean)">
            <summary>
            Adds given amount of linear impulse (<see cref="M:Sandbox.PhysicsBody.ApplyImpulse(Vector3)"/>) to all physics bodies in this group.
            </summary>
            <param name="vel">Velocity to apply.</param>
            <param name="withMass">Whether to multiply the velocity by mass of the <see cref="T:Sandbox.PhysicsBody"/> on a per-body basis.</param>
        </member>
        <member name="M:Sandbox.PhysicsGroup.ApplyAngularImpulse(Vector3,System.Boolean)">
            <summary>
            Adds given amount of angular linear impulse (<see cref="M:Sandbox.PhysicsBody.ApplyAngularImpulse(Vector3)"/>) to all physics bodies in this group.
            </summary>
            <param name="vel">Angular velocity to apply.</param>
            <param name="withMass">Whether to multiply the velocity by mass of the <see cref="T:Sandbox.PhysicsBody"/> on a per-body basis.</param>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Velocity">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.Velocity"/> on all bodies of this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.AngularVelocity">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.AngularVelocity"/> on all bodies of this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Sleeping">
            <summary>
            Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            You can use this to wake the body up, or prematurely send it to sleep.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.RebuildMass">
            <summary>
            Calls <see cref="M:Sandbox.PhysicsBody.RebuildMass"/> on all bodies of this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Mass">
            <summary>
            The total mass of all the <b>dynamic</b> <see cref="T:Sandbox.PhysicsBody">PhysicsBodies</see> in this group.
            When setting the total mass, it will be set on each body proportionally to each of their old masses,
            i.e. if a body had 25% of previous total mass, it will have 25% of new total mass.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.LinearDamping">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.LinearDamping"/> on all bodies in this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.AngularDamping">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.AngularDamping"/> on all bodies in this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Bodies">
            <summary>
            Returns all physics bodies that belong to this physics group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.BodyCount">
            <summary>
            Returns amount of physics bodies that belong to this physics group.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.GetBody(System.Int32)">
            <summary>
            Gets a <see cref="T:Sandbox.PhysicsBody"/> at given index within this physics group. See <see cref="P:Sandbox.PhysicsGroup.BodyCount"/>.
            </summary>
            <param name="groupIndex">Index for the body to look up, in range from 0 to <see cref="P:Sandbox.PhysicsGroup.BodyCount"/>.</param>
        </member>
        <member name="M:Sandbox.PhysicsGroup.GetBody(System.String)">
            <summary>
            Returns a <see cref="T:Sandbox.PhysicsBody"/> by its <see cref="P:Sandbox.PhysicsBody.GroupName"/> within this group.
            </summary>
            <param name="groupName">Name of the physics body to look up.</param>
            <returns>The physics body, or null if body with given name is not found.</returns>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Joints">
            <summary>
            Any and all joints that are attached to any body in this group.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.SetSurface(System.String)">
            <summary>
            Sets the physical properties of each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of this group.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.Remove">
            <summary>
            Delete this group, and all of its bodies
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsShape">
            <summary>
            Represents a basic, convex shape. A <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> consists of one or more of these.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Body">
            <summary>
            The physics body we belong to.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.BoneIndex">
            <summary>
            The bone index that this physics shape represents
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Collider">
            <summary>
            The collider object that created / owns this shape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsTrigger">
            <summary>
            This is a trigger (!)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.SurfaceVelocity">
            <summary>
            Set the local velocity of the surface so things can slide along it, like a conveyor belt
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.EnableAllCollision">
            <summary>
            Enable contact, trace and touch
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.DisableAllCollision">
            <summary>
            Disable contact, trace and touch
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.EnableSolidCollisions">
            <summary>
            Controls whether this shape has solid collisions.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.EnableTouch">
            <summary>
            Controls whether this shape can fire touch events for its owning entity. (Entity.StartTouch, Touch and EndTouch)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.EnableTouchPersists">
            <summary>
            Controls whether this shape can fire continuous touch events for its owning entity (i.e. calling Entity.Touch every frame)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsMeshShape">
            <summary>
            Is this a MeshShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsHullShape">
            <summary>
            Is this a HullShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsSphereShape">
            <summary>
            Is this a SphereShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsCapsuleShape">
            <summary>
            Is this a CapsuleShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsHeightfieldShape">
            <summary>
            Is this a HeightfieldShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Sphere">
            <summary>
            Get sphere properties if we're a sphere type
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Capsule">
            <summary>
            Get capsule properties if we're a capsule type
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateCapsuleShape(Vector3,Vector3,System.Single)">
            <summary>
            Recreate the collision mesh (Only if this physics shape is type Capsule)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateBoxShape(Vector3,Rotation,Vector3)">
            <summary>
            Recreate the collision mesh (Only if this physics shape is type Hull)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
            <summary>
            Recreate the collision mesh (Only if this physics shape is type Mesh)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Span{Vector3},System.Span{System.Int32})">
            <summary>
            Recreate the mesh of the shape (Only if this physics shape is type Mesh)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateHull(Vector3,Rotation,System.Span{Vector3})">
            <summary>
            Recreate the hull of the shape (Only if this physics shape is type Hull)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.SurfaceMaterial">
            <summary>
            Controls physical properties of this shape.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Surfaces">
            <summary>
            Multiple surfaces referenced by mesh or heightfield collision.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.Remove">
            <summary>
            Remove this shape. After calling this the shape should be considered released and not used again.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.Triangulate(Vector3[]@,System.UInt32[]@)">
            <summary>
            Triangulate this shape.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Friction">
            <summary>
            The friction value
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsShape.OnDirty">
            <summary>
            Called when anything significant changed about this physics object. Like its position,
            or its enabled status.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.HasTag(System.String)">
            <summary>
            Does this shape have a specific tag?
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.AddTag(System.String)">
            <summary>
            Add a tag to this shape.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.RemoveTag(System.String)">
            <summary>
            Remove a tag from this shape.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.ClearTags">
            <summary>
            Clear all tags from this shape.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceBuilder.filterCallback">
            <summary>
            Do not expose! We want to force this whole thing into as tight of a box as possible!
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Sphere(System.Single,Vector3@,Vector3@)">
            <summary>
            Casts a sphere from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Sphere(System.Single,Ray@,System.Single@)">
            <summary>
            Casts a sphere from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Box(Vector3,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Box(Vector3,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Box(BBox,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Box(BBox,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Capsule(Capsule)">
            <summary>
            Casts a capsule
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Capsule(Capsule,Vector3@,Vector3@)">
            <summary>
            Casts a capsule from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Capsule(Capsule,Ray@,System.Single@)">
            <summary>
            Casts a capsule from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Cylinder(System.Single,System.Single)">
            <summary>
            Casts a cylinder
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Cylinder(System.Single,System.Single,Vector3@,Vector3@)">
            <summary>
            Casts a cylinder from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Cylinder(System.Single,System.Single,Ray@,System.Single@)">
            <summary>
            Casts a cylinder from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Ray(Vector3@,Vector3@)">
            <summary>
            Casts a ray from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Ray(Ray@,System.Single@)">
            <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Body(Sandbox.PhysicsBody,Vector3@)">
            <summary>
            Casts a PhysicsBody from its current position and rotation to desired end point.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Body(Sandbox.PhysicsBody,Transform@,Vector3@)">
            <summary>
            Casts a PhysicsBody from a position and rotation to desired end point.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Sweep(Sandbox.PhysicsBody@,Transform@,Transform@)">
            <summary>
            Sweeps each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of given PhysicsBody and returns the closest collision. Does not support Mesh PhysicsShapes.
            Basically 'hull traces' but with physics shapes.
            Same as tracing a body but allows rotation to change during the sweep.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Sweep(Sandbox.PhysicsBody@,Transform@)">
            <summary>
            Creates a Trace.Sweep using the <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see>'s position as the starting position.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.FromTo(Vector3@,Vector3@)">
            <summary>
            Sets the start and end positions of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.FromTo(Transform@,Vector3@)">
            <summary>
            Sets the start transform and end position of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Rotated(Rotation@)">
            <summary>
            Sets the start rotation of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.HitTriggers">
            <summary>
            Include triggers in the trace
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.HitTriggersOnly">
            <summary>
            Only hit triggers
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.IgnoreStatic">
            <summary>
            Ignore static objects in the trace
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.IgnoreDynamic">
            <summary>
            Ignore dynamic objects in the trace
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.IgnoreKeyframed">
            <summary>
            Ignore keyframed objects in the trace
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.UseHitPosition(System.Boolean)">
            <summary>
            Compute hit position.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Size(BBox@)">
            <summary>
            Makes this trace an axis aligned box of given size. Extracts mins and maxs from the Bounding Box.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Size(Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size. Calculates mins and maxs by assuming given size is (maxs-mins) and the center is in the middle.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Size(Vector3@,Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Radius(System.Single)">
            <summary>
            Makes this trace a sphere of given radius.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Run">
            <summary>
            Run the trace and return the result. The result will return the first hit.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.RunAll">
            <summary>
            Run the trace and return all hits as a result.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.RunAgainstCapsule(Capsule@,Transform@)">
            <summary>
            Traces only against the given capsule at the specified transform.
            </summary>
            <param name="capsule">The capsule to test against.</param>
            <param name="transform">Transform applied to the capsule.</param>
            <returns>The trace result.</returns>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.RunAgainstSphere(Sandbox.Sphere@,Transform@)">
            <summary>
            Traces only against the given sphere at the specified transform.
            </summary>
            <param name="sphere">The sphere to test against.</param>
            <param name="transform">Transform applied to the sphere.</param>
            <returns>The trace result.</returns>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.RunAgainstBBox(BBox@,Transform@)">
            <summary>
            Traces only against the given bounding box at the specified transform.
            </summary>
            <param name="box">The bounding box to test against.</param>
            <param name="transform">Transform applied to the box.</param>
            <returns>The trace result.</returns>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithTag(Sandbox.StringToken)">
            <summary>
            Only return entities with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the entity will need all tags).
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithAllTags(System.String[])">
            <summary>
            Only return with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithAllTags(Sandbox.ITagSet)">
            <summary>
            Only return with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithAnyTags(System.String[])">
            <summary>
            Only return entities with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithAnyTags(System.Collections.Generic.IReadOnlySet{System.UInt32})">
            <summary>
            Only return entities with any of these tags (using ints)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithAnyTags(Sandbox.ITagSet)">
            <summary>
            Only return with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithoutTag(System.String)">
            <summary>
            Only return with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithoutTags(System.String[])">
            <summary>
            Only return without any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithoutTags(Sandbox.ITagSet)">
            <summary>
            Only return without any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithCollisionRules(System.String,System.Boolean)">
            <summary>
            Use the collision rules of the given tag.
            </summary>
            <param name="tag">Which tag this trace will adopt the collision rules of.</param>
            <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithCollisionRules(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Use the collision rules for the given set of tags.
            </summary>
            <param name="tags">Which tags this trace will adopt the collision rules of.</param>
            <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Hit">
            <summary>
            Whether the trace hit something or not
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.StartedSolid">
            <summary>
            Whether the trace started in a solid
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.StartPosition">
            <summary>
            The start position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.EndPosition">
            <summary>
            The end or hit position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.HitPosition">
            <summary>
            The hit position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Normal">
            <summary>
            The hit surface normal (direction vector)
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Fraction">
            <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Body">
            <summary>
            The physics object that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Shape">
            <summary>
            The physics shape that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Surface">
            <summary>
            The physical properties of the hit surface
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsTraceResult.Bone">
            <summary>
            The id of the hit bone (either from hitbox or physics shape)
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Direction">
            <summary>
            The direction of the trace ray
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Triangle">
            <summary>
            The triangle index hit, if we hit a mesh <see cref="T:Sandbox.PhysicsShape">physics shape</see>
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Tags">
            <summary>
            The tags that the hit shape had
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsTraceResult.Distance">
            <summary>
            The distance between start and end positions.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsSimulationMode">
            <summary>
            Physics simulation mode. For use with <see cref="P:Sandbox.PhysicsWorld.SimulationMode"/>.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsSimulationMode.Discrete">
            <summary>
            Discrete collision detection.
            In this mode physics bodies can fly through thin walls when moving very quickly, but it is has better performance.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsSimulationMode.Continuous">
            <summary>
            Continuous collision detection. This is the default mode.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsWorld">
            <summary>
            A world in which physics objects exist. You can create your own world but you really don't need to. A world for the map is created clientside and serverside automatically.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Bodies">
            <summary>
            All bodies in the world
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.CollisionRules">
            <summary>
            Set or retrieve the collision rules for this <see cref="T:Sandbox.PhysicsWorld"/>.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.#ctor">
            <summary>
            Create a new physics world. You should only do this if you want to simulate an extra world for some reason.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.SetupPhysicsFromModel(Sandbox.Model,Sandbox.PhysicsMotionType)">
            <summary>
            Temp function for creating model physics until entity system handles it
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.SetupPhysicsFromModel(Sandbox.Model,Transform,Sandbox.PhysicsMotionType)">
            <summary>
            Temp function for creating model physics until entity system handles it
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.Delete">
            <summary>
            Delete this world and all objects inside. Will throw an exception if you try to delete a world that you didn't manually create.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.Step(System.Single)">
            <summary>
            Step simulation of this physics world. You can only do this on physics worlds that you manually create.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.Step(System.Single,System.Int32)">
            <summary>
            Step simulation of this physics world. You can only do this on physics worlds that you manually create.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.Step(System.Single,System.Single,System.Int32)">
            <summary>
            Step simulation of this physics world. You can only do this on physics worlds that you manually create.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Gravity">
            <summary>
            Access the world's current gravity.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.AirDensity">
            <summary>
            Air density of this physics world, for things like air drag.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Body">
            <summary>
            The body of this physics world.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Group">
            <summary>
            The physics group of this physics world. A physics world will contain only 1 body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.SleepingEnabled">
            <summary>
            If true then bodies will be able to sleep after a period of inactivity
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.SimulationMode">
            <summary>
            Physics simulation mode. See <see cref="T:Sandbox.PhysicsSimulationMode"/> for explanation of each mode.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.SubSteps">
            <summary>
            If you're seeing objects go through other objects or you have a low tickrate, you might want to increase the number of physics substeps.
            This breaks physics steps down into this many substeps. The default is 1 and works pretty good.
            Be aware that the number of physics ticks per second is going to be tickrate * substeps.
            So if you're ticking at 90 and you have SubSteps set to 1000 then you're going to do 90,000 steps per second. So be careful here.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.SetCollisionRules(Sandbox.Physics.CollisionRules)">
            <summary>
            Used internally to set collision rules from gamemode's project settings.
            You shouldn't need to call this yourself.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.GetCollisionRule(System.String,System.String)">
            <summary>
            Gets the specific collision rule for a pair of tags.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Trace">
            <summary>
            Raytrace against this world
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.RunTrace(Sandbox.PhysicsTraceBuilder@)">
            <summary>
            Like calling PhysicsTraceBuilder.Run, except will re-target this world if it's not already the target
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.RunTraceAll(Sandbox.PhysicsTraceBuilder@)">
            <summary>
            Like calling PhysicsTraceBuilder.RunAll, except will re-target this world if it's not already the target
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.DebugSceneWorld">
            <summary>
            A SceneWorld where debug SceneObjects exist.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.DebugDraw">
            <summary>
            Updates all the SceneObjects in the <see cref="P:Sandbox.PhysicsWorld.DebugSceneWorld"/>, call once per tick or frame.
            </summary>
        </member>
        <member name="T:Sandbox.ConfigData">
            <summary>
            Project configuration data is derived from this class
            </summary>
        </member>
        <member name="M:Sandbox.ConfigData.OnValidate">
            <summary>
            Called after deserialization, and before serialization. A place to error check and make sure everything is fine.
            </summary>
        </member>
        <member name="T:Sandbox.InputSettings">
            <summary>
            A class that holds all configured input settings for a game.
            This is serialized as a config and shared from the server to the client.
            </summary>
        </member>
        <member name="P:Sandbox.InputSettings.Actions">
            <summary>
            A list of actions used by the game.
            </summary>
        </member>
        <member name="T:Sandbox.NetworkingSettings">
            <summary>
            A class that holds all configured networking settings for a game.
            This is serialized as a config and shared from the server to the client.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkingSettings.DestroyLobbyWhenHostLeaves">
            <summary>
            Whether to disband the game lobby when the host leaves.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkingSettings.AutoSwitchToBestHost">
            <summary>
            Whether to periodically switch to the best host candidate. Candidates are
            scored based on their average ping and connection quality to all other peers.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkingSettings.ClientsCanSpawnObjects">
            <summary>
            By default can clients create objects. This can be changed per connection after join.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkingSettings.ClientsCanRefreshObjects">
            <summary>
            By default can clients refresh objects. This can be changed per connection after join.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkingSettings.UpdateRate">
            <summary>
            The frequency at which the network system will send updates to clients. Higher is better but
            you probably want to stay in the 10-60 range.
            </summary>
        </member>
        <member name="P:Sandbox.ProjectSettings.Collision">
            <summary>
            Get the <see cref="T:Sandbox.Physics.CollisionRules"/> from the active project settings.
            </summary>
        </member>
        <member name="P:Sandbox.ProjectSettings.Input">
            <summary>
            Get the <see cref="P:Sandbox.ProjectSettings.Input"/> from the active project settings.
            </summary>
        </member>
        <member name="P:Sandbox.ProjectSettings.Networking">
            <summary>
            Get the <see cref="T:Sandbox.NetworkingSettings"/> from the active project settings.
            </summary>
        </member>
        <member name="P:Sandbox.ProjectSettings.Mixer">
            <summary>
            Get the <see cref="T:Sandbox.Audio.MixerSettings"/> from the active project settings.
            </summary>
        </member>
        <member name="P:Sandbox.ProjectSettings.Cursor">
            <summary>
            Get the <see cref="T:Sandbox.CursorSettings"/> from the active project settings.
            </summary>
        </member>
        <member name="P:Sandbox.ProjectSettings.Physics">
            <summary>
            Get the <see cref="P:Sandbox.ProjectSettings.Physics"/> from the active project settings.
            </summary>
        </member>
        <member name="M:Sandbox.ProjectSettings.ClearCache">
            <summary>
            Reset any stored references to Project Settings.
            </summary>
        </member>
        <member name="M:Sandbox.ProjectSettings.Get``1(System.String)">
            <summary>
            Gets or creates a default version of this config data. You can safely call this multiple times
            and it will return the same object. The cache is cleared automatically when the project changes, 
            or when it's hotloaded.
            </summary>
        </member>
        <member name="T:Sandbox.Project">
            <summary>
            Represents an on-disk project.
            </summary>
            <summary>
            Represents an on-disk project.
            </summary>
        </member>
        <member name="P:Sandbox.Project.HasCompiler">
            <summary>
            Whether the project's code has a compiler assigned.
            </summary>
        </member>
        <member name="P:Sandbox.Project.BaseReferencingTypes">
            <summary>
            These package types should reference package.base
            </summary>
        </member>
        <member name="M:Sandbox.Project.UpdateEditorCompiler">
            <summary>
            If required, create the editor compiler
            </summary>
        </member>
        <member name="M:Sandbox.Project.FindByCompiler(Sandbox.Compiler)">
            <summary>
            Find a project from a compiler
            </summary>
        </member>
        <member name="M:Sandbox.Project.LoadPrecompiled">
            <summary>
            Loads precompiled assemblies that might exist (menu) as long as we're not in editor or headless or anything
            </summary>
        </member>
        <member name="P:Sandbox.Project.ProjectSourceObject">
            <summary>
            If this is a single asset project, this will be the asset object
            </summary>
        </member>
        <member name="P:Sandbox.Project.ConfigFilePath">
            <summary>
            Absolute path to the .addon file
            </summary>
        </member>
        <member name="P:Sandbox.Project.RootDirectory">
            <summary>
            Root directory of this project
            </summary>
        </member>
        <member name="P:Sandbox.Project.Active">
            <summary>
            True if this project is active
            </summary>
        </member>
        <member name="P:Sandbox.Project.Pinned">
            <summary>
            True if this project is pinned, we'll prioritise it when sorting
            </summary>
        </member>
        <member name="P:Sandbox.Project.LastOpened">
            <summary>
            When did the user last open this project?
            </summary>
        </member>
        <member name="P:Sandbox.Project.Broken">
            <summary>
            True if this project failed to load properly for some reason
            </summary>
        </member>
        <member name="P:Sandbox.Project.IsPublished">
            <summary>
            Returns true if this project has previously been published. This is kind of a guess though
            because all it does is look to see if we have a published package cached with the same ident.
            </summary>
        </member>
        <member name="P:Sandbox.Project.EditUrl">
            <summary>
            The URL to the package's page for editing
            </summary>
        </member>
        <member name="P:Sandbox.Project.ViewUrl">
            <summary>
            The URL to the package's page for viewing/linking
            </summary>
        </member>
        <member name="P:Sandbox.Project.Config">
            <summary>
            Configuration of the project.
            </summary>
        </member>
        <member name="P:Sandbox.Project.IsTransient">
            <summary>
            If true this project isn't a 'real' project. It's likely a temporary project created with the
            intention to configure and publish a single asset.
            </summary>
        </member>
        <member name="P:Sandbox.Project.IsBuiltIn">
            <summary>
            If true this project isn't a 'real' project. It's likely a temporary project created with the
            intention to configure and publish a single asset.
            </summary>
        </member>
        <member name="P:Sandbox.Project.OnSaveProject">
            <summary>
            Called when the project is about to save
            </summary>
        </member>
        <member name="P:Sandbox.Project.AssemblyFileSystem">
            <summary>
            A filesystem into which compiled assemblies are written
            </summary>
        </member>
        <member name="M:Sandbox.Project.GetRootPath">
            <summary>
            Absolute path to the location of the <c>.sbproj</c> file of the project.
            </summary>
        </member>
        <member name="M:Sandbox.Project.GetCodePath">
            <summary>
            Absolute path to the Code folder of the project.
            </summary>
        </member>
        <member name="M:Sandbox.Project.HasCodePath">
            <summary>
            Returns true if the Code path exists
            </summary>
        </member>
        <member name="M:Sandbox.Project.GetEditorPath">
            <summary>
            Absolute path to the Editor folder of the project.
            </summary>
        </member>
        <member name="M:Sandbox.Project.HasEditorPath">
            <summary>
            Returns true if the Editor path exists
            </summary>
        </member>
        <member name="M:Sandbox.Project.GetAssetsPath">
            <summary>
            Absolute path to the Assets folder of the project, or <see langword="null"/> if not set.
            </summary>
        </member>
        <member name="M:Sandbox.Project.GetLocalizationPath">
            <summary>
            Absolute path to the Localization folder of the project, or <see langword="null"/> if not set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Project.HasAssetsPath">
            <summary>
            Returns true if the Assets path exists
            </summary>
        </member>
        <member name="P:Sandbox.Project.Package">
            <summary>
            The package for this project. This is a mock up of the actual package.
            </summary>
        </member>
        <member name="M:Sandbox.Project.IsSourcePublish">
            <summary>
            Return true if this project type uploads all the source files when it's published
            </summary>
        </member>
        <member name="P:Sandbox.Project.Current">
            <summary>
            Current open project.
            </summary>
        </member>
        <member name="M:Sandbox.Project.Clear">
            <summary>
            Remove all local packages. Used by unit tests to reset state.
            </summary>
        </member>
        <member name="M:Sandbox.Project.Tick">
            <summary>
            Check whether the group needs recompiling, and recompiles
            </summary>
        </member>
        <member name="M:Sandbox.Project.InitializeBuiltIn(System.Boolean)">
            <summary>
            Initializes all the base projects
            </summary>
        </member>
        <member name="M:Sandbox.Project.SyncWithPackageManager">
            <summary>
            Takes all of the active projects and makes sure we're in sync
            with the package manager. Creates mock packages that act like real ones.
            Removes packages that are no longer active. If nothing changed then this should
            do nothing.
            </summary>
        </member>
        <member name="M:Sandbox.Project.GenerateSolution">
            <summary>
            (Re)generate the active project's solution file.
            </summary>
        </member>
        <member name="M:Sandbox.Project.AddFromFileBuiltIn(System.String)">
            <summary>
            Like AddFromFile but the project is marked as "built in" - which means
            it's always automatically loaded and can't be unloaded.
            </summary>
        </member>
        <member name="M:Sandbox.Project.ResolveCompiler(System.Reflection.Assembly)">
            <summary>
            Resolve an assemblt to a compiler using the assembly name
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Duration">
            <summary>
            The duration of the currently playing sequence (seconds)
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.IsFinished">
            <summary>
            Get whether the current animation sequence has finished
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Name">
            <summary>
            The name of the currently playing animation sequence
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.TimeNormalized">
            <summary>
            The normalized (between 0 and 1) elapsed time of the currently playing
            animation sequence
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Time">
            <summary>
            The elapsed time of the currently playing animation sequence (seconds)
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Looping">
            <summary>
            Get or set whether the current animation sequence is looping
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Blending">
            <summary>
            Get or set whether animations blend smoothly when transitioning between sequences.
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.SequenceNames">
            <summary>
            The list of sequences that can be used
            </summary>
        </member>
        <member name="T:Sandbox.AnimGraphDirectPlayback">
            <summary>
            For communicating with a Direct Playback Anim Node, which allows code to tell it to play a given sequence
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.StartTime">
            <summary>
            Set the time at which the currently playing sequence should have had a cycle of zero.
            This will adjust the current cycle of the sequence to match.
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.TimeNormalized">
            <summary>
            Get the cycle of the currently playing sequence.  Will return 0 if no sequence is playing.
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.Duration">
            <summary>
            The duration of the currently playing sequence (seconds)
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.Time">
            <summary>
            The elapsed time of the currently playing animation sequence (seconds)
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.Name">
            <summary>
            Returns the currently playing sequence.
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.AnimationCount">
            <summary>
            Get the number of animations that can be used.
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.Animations">
            <summary>
            Get the list of animations that can be used.
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.Sequences">
            <summary>
            Get the list of sequences that can be used.
            </summary>
        </member>
        <member name="M:Sandbox.AnimGraphDirectPlayback.Play(System.String)">
            <summary>
            Play the given sequence until it ends, then blend back.
            Calling this function with a new sequence while another one is playing will immediately start blending from the old one to the new one.  
            </summary>
        </member>
        <member name="M:Sandbox.AnimGraphDirectPlayback.Play(System.String,Vector3,System.Single,System.Single)">
            <summary>
            Same as the other Play function, but also sets a target position and heading for the sequence.
            Over interpTime seconds, the entity's root motion will be augmented to move it to target and rotate it to heading. 
            </summary>
        </member>
        <member name="M:Sandbox.AnimGraphDirectPlayback.Cancel">
            <summary>
            Stop playing the override sequence.
            </summary>
        </member>
        <member name="T:Sandbox.AsyncGPUReadback">
            <summary>
            Provides methods for reading GPU data asynchronously without blocking the render thread.
            </summary>
            <remarks>
            Handles the management of callbacks and memory for reading textures and buffers from GPU memory.
            Data retrieved through these methods is only valid during the callback execution.
            </remarks>
        </member>
        <member name="M:Sandbox.AsyncGPUReadback.ReadTextureAsync(NativeEngine.IRenderContext,Sandbox.Texture,Sandbox.AsyncGPUReadback.TextureReadDelegate,System.Int32,System.Int32,System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32})">
            <summary>
            Reads texture data from GPU memory, data is kept valid until after the callback task is finished.
            If srcRect is not specified, the entire texture will be read.
            </summary>
        </member>
        <member name="M:Sandbox.AsyncGPUReadback.DispatchManagedReadTextureCallback(NativeEngine.CReadTexturePixelsManagedCallback,System.IntPtr,Sandbox.ImageFormat,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Called by native to dispatch the managed callback for texture read operations.
            </summary>
        </member>
        <member name="M:Sandbox.AsyncGPUReadback.DispatchManagedReadBufferCallback(NativeEngine.CReadBufferManagedCallback,System.IntPtr,System.Int32)">
            <summary>
            Called by native to dispatch the managed callback for buffer read operations.
            </summary>
        </member>
        <member name="T:Sandbox.BlendMode">
            <summary>
            Blend modes used by the UI system
            </summary>
        </member>
        <member name="T:Sandbox.CameraRenderer">
            <summary>
            Camera setup for rendering a View.
            </summary>
        </member>
        <member name="F:Sandbox.ComputeBufferType.Structured">
            <summary>
            Structured Buffer (HLSL RWStructuredBuffer)
            </summary>
        </member>
        <member name="F:Sandbox.ComputeBufferType.ByteAddress">
            <summary>
            Byte Address Buffer (HLSL RWByteAddressBuffer)
            </summary>
        </member>
        <member name="F:Sandbox.ComputeBufferType.Append">
            <summary>
            Append Structured Buffer (HLSL AppendStructuredBuffer)
            </summary>
        </member>
        <member name="F:Sandbox.ComputeBufferType.IndirectDrawArguments">
            <summary>
            Indirect argument buffer for indirect draws
            <seealso cref="T:Sandbox.GpuBuffer.IndirectDrawArguments"/>
            </summary>
        </member>
        <member name="T:Sandbox.ComputeShader">
            <summary>
            A compute shader is a program that runs on the GPU, often with data provided to/from the CPU by means of a <see cref="T:Sandbox.GpuBuffer`1"/> or a <see cref="T:Sandbox.Texture"/>.
            </summary>
            <seealso cref="T:Sandbox.GpuBuffer`1"/>
        </member>
        <member name="P:Sandbox.ComputeShader.Attributes">
            <summary>
            Attributes that are passed to the compute shader on dispatch.
            </summary>
        </member>
        <member name="M:Sandbox.ComputeShader.#ctor(System.String)">
            <summary>
            Create a compute shader from the specified path.
            </summary>
        </member>
        <member name="M:Sandbox.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32)">
            <summary>
            Dispatch this compute shader using explicit thread counts.
            </summary>
            <remarks>
            The specified thread counts will be automatically divided by the thread group size
            defined in the shader to compute the final dispatch group count.
            <para>
            When called outside a graphics context, the dispatch runs immediately.  
            When called inside a graphics context, the dispatch runs async.
            </para>
            </remarks>
            <param name="threadsX">The number of threads to dispatch in the X dimension.</param>
            <param name="threadsY">The number of threads to dispatch in the Y dimension.</param>
            <param name="threadsZ">The number of threads to dispatch in the Z dimension.</param>
        </member>
        <member name="M:Sandbox.ComputeShader.DispatchIndirect(Sandbox.GpuBuffer,System.UInt32)">
            <summary>
            Dispatch this compute shader by reading thread group counts (x, y, z)
            from an indirect buffer of type <see cref="T:Sandbox.GpuBuffer.IndirectDispatchArguments"/>.
            </summary>
            <remarks>
            <para>
            <paramref name="indirectBuffer"/> must be created with <see cref="F:Sandbox.GpuBuffer.UsageFlags.IndirectDrawArguments"/>  
            and have an element size of 12 bytes.
            </para>
            <para>
            <paramref name="indirectElementOffset"/> is an element index into <paramref name="indirectBuffer"/>, not a byte offset.
            </para>
            <para>
            When called outside a graphics context, the dispatch runs immediately.  
            When called inside a graphics context, the dispatch runs async.
            </para>
            </remarks>
            <param name="indirectBuffer">The GPU buffer containing one or more dispatch argument entries.</param>
            <param name="indirectElementOffset">The index of the dispatch arguments element to use (each element = 12 bytes).</param>
        </member>
        <member name="M:Sandbox.ComputeShader.DispatchWithAttributes(Sandbox.RenderAttributes,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:Sandbox.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sandbox.ComputeShader.DispatchIndirectWithAttributes(Sandbox.RenderAttributes,Sandbox.GpuBuffer,System.UInt32)">
            <inheritdoc cref="M:Sandbox.ComputeShader.DispatchIndirect(Sandbox.GpuBuffer,System.UInt32)"/>
        </member>
        <member name="T:Sandbox.CubemapRendering">
            <summary>
            Provides functionality for rendering and filtering cubemap textures.
            Used for environment mapping and image-based lighting in PBR rendering.
            </summary>
        </member>
        <member name="T:Sandbox.CubemapRendering.GGXFilterType">
            <summary>
            Specifies the quality level for GGX filtering of environment maps.
            </summary>
        </member>
        <member name="F:Sandbox.CubemapRendering.GGXFilterType.Fast">
            <summary>
            Faster filtering with lower sample count.
            </summary>
        </member>
        <member name="F:Sandbox.CubemapRendering.GGXFilterType.Quality">
            <summary>
            Higher quality filtering with more samples.
            </summary>
        </member>
        <member name="M:Sandbox.CubemapRendering.Render(Sandbox.SceneWorld,Sandbox.Texture,Transform,System.Single,System.Single,Sandbox.CubemapRendering.GGXFilterType)">
            <summary>
            Renders a cubemap from a scene at the specified transform position and applies filtering.
            </summary>
            <param name="world">The scene world to render.</param>
            <param name="cubemapTexture">The texture to render the cubemap to.</param>
            <param name="cubemapTransform">The position and rotation of the cubemap camera.</param>
            <param name="znear">The near plane distance for the camera.</param>
            <param name="zfar">The far plane distance for the camera.</param>
            <param name="filterType">The quality level for GGX filtering.</param>
        </member>
        <member name="M:Sandbox.CubemapRendering.Filter(Sandbox.Texture,Sandbox.CubemapRendering.GGXFilterType)">
            <summary>
            Applies filtering to a cubemap texture, generating both downsample and GGX filtering.
            </summary>
            <param name="cubemapTexture">The cubemap texture to filter.</param>
            <param name="filterType">The quality level for GGX filtering.</param>
            <exception cref="T:System.Exception">Thrown when the cubemap texture doesn't meet requirements.</exception>
        </member>
        <member name="M:Sandbox.CubemapRendering.FilterDownsample(Sandbox.Texture)">
            <summary>
            Downsamples a cubemap texture to generate its mip chain.
            </summary>
            <param name="cubemapTexture">The cubemap texture to downsample.</param>
        </member>
        <member name="M:Sandbox.CubemapRendering.FilterGGX(Sandbox.Texture,Sandbox.CubemapRendering.GGXFilterType)">
            <summary>
            Applies GGX filtering to a cubemap texture for image-based lighting.
            This generates the pre-filtered environment map used in PBR workflows.
            </summary>
            <param name="cubemapTexture">The cubemap texture to filter.</param>
            <param name="filterType">The quality level for GGX filtering.</param>
        </member>
        <member name="M:Sandbox.CubemapRendering.SumOfSquaresTwo(System.Int32)">
            <summary>
            Calculates the sum of squares of powers of two up to n.
            Formula: 1 + 2 + 4 + 8 + ... + (2^k) where 2^k  n
            Used for determining compute shader dispatch dimensions.
            </summary>
            <param name="n">The upper limit for powers of two.</param>
            <returns>The sum of squares of powers of two up to n.</returns>
        </member>
        <member name="T:Sandbox.GpuBuffer">
             <summary>
             A GPU data buffer intended for use with a <see cref="T:Sandbox.ComputeShader"/>.
             
             You can read and write arbitrary data to and from the CPU and GPU.
             This allows for efficient parallel data processing on the GPU.
             
             Different GPU buffer types can be used depending on the provided <see cref="T:Sandbox.GpuBuffer.UsageFlags"/>.
             Using the default <see cref="F:Sandbox.GpuBuffer.UsageFlags.Structured"/> type buffers map to StructuredBuffer&lt;T&gt; and RWStructuredBuffer&lt;T&gt; in HLSL.
             </summary>
            
             <example>
             This example shows how to use the GpuBuffer class to send data to a compute shader:
             <code>
             struct MyData
             {
                 public float Value;
             }
             
             // Allocate the GPU buffer
             using (var buffer = new GpuBuffer&lt;MyData&gt;( 2 ))
             {
            		// Upload data to the GPU buffer
            		var data = new MyData[] { new MyData { Value = 1.0f }, new MyData { Value = 2.0f } };
            		buffer.SetData( data );
             
                 // Pass the buffer to a compute shader
                 ComputeShader.Attributes.Set( "myData", buffer );
                 
                 // Dispatch the shader
                 ComputeShader.Dispatch();
             }
             </code>
             </example>
             
             <example>
             This example shows how to retrieve data from a GPU using the GpuBuffer class:
             <code>
             struct MyData
             {
                 public float Value;
             }
             
             using (var buffer = new GpuBuffer&lt;MyData&gt;( 8 ))
             {
                 // Pass the buffer to a compute shader
                 ComputeShader.Attributes.Set( "myData", buffer );
                 
                 // Dispatch the shader
                 ComputeShader.Dispatch();
                 
            		// Retrieve the data from the GPU
            		var data = new MyData[ 8 ];
            		buffer.GetData( data, 0, 8 );
             }
             </code>
             </example>
            
             <seealso cref="T:Sandbox.ComputeShader"/>
             <seealso cref="M:Sandbox.RenderAttributes.Set(Sandbox.StringToken@,Sandbox.GpuBuffer@)"/>
        </member>
        <member name="P:Sandbox.GpuBuffer.ElementCount">
            <summary>
            Number of elements in the buffer.
            </summary>
        </member>
        <member name="P:Sandbox.GpuBuffer.ElementSize">
            <summary>
            Size of a single element in the buffer.
            </summary>
        </member>
        <member name="P:Sandbox.GpuBuffer.Usage">
            <summary>
            What sort of buffer this is
            </summary>
        </member>
        <member name="M:Sandbox.GpuBuffer.#ctor(System.Int32,System.Int32,Sandbox.GpuBuffer.UsageFlags,System.String)">
            <summary>
            Creates a new GPU buffer with a specified number of elements and a specific buffer type.
            </summary>
            <param name="elementCount">The total number of elements that the GpuBuffer can hold. This represents the buffer's size in terms of elements, not bytes.</param>
            <param name="elementSize">The total number of elements that the GpuBuffer can hold. This represents the buffer's size in terms of elements, not bytes.</param>
            <param name="flags">Defines the usage pattern of the GPU buffer. This can affect performance depending on how the buffer is utilized.</param>
            <param name="debugName">Test</param>
        </member>
        <member name="M:Sandbox.GpuBuffer.Dispose">
            <summary>
            Destroys the GPU buffer, don't use it no more
            </summary>
        </member>
        <member name="M:Sandbox.GpuBuffer.GetData``1(System.Span{``0})">
            <summary>
            Retrieves the GPU buffer and copies them into a provided Span.
            </summary>
            <remarks>
            This operation is synchronous and will block until the data has been fully downloaded from the GPU.
            </remarks>
            <param name="data">A Span of type T which the GPU buffer's contents will be copied into.</param>
        </member>
        <member name="M:Sandbox.GpuBuffer.GetData``1(System.Span{``0},System.Int32,System.Int32)">
            <summary>
            Retrieves a number of elements from the GPU buffer and copies them into a provided Span.
            </summary>
            <remarks>
            This operation is synchronous and will block until the specified range of data has been fully downloaded from the GPU.
            </remarks>
            <param name="data">A Span of type T which the GPU buffer's contents will be copied into.</param>
            <param name="start">The starting index from which to begin retrieving data. This index is in terms of elements, not bytes.</param>
            <param name="count">The number of elements to retrieve from the GPU buffer. This count is also in terms of elements, not bytes.</param>
        </member>
        <member name="M:Sandbox.GpuBuffer.GetDataAsync``1(System.Action{System.ReadOnlySpan{``0}})">
            <summary>
            Asynchronously retrieves data from the GPU buffer and provides it to the callback.
            </summary>
            <remarks>
            This operation is asynchronous and won't block the calling thread while data is downloaded from the GPU.
            The data span is only valid during the callback execution.
            </remarks>
            <typeparam name="T">The type of data to retrieve.</typeparam>
            <param name="callback">Callback that receives the data when the read operation completes.</param>
        </member>
        <member name="M:Sandbox.GpuBuffer.GetDataAsync``1(System.Action{System.ReadOnlySpan{``0}},System.Int32,System.Int32)">
            <summary>
            Asynchronously retrieves a number of elements from the GPU buffer and provides it to the callback.
            </summary>
            <remarks>
            This operation is asynchronous and won't block the calling thread while data is downloaded from the GPU.
            The data span is only valid during the callback execution.
            </remarks>
            <typeparam name="T">The type of data to retrieve.</typeparam>
            <param name="callback">Callback that receives the data when the read operation completes.</param>
            <param name="start">The starting index from which to begin retrieving data. This index is in terms of elements, not bytes.</param>
            <param name="count">The number of elements to retrieve from the GPU buffer. This count is also in terms of elements, not bytes.</param>
        </member>
        <member name="M:Sandbox.GpuBuffer.SetData``1(System.Span{``0},System.Int32)">
            <summary>
            Synchronously uploads data from a Span to the GPU, replacing the existing data in this GpuBuffer.
            </summary>
            <remarks>
            This operation is synchronous; it will block until the data has been fully uploaded to the GPU.
            </remarks>
            <param name="data">The Span of data to upload. It should contain items of type T, which is a struct.</param>
            <param name="elementOffset">The offset in terms of elements (not bytes) at which to start uploading data (default is 0).</param>
        </member>
        <member name="M:Sandbox.GpuBuffer.SetData``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Synchronously uploads data from a List to the GPU, replacing the existing data in this GpuBuffer.
            </summary>
            <remarks>
            This operation is synchronous; it will block until the data has been fully uploaded to the GPU.
            </remarks>
            <param name="data">The List of data to upload. It should contain items of type T, which is a struct.</param>
            <param name="elementOffset">The offset in terms of elements (not bytes) at which to start uploading data (default is 0).</param>
        </member>
        <member name="M:Sandbox.GpuBuffer.CopyStructureCount(Sandbox.GpuBuffer,System.Int32)">
            <summary>
            For <see cref="F:Sandbox.GpuBuffer.UsageFlags.Append"/> buffers there is a hidden uint 32-bit atomic counter in the buffer that contains the number of 
            writes to the buffer after invocation of the compute shader.  In order to get the value of the counter, the data needs to be copied to
            another GPU buffer that can be used.
            </summary>
        </member>
        <member name="M:Sandbox.GpuBuffer.SetCounterValue(System.UInt32)">
            <summary>
            Sets the counter value for <see cref="F:Sandbox.GpuBuffer.UsageFlags.Append"/> or <see cref="F:Sandbox.GpuBuffer.UsageFlags.Counter"/> structured buffers.
            </summary>
        </member>
        <member name="T:Sandbox.GpuBuffer.UsageFlags">
            <summary>
            You can combine these e.g UsageFlags.Index | UsageFlags.ByteAddress for a buffer that can be used as an index buffer and in a compute shader.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.UsageFlags.Vertex">
            <summary>
            Can be used as a vertex buffer.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.UsageFlags.Index">
            <summary>
            Can be used as an index buffer.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.UsageFlags.ByteAddress">
            <summary>
            Byte Address Buffer (HLSL RWByteAddressBuffer)
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.UsageFlags.Structured">
            <summary>
            Structured Buffer (HLSL RWStructuredBuffer)
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.UsageFlags.Append">
            <summary>
            Append Structured Buffer (HLSL AppendStructuredBuffer)
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.UsageFlags.IndirectDrawArguments">
            <summary>
            Indirect argument buffer for indirect draws
            <seealso cref="T:Sandbox.GpuBuffer.IndirectDrawArguments"/>
            <seealso cref="T:Sandbox.GpuBuffer.IndirectDrawIndexedArguments"/>
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.IndirectDrawArguments.VertexCount">
            <summary>
            Number of vertices to draw per instance.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.IndirectDrawArguments.InstanceCount">
            <summary>
            Number of instances to draw.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.IndirectDrawArguments.FirstVertex">
            <summary>
            Index of the first vertex to draw.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.IndirectDrawArguments.FirstInstance">
            <summary>
            Instance ID of the first instance.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.IndexCount">
            <summary>
            Number of indices to draw per instance.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.InstanceCount">
            <summary>
            Number of instances to draw.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.FirstIndex">
            <summary>
            Index of the first index to draw.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.BaseVertex">
            <summary>
            Value added to each index before indexing into the vertex buffer.
            </summary>
        </member>
        <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.FirstInstance">
            <summary>
            Instance ID of the first instance.
            </summary>
        </member>
        <member name="T:Sandbox.GpuBuffer`1">
            <summary>
            A typed GpuBuffer
            </summary>
            <typeparam name="T">
            The type of data that the GpuBuffer will store.
            Must be a <see href="https://docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types">blittable</see> value type.
            </typeparam>
        </member>
        <member name="T:Sandbox.Graphics">
            <summary>
            Used to render to the screen using your Graphics Card, or whatever you
            kids are using in your crazy future computers. Whatever it is I'm sure
            it isn't fungible and everyone has free money and no-one has to ever work.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.IsActive">
            <summary>
            If true then we're currently rendering and
            you are safe to use the contents of this class
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.LayerType">
            <summary>
            The current layer type. This is useful to tell whether you're meant to be drawing opaque, transparent or shadow. You mainly
            don't need to think about this, but when you do, it's here.
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.grabbedTextures">
            <summary>
            When Frame grabbing, we store the result in this pooled render target. It stays checked out
            until the end of this render scope.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.Viewport">
            <summary>
            In pixel size, where are we rendering to?
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.Attributes">
            <summary>
            Access to the current render context's attributes. These will be used
            to set attributes in materials/shaders. This is cleared at the end of the render block.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.FrameAttributes">
            <summary>
            Access to the current frame's attributes.
            These will live until the end of the frame.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.CameraTransform">
            <summary>
            The camera transform of the currently rendering view
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.CameraPosition">
            <summary>
            The camera position of the currently rendering view
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.CameraRotation">
            <summary>
            The camera rotation of the currently rendering view
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.FieldOfView">
            <summary>
            The field of view of the currently rendering camera view, in degrees.
            </summary>
        </member>
        <member name="T:Sandbox.Graphics.Scope">
            <summary>
            Creates a scope where Graphics is safe to use.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.SetupLighting(Sandbox.SceneObject,Sandbox.RenderAttributes)">
            <summary>
            Setup the lighting attributes for this current object. Place them in the targetAttributes
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.GrabFrameTexture(System.String,Sandbox.RenderAttributes,System.Boolean)">
            <summary>
            Grabs the current viewport's color texture and stores it in targetName on renderAttributes.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.GrabDepthTexture(System.String,Sandbox.RenderAttributes,System.Boolean)">
            <summary>
            Grabs the current depth texture and stores it in targetName on renderAttributes.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.RenderTarget">
            <summary>
            Get or set the current render target. Setting this will bind the render target and change the viewport to match it.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.NativeLayerRenderTarget">
            <summary>
            Get the current color and depth MSAA render targets that this layer is rendering to.
            This should be set on start of scope but is causing problems, left here for advanced usage.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Clear(Color,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Clear the current drawing context to given color.
            </summary>
            <param name="color">Color to clear to.</param>
            <param name="clearColor">Whether to clear the color buffer at all.</param>
            <param name="clearDepth">Whether to clear the depth buffer.</param>
            <param name="clearStencil">Whether to clear the stencil buffer.</param>
        </member>
        <member name="M:Sandbox.Graphics.Clear(System.Boolean,System.Boolean)">
            <summary>
            Clear the current drawing context to given color.
            </summary>
            <param name="clearColor">Whether to clear the color buffer to transparent color.</param>
            <param name="clearDepth">Whether to clear the depth buffer.</param>
        </member>
        <member name="M:Sandbox.Graphics.RenderToTexture(Sandbox.SceneCamera,Sandbox.Texture)">
            <summary>
            Render this camera to the specified texture target
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.CopyTexture(Sandbox.Texture,Sandbox.Texture)">
            <summary>
            Copies pixel data from one texture to another on the GPU.
            This does not automatically resize or scale the texture, format and size should be equal.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.CopyTexture(Sandbox.Texture,Sandbox.Texture,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies pixel data from one texture to another on the GPU.
            This does not automatically resize or scale the texture, format and size should be equal.
            This one lets you copy to/from arrays / specific mips.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw``1(Sandbox.GpuBuffer{``0},Sandbox.Material,System.Int32,System.Int32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draws geometry using a vertex buffer and material.
            </summary>
            <typeparam name="T">The vertex type used for vertex layout.</typeparam>
            <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
            <param name="material">The material to use for rendering.</param>
            <param name="startVertex">The starting vertex index for rendering.</param>
            <param name="vertexCount">The number of vertices to render. If 0, uses all vertices in the buffer.</param>
            <param name="attributes">Optional render attributes to apply only for this draw call.</param>
            <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
        </member>
        <member name="M:Sandbox.Graphics.Draw``1(Sandbox.GpuBuffer{``0},Sandbox.GpuBuffer,Sandbox.Material,System.Int32,System.Int32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draws indexed geometry using vertex and index buffers.
            </summary>
            <typeparam name="T">The vertex type used for vertex layout.</typeparam>
            <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
            <param name="indexBuffer">The GPU buffer containing index data.</param>
            <param name="material">The material to use for rendering.</param>
            <param name="startIndex">The starting index for rendering.</param>
            <param name="indexCount">The number of indices to render. If 0, uses all indices in the buffer.</param>
            <param name="attributes">Optional render attributes to apply only for this draw call.</param>
            <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
        </member>
        <member name="M:Sandbox.Graphics.DrawInternal``1(``0*,System.Int32,System.UInt16*,System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            This is our entry point into the engine for all draws
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw(System.Span{Sandbox.Vertex},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw``1(System.Span{``0},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            TODO: make this public
            TODO: Is this safe to be public
            TODO: Is VertexLayoutManager.Get Safe 
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw(System.Collections.Generic.List{Sandbox.Vertex},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw``1(System.Collections.Generic.List{``0},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            TODO: make this public
            TODO: Is this safe to be public
            TODO: Is VertexLayoutManager.Get Safe 
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw(System.Span{Sandbox.Vertex},System.Int32,System.Span{System.UInt16},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Blit(Sandbox.Material,Sandbox.RenderAttributes)">
            <summary>
            Draw a screen space quad using the passed material. Your material should be using a
            screenspace shader so it will actually render to the screen and not in worldspace at 0,0,0
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Render(Sandbox.SceneObject,System.Nullable{Transform},System.Nullable{Color},Sandbox.Material)">
            <summary>
            Render a SceneObject
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawQuad(Sandbox.Rect@,Sandbox.Material@,Color@,Sandbox.RenderAttributes)">
            <summary>
            Draw a quad in screenspace
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawQuad(Sandbox.Rect@,System.Single@,Sandbox.Material@,Color@,Sandbox.RenderAttributes)">
            <summary>
            Draw a rotated quad in screenspace
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawText(Sandbox.Rect@,System.String,Color,System.String,System.Single,System.Single,Sandbox.TextFlag)">
            <summary>
            Draws a text quad in screenspace using the Material.UI.Text material.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawText(Sandbox.Rect@,Sandbox.TextRendering.Scope@,Sandbox.TextFlag)">
            <summary>
            Draws a text quad in screenspace using the Material.UI.Text material.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawText(Sandbox.Rect@,System.Single,Sandbox.TextRendering.Scope@,Sandbox.TextFlag)">
            <summary>
            Draws a rotated text quad in screenspace using the Material.UI.Text material.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawText(Vector2@,System.String,Color,System.String,System.Single,System.Single)">
            <summary>
            Draws a text quad in screenspace using the Material.UI.Text material.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.MeasureText(Sandbox.Rect@,System.String,System.String,System.Single,System.Single,Sandbox.TextFlag)">
            <summary>
            Measure how big some text will be, without having to render it
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.MeasureText(Sandbox.Rect@,Sandbox.TextRendering.Scope@,Sandbox.TextFlag)">
            <summary>
            Measure how big some text will be, without having to render it
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawIcon(Sandbox.Rect,System.String,Color,System.Single,Sandbox.TextFlag)">
            <summary>
            Calls DrawText with "Material Icons" font. You can get a list of icons here https://fonts.google.com/icons?selected=Material+Icons
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawRoundedRectangle(Sandbox.Rect@,Color@,Vector4@,Vector4@,Color@)">
            <summary>
            Draw a rounded rectangle, with optional border, in Material.UI.Box
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawModel(Sandbox.Model,Transform,Sandbox.RenderAttributes)">
            <summary>
            Draws a single model at the given Transform immediately.
            </summary>
            <param name="model">The model to draw</param>
            <param name="transform">Transform to draw the model at</param>
            <param name="attributes">Optional attributes to apply only for this draw call</param>
        </member>
        <member name="M:Sandbox.Graphics.DrawModelInstanced(Sandbox.Model,System.Span{Transform},Sandbox.RenderAttributes)">
            <summary>
            Draws multiple instances of a model using GPU instancing, assuming standard implemented shaders.
            
            Use `GetTransformMatrix( int instance )` in shaders to access the instance transform.
            
            There is a limit of 1,048,576 transform slots per frame when using this method.
            </summary>
            <param name="model">The model to draw</param>
            <param name="transforms">Instance transform data to draw</param>
            <param name="attributes">Optional attributes to apply only for this draw call</param>
        </member>
        <member name="M:Sandbox.Graphics.DrawModelInstancedIndirect(Sandbox.Model,Sandbox.GpuBuffer,System.Int32,Sandbox.RenderAttributes)">
            <summary>
            Draws multiple instances of a model using GPU instancing with the number of instances being provided by indirect draw arguments.
            Use `SV_InstanceID` semantic in shaders to access the rendered instance.
            </summary>
            <param name="model">The model to draw</param>
            <param name="buffer">The GPU buffer containing the DrawIndirectArguments</param>
            <param name="bufferOffset">Optional offset in the GPU buffer</param>
            <param name="attributes">Optional attributes to apply only for this draw call</param>
        </member>
        <member name="M:Sandbox.Graphics.DrawModelInstanced(Sandbox.Model,System.Int32,Sandbox.RenderAttributes)">
            <summary>
            Draws multiple instances of a model using GPU instancing.
            This is similar to <see cref="M:Sandbox.Graphics.DrawModelInstancedIndirect(Sandbox.Model,Sandbox.GpuBuffer,System.Int32,Sandbox.RenderAttributes)"/>,
            except the count is provided from the CPU rather than via a GPU buffer.
            
            Use `SV_InstanceID` semantic in shaders to access the rendered instance.
            </summary>
            <param name="model">The model to draw</param>
            <param name="count">The number of instances to draw</param>
            <param name="attributes">Optional attributes to apply only for this draw call</param>
        </member>
        <member name="M:Sandbox.Graphics.OnLayer(System.Int32,ManagedRenderSetup_t)">
            <summary>
            Called by the engine during pipeline. This could be rendering the scene from any camera.
            That means you can't assume this is the game view. This might be a tools view, or another view
            </summary>
        </member>
        <member name="T:Sandbox.Graphics.DownsampleMethod">
            <summary>
            Which method to use when downsampling a texture
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.Box">
            <summary>
            Uses a box filter to downsample the texture
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.GaussianBlur">
            <summary>
            Uses a gaussian filter to downsample the texture
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.GGX">
            <summary>
            Downsamples the texture using GGX normal distribution function, suitable for using with PBR materials
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.Max">
            <summary>
            Downsamples the texture using a max operator filter ( brightest pixel )
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.Min">
            <summary>
            Downsamples the texture using a min operator filter ( darkest pixel )
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.MinMax">
            <summary>
            Downsamples the texture in red and green channels using a Min/Max filter ( darkest and brightest pixel )
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.GenerateMipMaps(Sandbox.Texture,Sandbox.Graphics.DownsampleMethod,System.Int32,System.Int32)">
            <summary>
            Generate the mip maps for this texture. Obviously the texture needs to support mip maps.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.ResourceBarrierTransition(Sandbox.Texture,Sandbox.Rendering.ResourceState)">
            <summary>
            Executes a barrier transition for the given GPU Texture Resource.
            Transitions the texture resource to a new pipeline stage and access state.
            </summary>
            <param name="texture">The texture to transition.</param>
            <param name="state">The new resource state for the texture.</param>
        </member>
        <member name="M:Sandbox.Graphics.ResourceBarrierTransition``1(Sandbox.GpuBuffer{``0},Sandbox.Rendering.ResourceState)">
            <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource to a new pipeline stage and access state.
            </summary>
            <typeparam name="T">The unmanaged type of the buffer elements.</typeparam>
            <param name="buffer">The GPU buffer to transition.</param>
            <param name="state">The new resource state for the buffer.</param>
        </member>
        <member name="M:Sandbox.Graphics.ResourceBarrierTransition(Sandbox.GpuBuffer,Sandbox.Rendering.ResourceState)">
            <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource to a new pipeline stage and access state.
            </summary>
            <param name="buffer">The GPU buffer to transition.</param>
            <param name="state">The new resource state for the buffer.</param>
        </member>
        <member name="M:Sandbox.Graphics.ResourceBarrierTransition``1(Sandbox.GpuBuffer{``0},Sandbox.Rendering.ResourceState,Sandbox.Rendering.ResourceState)">
            <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource from a known source state to a specified destination state.
            </summary>
            <typeparam name="T">The unmanaged type of the buffer elements.</typeparam>
            <param name="buffer">The GPU buffer to transition.</param>
            <param name="before">The current resource state of the buffer.</param>
            <param name="after">The desired resource state of the buffer after the transition.</param>
        </member>
        <member name="M:Sandbox.Graphics.ResourceBarrierTransition(Sandbox.GpuBuffer,Sandbox.Rendering.ResourceState,Sandbox.Rendering.ResourceState)">
            <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource from a known source state to a specified destination state.
            </summary>
            <param name="buffer">The GPU buffer to transition.</param>
            <param name="before">The current resource state of the buffer.</param>
            <param name="after">The desired resource state of the buffer after the transition.</param>
        </member>
        <member name="M:Sandbox.Graphics.ResourceStateToVulkanFlags(Sandbox.Rendering.ResourceState,NativeEngine.RenderBarrierPipelineStageFlags_t@,NativeEngine.RenderBarrierAccessFlags_t@,NativeEngine.RenderImageLayout_t@)">
            <summary>
            Figure out what flags Vulkan needs for the given ResourceState
            </summary>
        </member>
        <member name="T:Sandbox.MorphCollection">
            <summary>
            Used to access and manipulate morphs.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.ResetAll">
            <summary>
            Reset all morphs to their default values.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Reset(System.Int32)">
            <summary>
            Reset morph number i to its default value.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Reset(System.String)">
            <summary>
            Reset named morph to its default value.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Set(System.Int32,System.Single)">
            <summary>
            Set indexed morph to this value.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Set(System.String,System.Single)">
            <summary>
            Set named morph to this value.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Get(System.Int32)">
            <summary>
            Get indexed morph value (Note: Currently, this only gets the override morph value)
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Get(System.String)">
            <summary>
            Get named morph value (Note: Currently, this only gets the override morph value)
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.GetName(System.Int32)">
            <summary>
            Retrieve name of a morph at given index.
            </summary>
        </member>
        <member name="P:Sandbox.MorphCollection.Count">
            <summary>
            Amount of morphs.
            </summary>
        </member>
        <member name="T:Sandbox.MusicPlayer">
            <summary>
            Enables music playback. Use this for music, not for playing game sounds.
            </summary>
        </member>
        <member name="F:Sandbox.MusicPlayer.native">
            <summary>
            We only use the audio component of the video player.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.SampleRate">
            <summary>
            Sample rate of the audio being played.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Channels">
            <summary>
            Number of channels of the audio being played.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Duration">
            <summary>
            Gets the total duration of the video in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.PlaybackTime">
            <summary>
            Gets the current playback time in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.OnFinished">
            <summary>
            Invoked when the audio has finished playing.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.OnRepeated">
            <summary>
            Invoked when the audio has repeated.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.ListenLocal">
            <summary>
            Place the listener at 0,0,0 facing 1,0,0.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Position">
            <summary>
            Position of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Paused">
            <summary>
            Pause playback of audio.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Repeat">
            <summary>
            Audio will repeat when reaching the end.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Volume">
            <summary>
            Change the volume of this music.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.LipSync">
            <summary>
            Enables lipsync processing.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.TargetMixer">
            <summary>
            Which mixer do we want to write to
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Distance">
            <inheritdoc cref="P:Sandbox.SoundHandle.Distance"/>
        </member>
        <member name="P:Sandbox.MusicPlayer.Falloff">
            <inheritdoc cref="P:Sandbox.SoundHandle.Falloff"/>
        </member>
        <member name="P:Sandbox.MusicPlayer.Visemes">
            <summary>
            A list of 15 lipsync viseme weights. Requires <see cref="P:Sandbox.MusicPlayer.LipSync"/> to be enabled.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Title">
            <summary>
            Get title of the track.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Spectrum">
            <summary>
            512 FFT magnitudes used for audio visualization.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Amplitude">
            <summary>
            Approximate measure of audio loudness.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.PlayUrl(System.String)">
            <summary>
            Plays a music stream from a URL.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.Play(Sandbox.BaseFileSystem,System.String)">
            <summary>
            Plays a music file from a relative path.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.Stop">
            <summary>
            Stops audio playback.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.Seek(System.Single)">
            <summary>
            Sets the playback position to a specified time in the audio, given in seconds.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.GetMeta(System.String)">
            <summary>
            Get meta data string.
            </summary>
        </member>
        <member name="T:Sandbox.ScreenCaptureUtility">
            <summary>
            Utility methods for screen recording and screenshot functionality
            </summary>
        </member>
        <member name="M:Sandbox.ScreenCaptureUtility.GenerateScreenshotFilename(System.String)">
            <summary>
            Generates a suitable screenshot filename with timestamp
            </summary>
        </member>
        <member name="T:Sandbox.ScreenRecorder">
            <summary>
            Records the screen to a video file.
            </summary>
        </member>
        <member name="M:Sandbox.ScreenRecorder.IsRecording">
            <summary>
            Gets whether a recording is currently in progress.
            </summary>
        </member>
        <member name="M:Sandbox.ScreenRecorder.StartRecording">
            <summary>
            Starts recording to the specified file.
            </summary>
            <returns>True if recording started successfully</returns>
        </member>
        <member name="M:Sandbox.ScreenRecorder.StopRecording">
            <summary>
            Stops the current recording.
            </summary>
        </member>
        <member name="M:Sandbox.ScreenRecorder.RecordVideoFrame(NativeEngine.IRenderContext,NativeEngine.ITexture)">
            <summary>
            Captures a video frame from the provided render context and view.
            </summary>
        </member>
        <member name="M:Sandbox.ScreenRecorder.RecordAudioSample(CAudioMixDeviceBuffers)">
            <summary>
            Captures an audio frame from the provided audio buffers.
            </summary>
        </member>
        <member name="T:Sandbox.ScreenshotService">
            <summary>
            Provides functionality to capture and save screenshots in various formats.
            </summary>
        </member>
        <member name="M:Sandbox.ScreenshotService.RequestCapture">
            <summary>
            Captures the screen and saves it as a PNG file.
            </summary>
        </member>
        <member name="M:Sandbox.ScreenshotService.CaptureRenderTexture(NativeEngine.IRenderContext,NativeEngine.ITexture,System.String)">
            <summary>
            Captures the current render target and saves it to the specified file.
            </summary>
        </member>
        <member name="T:Sandbox.VideoPlayer">
            <summary>
            Enables video playback and access to the video texture and audio.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.OnLoaded">
            <summary>
            Video successfully loaded.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.OnAudioReady">
            <summary>
            Event that is invoked when the audio stream is created and ready to use.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.OnFinished">
            <summary>
            Video finished playing.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.OnRepeated">
            <summary>
            Video started playing again after looping.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.OnTextureData">
            <summary>
            If this event is set, texture data will be provided instead of rendering to the texture.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Repeat">
            <summary>
            Sets whether the video should loop when it reaches the end.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Duration">
            <summary>
            Gets the total duration of the video in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.PlaybackTime">
            <summary>
            Gets the current playback time in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.SampleRate">
            <summary>
            Audio sample rate.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Channels">
            <summary>
            Number of audio channels.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.HasAudio">
            <summary>
            Does the loaded video have audio?
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.IsPaused">
            <summary>
            Has the video been paused?
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Texture">
            <summary>
            Texture of the video frame.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Width">
            <summary>
            Width of the video.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Height">
            <summary>
            Height of the video.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Audio">
            <summary>
            Access audio properties for this video playback.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.ListenLocal">
            <summary>
            Place the listener at 0,0,0 facing 1,0,0.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.Position">
            <summary>
            Position of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.TargetMixer">
            <summary>
            Which mixer do we want to write to
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.Volume">
            <summary>
            Volume of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.LipSync">
            <summary>
            Enables lipsync processing.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.Distance">
            <inheritdoc cref="P:Sandbox.SoundHandle.Distance"/>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.Falloff">
            <inheritdoc cref="P:Sandbox.SoundHandle.Falloff"/>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.Visemes">
            <summary>
            A list of 15 lipsync viseme weights. Requires <see cref="P:Sandbox.VideoPlayer.AudioAccessor.LipSync"/> to be enabled.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.GetMeta(System.String)">
            <summary>
            Get meta data string.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Play(System.String)">
            <summary>
            Plays a video file from a URL. If there's already a video playing, it will stop.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Play(Sandbox.BaseFileSystem,System.String)">
            <summary>
            Plays a video file from a relative path. If there's already a video playing, it will stop.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Resume">
            <summary>
            Resumes video playback.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Stop">
            <summary>
            Stops video playback.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Pause">
            <summary>
            Pauses video playback.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.TogglePause">
            <summary>
            Toggle video playback
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Seek(System.Single)">
            <summary>
            Sets the playback position to a specified time in the video, given in seconds.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Present">
            <summary>
            Present a video frame.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Muted">
            <summary>
            The video is muted
            </summary>
        </member>
        <member name="T:Sandbox.VideoWriter">
            <summary>
            Allows the creation of video content by encoding a sequence of frames.
            </summary>
        </member>
        <member name="M:Sandbox.VideoWriter.Config.IsCodecSupported">
            <summary>
            Can this container support the codec.
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.H264">
            <summary>
            H.264 codec (does not support transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.H265">
            <summary>
            H.265 codec (does not support transparency)
            Only supported on modern GPUS, will fallback to H.264 if not supported.
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.VP8">
            <summary>
            VP8 codec (does not support transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.VP9">
            <summary>
            VP9 codec (supports transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.WebP">
            <summary>
            WebP codec (supports transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Container.MP4">
            <summary>
            MP4 container (does not support transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Container.WebM">
            <summary>
            WebM container (supports transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Container.WebP">
            <summary>
            WebP container (supports transparency)
            </summary>
        </member>
        <member name="M:Sandbox.VideoWriter.Dispose">
            <summary>
            Dispose this recorder, the encoder will be flushed and video finalized.
            </summary>
        </member>
        <member name="M:Sandbox.VideoWriter.FinishAsync">
            <summary>
            Finish creating this video. The encoder will be flushed and video finalized.
            </summary>
        </member>
        <member name="M:Sandbox.VideoWriter.AddFrame(System.ReadOnlySpan{System.Byte},System.Nullable{System.TimeSpan})">
            <summary>
            Add a frame of data to be encoded. Timestamp is in microseconds. 
            If a timestamp is not specified, it will use an incremented 
            frame count as the timestamp.
            </summary>
            <param name="data">The frame data to be encoded.</param>
            <param name="timestamp">The timestamp for the frame in microseconds. If not specified, an incremented frame count will be used.</param>
        </member>
        <member name="M:Sandbox.VideoWriter.AddFrame(Sandbox.Bitmap,System.Nullable{System.TimeSpan})">
            <summary>
            Add a frame of data to be encoded. Timestamp is in microseconds. 
            If a timestamp is not specified, it will use an incremented 
            frame count as the timestamp.
            </summary>
            <param name="bitmap">The frame data to be encoded.</param>
            <param name="timestamp">The timestamp for the frame in microseconds. If not specified, an incremented frame count will be used.</param>
        </member>
        <member name="M:Sandbox.VideoWriter.AddAudioSamples(CAudioMixDeviceBuffers)">
            <summary>
            Internal for now as I have no idea, how to expose audio recording in a good way yet.
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetPointer(Sandbox.StringToken@,System.IntPtr@)">
            <summary>
            Internal for a reason - don't expose!
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,System.Span{``0})">
            <summary>
            Set a constant buffer to a specific value
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,``0)">
            <summary>
            Set a constant buffer to a specific value
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,``0[])">
            <summary>
            Set a constant buffer to a specific value
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,System.Collections.Generic.List{``0})">
            <summary>
            Set a constant buffer to a specific value
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetBool(Sandbox.StringToken@,System.Boolean@)">
            <summary>
            Get a bool value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetVector(Sandbox.StringToken@,Vector3@)">
            <summary>
            Get a vector3 value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetVector4(Sandbox.StringToken@,Vector4@)">
            <summary>
            Get a vector4 value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetAngles(Sandbox.StringToken@,Angles@)">
            <summary>
            Get a vector4 value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetFloat(Sandbox.StringToken@,System.Single@)">
            <summary>
            Get a float value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetInt(Sandbox.StringToken@,System.Int32@)">
            <summary>
            Get a int value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetMatrix(Sandbox.StringToken@,Matrix@)">
            <summary>
            Get a matrix value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetTexture(Sandbox.StringToken@,Sandbox.Texture@)">
            <summary>
            Get a texture value - else defaultValue if missing
            </summary>
        </member>
        <member name="T:Sandbox.RenderTarget">
            <summary>
            Essentially wraps a couple of textures that we're going to render to. The color texture and the depth texture.
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.GetTemporary(System.Int32,System.Int32,Sandbox.ImageFormat,Sandbox.ImageFormat,Sandbox.MultisampleAmount,System.Int32,System.String)">
            <summary>
            Get a temporary render target. You should dispose the returned handle when you're done to return the textures to the pool.
            </summary>
            <param name="width">Width of the render target you want.</param>
            <param name="height">Height of the render target you want.</param>
            <param name="colorFormat">The format for the color buffer. If set to default we'll use whatever the current pipeline is using.</param>
            <param name="depthFormat">The format for the depth buffer.</param>
            <param name="msaa">The number of msaa samples you'd like. Msaa render textures are a pain in the ass so you're probably gonna regret trying to use this.</param>
            <param name="numMips">Number of mips you want in this texture. You probably don't want this unless you want to generate mips in a second pass.</param>
            <param name="targetName">The optional name of the render target</param>
            <returns>A RenderTarget that is ready to render to.</returns>
        </member>
        <member name="M:Sandbox.RenderTarget.GetTemporary(System.Int32,Sandbox.ImageFormat,Sandbox.ImageFormat,Sandbox.MultisampleAmount,System.Int32,System.String)">
            <summary>
            Get a temporary render target. You should dispose the returned handle when you're done to return the textures to the pool.
            </summary>
            <param name="sizeFactor">Divide the screen size by this factor. 2 would be half screen sized. 1 for full screen sized.</param>
            <param name="colorFormat">The format for the color buffer. If null we'll choose the most appropriate for where you are in the pipeline.</param>
            <param name="depthFormat">The format for the depth buffer.</param>
            <param name="msaa">The number of msaa samples you'd like. Msaa render textures are a pain in the ass so you're probably gonna regret trying to use this.</param>
            <param name="numMips">Number of mips you want in this texture. You probably don't want this unless you want to generate mips in a second pass.</param>
            <param name="targetName">The optional name of the render target</param>
            <returns>A RenderTarget that is ready to render to.</returns>
        </member>
        <member name="M:Sandbox.RenderTarget.EndOfFrame">
            <summary>
            Called at the end of the frame. At this point none of the render targets that were loaned out
            should be being used, so we can put them all back in the pool.
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.Flush">
            <summary>
            Flush all the render targets out. Useful to do when screen size changes.
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.Loaned">
            <summary>
            Is this currently loaned out (Active)
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.FramesSinceUsed">
            <summary>
            The amount of time since this texture was last used
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.CreationHash">
            <summary>
            The hash of the parameters used to create this
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.Width">
            <summary>
            Width of the render target
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.Height">
            <summary>
            Height of the render target
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.ColorTarget">
            <summary>
            The target colour texture
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.DepthTarget">
            <summary>
            The target depth texture
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.Dispose">
            <summary>
            Stop using this texture, return it to the pool
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.Destroy">
            <summary>
            Destroy this buffer. It shouldn't be used anymore after this.
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.From(Sandbox.Texture,Sandbox.Texture)">
            <summary>
            Create a render target from these textures
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.Translucent">
            <summary>
            Translucent pass. We're rendering translucent objects in depth sorted order, from back to front.
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.Shadow">
            <summary>
            Rendering dynamic shadows
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.EffectsTranslucent">
            <summary>
            Translucent effects on the 1/4 texture
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.EffectsOpaque">
            <summary>
            Opaque effects on the 1/4 texture
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.DepthPrepass">
            <summary>
            Depth prepass to reduce overdraw
            </summary>
        </member>
        <member name="M:Sandbox.FontManager.GetBestTypeface(Topten.RichTextKit.IStyle)">
            <summary>
            Tries to get the best matching font for the given style.
            Will return a matching font family with the closest font weight and optionally slant.
            </summary>
        </member>
        <member name="M:Sandbox.TextRendering.GetOrCreateTexture(Sandbox.TextRendering.Scope@,Vector2,Sandbox.TextFlag,Sandbox.UI.FontSmooth)">
            <summary>
            Create a texture from the scope. The texture will either be a cached version or will be rendered immediately
            </summary>
        </member>
        <member name="M:Sandbox.TextRendering.GetOrCreateTextBlock(System.Int32,System.Boolean@)">
            <summary>
            We don't expose this because we don't want them to do something stupid like free
            a textblock that they're still using
            </summary>
        </member>
        <member name="M:Sandbox.TextRendering.Tick">
            <summary>
            Free old, unused textblocks (and their textures)
            </summary>
        </member>
        <member name="T:Sandbox.TextRendering.Scope">
            <summary>
            Defines a scope of text, all using the same style.
            </summary>
        </member>
        <member name="M:Sandbox.TextRendering.Scope.Measure">
            <summary>
            Measures the rendered size of the text in this <see cref="T:Sandbox.TextRendering.Scope"/> using its current style settings. This is non trivial
            but the underlying style is cached, so if you end up drawing it, it'll re-use the cached data anyway.
            </summary>
            <returns>
            A <see cref="T:Vector2"/> representing the width and height, in pixels, of the rendered text.
            </returns>
        </member>
        <member name="T:Sandbox.TextRendering.TextBlock">
            <summary>
            We'll expose this at some point, but will probably be as Sandbox.TextBlock - and then need to think about ownership and caching
            </summary>
        </member>
        <member name="T:Sandbox.VertexLayout">
            <summary>
            Allows for the definition of custom vertex layouts
            </summary>
        </member>
        <member name="M:Sandbox.VertexLayout.FreeAll">
            <summary>
            Should probably be calling this on hotload, when types are changed?
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.Enabled">
            <summary>
            Indicates whether the fog system is enabled.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.Anisotropy">
            <summary>
            Level of anisotropy.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.Scattering">
            <summary>
            Scattering value.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.DrawDistance">
            <summary>
            Draw distance.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.FadeInStart">
            <summary>
            Start distance where fading begins.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.FadeInEnd">
            <summary>
            End distance where fading concludes.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.IndirectStrength">
            <summary>
            Strength of indirect illumination.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.BakedIndirectTexture">
            <summary>
            Provides indirect lighting from a baked volume texture.
            This gets compiled with your map and is provided by an env_volumetric_controller.
            </summary>
            <remarks>
            You shouldn't expect to be able to add new runtime fog volumes if using this.
            </remarks>
        </member>
        <member name="P:Sandbox.CubemapFogController.LodBias">
            <summary>
            Adjust how quickly the cubemap blurs out at closer distances. A value of 0.0 always uses the lowest resolution MIP over the entire range, while a value of 1.0 uses the highest.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.StartDistance">
            <summary>
            The distance from the player at which the fog will start to fade in.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.EndDistance">
            <summary>
            The distance from the player at which the fog will be at full strength.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.FalloffExponent">
            <summary>
            Exponent for distance falloff. For example, 2.0 is proportional to square of distance.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.HeightWidth">
            <summary>
            The distance between the start of the height fog and where it is fully opaque. Setting this to 0 will disable height based blending.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.HeightStart">
            <summary>
            The absolute height in the map at which the height fog will start to fade in.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.HeightExponent">
            <summary>
            Exponent for height falloff. For example, 2.0 is proportional to square of distance.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.Enabled">
            <summary>
            Is this cubemap fog active?
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.Texture">
            <summary>
            Cubemap texture to use for the fog.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.Transform">
            <summary>
            Location of the fog.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.Tint">
            <summary>
            Tint of the fog. 
            </summary>
        </member>
        <member name="T:Sandbox.DecalSceneObject">
            <summary>
            A decal. Use the Component.
            </summary>
        </member>
        <member name="T:Sandbox.IManagedCamera">
            <summary>
            Used for c++ to make callbacks to a camera and be able to find it by id
            </summary>
        </member>
        <member name="M:Sandbox.IManagedCamera.OnRenderStage(Sandbox.Rendering.Stage)">
            <summary>
            Called when entering a specific pipeline stage
            </summary>
        </member>
        <member name="M:Sandbox.IManagedCamera.AllocateCameraId">
            <summary>
            Allocate a camera id for this camera. This is used to find the camera in the c++ code.
            </summary>
        </member>
        <member name="M:Sandbox.IManagedCamera.FindById(System.Int32)">
            <summary>
            Find a camera by its id. This is used to find the camera by the calling c++ code. This is called
            in the render thread, so it's important to be thread-safe.
            </summary>
        </member>
        <member name="M:Sandbox.IManagedCamera.Cleanup">
            <summary>
            keep the directory clean by trimming all the old ones
            </summary>
        </member>
        <member name="T:Sandbox.SceneCamera">
            <summary>
            Represents a camera and holds render hooks. This camera can be used to draw tool windows and scene panels.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Bloom">
            <summary>
            Access tonemapping properties of camera
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.BloomAccessor.Enabled">
            <summary>
            Enable or disable exposure.
            </summary>
        </member>
        <member name="F:Sandbox.SceneCamera._frustum">
            <summary>
            This is a c++ object with a ton of useful shit.
            Don't access it directly because it might be dirty.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Name">
            <summary>
            The name of this camera.. for debugging purposes.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.ExcludeTags">
            <summary>
            Scene objects with any of these tags won't be rendered by this camera.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.RenderTags">
            <summary>
            Only scene objects with one of these tags will be rendered by this camera.
            </summary>
        </member>
        <member name="F:Sandbox.SceneCamera.OnRenderStageHook">
            <summary>
            Keep hidden! CommandBuffers only!!
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OnRenderPostProcess">
            <summary>
            Called when rendering the post process pass
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OnRenderOpaque">
            <summary>
            Called when rendering the transparent pass
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OnRenderTransparent">
            <summary>
            Called when rendering the transparent pass
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OnRenderOverlay">
            <summary>
            Called when rendering the camera's overlay
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Size">
            <summary>
            The size of the screen. Allows us to work out aspect ratio.
            For now will get updated automatically on render.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.VolumetricFog">
            <summary>
            Control volumetric fog parameters, expect this to take 1-2ms of your GPU frame time.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.CubemapFog">
            <summary>
            Control fog based on an image.
            </summary>
        </member>
        <member name="F:Sandbox.SceneCamera.CubeRotations">
            <summary>
            Define the rotations for each of the 6 cube faces (right, left, up, down, front, back)
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.World">
            <summary>
            The world we're going to render.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Worlds">
            <summary>
            Your camera can render multiple worlds.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Position">
            <summary>
            The position of the scene's camera.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Rotation">
            <summary>
            The rotation of the scene's camera.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Angles">
            <summary>
            The rotation of the scene's camera.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.FieldOfView">
            <summary>
            The horizontal field of view of the Camera in degrees.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.ZFar">
            <summary>
            The camera's zFar distance. This is the furthest distance this camera will be able to render.
            This value totally depends on the game you're making. Shorter the better, sensible ranges would be
            between about 1000 and 30000, but if you want it to be further out you can balance that out by making
            znear larger.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.ZNear">
            <summary>
            The camera's zNear distance. This is the closest distance this camera will be able to render.
            A good value for this is about 5. Below 5 and particularly below 1 you're going to start to see
            a lot of artifacts like z-fighting.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Ortho">
            <summary>
            Whether to use orthographic projection.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OrthoHeight">
            <summary>
            Height of the ortho when <see cref="P:Sandbox.SceneCamera.Ortho"/> is enabled.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.DebugMode">
            <summary>
            Render this camera using a different render mode
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.WireframeMode">
            <summary>
            Render this camera using a wireframe view.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.ClearFlags">
            <summary>
            What kind of clearing should we do before we begin?
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Rect">
            <summary>
            The rect of the screen to render to. This is normalized, between 0 and 1.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.BackgroundColor">
            <summary>
            Color the scene camera clears the render target to.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.AmbientLightColor">
            <summary>
            The color of the ambient light. Set it to black for no ambient light, alpha is used for lerping between IBL and constant color.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.AntiAliasing">
            <summary>
            Enable or disable anti-aliasing for this render.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.EnablePostProcessing">
            <summary>
            Toggle all post processing effects for this camera. The default is on.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TargetEye">
            <summary>
            The HMD eye that this camera is targeting.
            Use <see cref="F:Sandbox.StereoTargetEye.None"/> for the user's monitor (i.e. the companion window).
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.WantsStereoSubmit">
            <summary>
            Set this to false if you don't want the stereo renderer to submit this camera's texture to the compositor.
            This option isn't considered if <see cref="P:Sandbox.SceneCamera.TargetEye"/> is <see cref="F:Sandbox.StereoTargetEye.None"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.EnableDirectLighting">
            <summary>
            Enable or disable direct lighting
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.EnableIndirectLighting">
            <summary>
            Enable or disable indirect lighting
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.OnPreRender(Vector2)">
            <summary>
            Should be called before a render
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ConfigureView(Sandbox.Rendering.ViewSetup@)">
            <summary>
            Configure the view immediately before rendering. This will set the camera position
            etc on the local camera renderer. This should be called immediately before adding
            the views etc.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect)">
            <summary>
            Given a pixel rect return a frustum on the current camera.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect,Vector3)">
            <summary>
            Given a pixel rect return a frustum on the current camera. Pass in 1 to ScreenSize to use normalized screen coords.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.GetRay(Vector3)">
            <summary>
            Given a cursor position get a scene aiming ray.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.GetRay(Vector2,Vector3)">
            <summary>
            Given a cursor position get a scene aiming ray.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ToScreen(Vector3)">
            <summary>
            Convert from world coords to screen coords. The results for x and y will be from 0 to <see cref="P:Sandbox.SceneCamera.Size"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ToScreen(Vector3,Vector2@)">
            <summary>
            Convert from world coords to screen coords. The results for x and y will be from 0 to <see cref="P:Sandbox.SceneCamera.Size"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ToScreen(Line)">
            <summary>
            Projects a line in world space to screen coords, returning null if the line is
            fully behind the camera.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ToScreenNormal(Vector3)">
            <summary>
            Convert from world coords to normal screen corrds. The results will be between 0 and 1
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ToScreenWithDirection(Vector3)">
            <summary>
            Convert from world coords to screen coords but the Z component stores whether this vector
            is behind the screen (&lt;0) or in front of it (&gt;0). The X and Y components are normalized
            from 0 to 1.
            </summary>
            <param name="world"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SceneCamera.ToWorld(Vector2)">
            <summary>
            Convert from screen coords to world coords on the near frustum plane.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.RenderToCubeTexture(Sandbox.Texture,System.Action,Sandbox.Rendering.ViewSetup@)">
            <summary>
            Renders the scene from the camera position to a cube texture, capturing all 6 directions.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.CustomProjectionMatrix">
            <summary>
            Allows specifying a custom projection matrix for this camera
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Tonemap">
            <summary>
            Access tonemapping properties of camera
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.Enabled">
            <summary>
            Enable or disable exposure.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.Rate">
            <summary>
            The rate of change for exposure.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.Fade">
            <summary>
            Set the speed at which exposure fades downwards (diminishes) in response to light changes.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.MinExposure">
            <summary>
            Minimum auto exposure scale
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.MaxExposure">
            <summary>
            Maximum auto exposure scale
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.ExposureCompensation">
            <summary>
            Number of stops to adjust auto-exposure by
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.PercentTarget">
            <summary>
            Set a custom brightness target to go along with 'Target Bright Pixel Percentage'. (-1 for default engine behavior)
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.PercentBrightPixels">
            <summary>
            Set a target for percentage of pixels above a certain brightness. (-1 for default engine behavior)
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.MinAverageLuminance">
            <summary>
            Set the minimum average luminance. This ensures that certain regions aren't too dim after tonemapping
            </summary>
        </member>
        <member name="T:Sandbox.ClearFlags">
            <summary>
            Flags for clearing a RT before rendering a scene using a SceneCamera
            </summary>
        </member>
        <member name="M:Sandbox.SceneCubemap.RenderDirty">
            <summary>
            Marks the cubemap as dirty, to be re-rendered on the next render.
            </summary>
        </member>
        <member name="T:Sandbox.SceneCullingBox">
            <summary>
            A box which can be used to explicitly control scene visibility. 
            There are two modes:
            1. Cull inside, hide any objects fully inside the box (excluder)
            2. Cull outside, hide any objects not intersecting any cull boxes marked cull outside (includer)
            </summary>
        </member>
        <member name="T:Sandbox.SceneCullingBox.CullMode">
            <summary>
            Cull mode, either inside or outside
            </summary>
        </member>
        <member name="F:Sandbox.SceneCullingBox.CullMode.Inside">
            <summary>
            Hide any objects fully inside the box
            </summary>
        </member>
        <member name="F:Sandbox.SceneCullingBox.CullMode.Outside">
            <summary>
            Hide any objects not intersecting any boxes
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.IsValid">
            <summary>
            Is this culling box valid, exists inside a scene world.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.World">
            <summary>
            The scene world this culling box belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.Transform">
            <summary>
            Position and rotation of this box, scale will scale the box size
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.Size">
            <summary>
            Size of this box, transform scale will scale this size
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.Mode">
            <summary>
            Cull mode, either inside or outside
            </summary>
        </member>
        <member name="M:Sandbox.SceneCullingBox.#ctor(Sandbox.SceneWorld,Transform,Vector3,Sandbox.SceneCullingBox.CullMode)">
            <summary>
            Create a scene culling box.
            Each scene world can have a list of boxes which can be used to explicitly cull objects inside or outside the boxes.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCullingBox.Delete">
            <summary>
            Delete this culling box. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="T:Sandbox.SceneCustomObject">
            <summary>
            A scene object that allows custom rendering within a scene world.
            </summary>
        </member>
        <member name="F:Sandbox.SceneCustomObject.RenderOverride">
            <summary>
            Called by default version of <see cref="M:Sandbox.SceneCustomObject.RenderSceneObject"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCustomObject.RenderSceneObject">
            <summary>
            Called when this scene object needs to be rendered.
            Invokes <see cref="F:Sandbox.SceneCustomObject.RenderOverride"/> by default. See the <see cref="T:Sandbox.Graphics" /> library for a starting point.
            </summary>
        </member>
        <member name="T:Sandbox.SceneDirectionalLight">
            <summary>
            A directional scene light that is used to mimic sun light in a <see cref="T:Sandbox.SceneWorld"/>. Direction is controlled by this objects' <see cref="T:Rotation"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneDirectionalLight.SkyColor">
            <summary>
            Ambient light color outside of all light probes.
            </summary>
        </member>
        <member name="P:Sandbox.SceneDirectionalLight.ShadowCascadeCount">
            <summary>
            Control number of shadow cascades
            </summary>
        </member>
        <member name="M:Sandbox.SceneDirectionalLight.SetCascadeDistanceScale(System.Single)">
            <summary>
            Set the max distance of the shadow cascade
            </summary>
        </member>
        <member name="T:Sandbox.SceneFogVolume">
            <summary>
            Represents a volume of fog in a scene, contributing to volumetric fog effects set on <see cref="P:Sandbox.SceneCamera.VolumetricFog"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneFogVolume.Transform">
            <summary>
            The position and rotation of the fog volume in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.SceneFogVolume.BoundingBox">
            <summary>
            Defines the spatial boundaries of the fog volume.
            </summary>
        </member>
        <member name="P:Sandbox.SceneFogVolume.FogStrength">
            <summary>
            The intensity of the fog. Higher values indicate denser fog.
            </summary>
        </member>
        <member name="P:Sandbox.SceneFogVolume.FalloffExponent">
            <summary>
            Controls how quickly the fog fades at the edges of the volume. Higher values give sharper transitions.
            </summary>
        </member>
        <member name="M:Sandbox.SceneFogVolume.Delete">
            <summary>
            Delete this fog volume. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="T:Sandbox.SceneLight">
            <summary>
            Generic point light scene object for use with a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.LightColor">
            <summary>
            Color and brightness of the light
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.Radius">
            <summary>
            Radius of the light in units
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.ConstantAttenuation">
            <summary>
            The light attenuation constant term
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.LinearAttenuation">
            <summary>
            The light attenuation linear term
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.QuadraticAttenuation">
            <summary>
            The light attenuation quadratic term
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.ShadowTextureResolution">
            <summary>
            Get or set the resolution of the shadow map. If this is zero the engine will decide what it should use.
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.ShadowsEnabled">
            <summary>
            Enable or disable shadow rendering
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.LightCookie">
            <summary>
            Access the LightCookie - which is a texture that gets drawn over the light
            </summary>
        </member>
        <member name="T:Sandbox.SceneLightProbe">
            <summary>
            Keep this internal for now
            </summary>
        </member>
        <member name="T:Sandbox.SceneLineObject">
            <summary>
            A scene object which is used to draw lines
            </summary>
        </member>
        <member name="P:Sandbox.SceneLineObject.TessellationLevel">
            <summary>
            Number of tessellation subdivisions across the width of each line segment.
            1 = no tessellation (just left and right), 2 = one subdivision in the middle, etc.
            Higher values create smoother curves and more detailed geometry but use more vertices.
            </summary>
        </member>
        <member name="M:Sandbox.SceneLineObject.GetCapVertexCount(Sandbox.SceneLineObject.CapStyle)">
            <summary>
            Calculate the number of vertices needed for a specific cap type
            </summary>
        </member>
        <member name="M:Sandbox.SceneLineObject.GetCapIndexCount(Sandbox.SceneLineObject.CapStyle)">
            <summary>
            Calculate the number of indices needed for a specific cap type
            </summary>
        </member>
        <member name="P:Sandbox.SceneLoadOptions.IsSystemScene">
            <summary>
            Internal property to mark this scene as being a system scene. It should only be set in
            <see cref="M:Sandbox.Scene.AddSystemScene"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneLoadOptions.DeleteEverything">
            <summary>
            If true, on load we'll even delete objects that are marked as DontDelete
            </summary>
        </member>
        <member name="T:Sandbox.SceneMap">
            <summary>
            Map geometry that can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.World">
            <summary>
            The scene world this map belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.IsValid">
            <summary>
            Is the map valid.
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.Bounds">
            <summary>
            Bounds of the map.
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.MapName">
            <summary>
            cs_assault
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.MapFolder">
            <summary>
            maps/davej/cs_assault
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.#ctor(Sandbox.SceneWorld,System.String)">
            <summary>
            Create a scene map within a scene world.
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.#ctor(Sandbox.SceneWorld,System.String,Sandbox.MapLoader)">
            <summary>
            Create a scene map within a scene world.
            </summary>
        </member>
        <member name="F:Sandbox.SceneMap.OnMapUpdated">
            <summary>
            Invoked when a map file is updated (re-compiled in Hammer.)
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.CreateAsync(Sandbox.SceneWorld,System.String,System.Threading.CancellationToken)">
            <summary>
            Create scene map asynchronously for when large maps take time to load.
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.CreateAsync(Sandbox.SceneWorld,System.String,Sandbox.MapLoader,System.Threading.CancellationToken)">
            <summary>
            Create scene map asynchronously for when large maps take time to load.
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.Delete">
            <summary>
            Delete this scene map. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="T:Sandbox.SceneModel">
            <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
            <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
            <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
            <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneVelocity(System.Int32,Vector3@,Vector3@)">
            <summary>
            Calculate velocity from previous and current bone transform 
            (I want to expose this public but want to make sure the math is correct first)
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimGraph(System.String)">
            <summary>
            Override the anim graph this scene model uses
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetBoneWorldTransform(System.Int32,Transform)">
            <summary>
            Sets the world space bone transform of a bone by its index.
            </summary>
            <param name="boneIndex">Bone index to set transform of.</param>
            <param name="transform"></param>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneWorldTransform(System.Int32)">
            <summary>
            Returns the world space transform of a bone by its index.
            </summary>
            <param name="boneIndex">Index of the bone to calculate transform of.</param>
            <returns>The world space transform, or an identity transform on failure.</returns>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneWorldTransform(System.String)">
            <summary>
            Returns the world space transform of a bone by its name.
            </summary>
            <param name="boneName">Name of the bone to calculate transform of.</param>
            <returns>The world space transform, or an identity transform on failure.</returns>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneLocalTransform(System.Int32)">
            <summary>
            Returns the local space transform of a bone by its index.
            </summary>
            <param name="boneIndex">Index of the bone to calculate transform of.</param>
            <returns>The local space transform, or an identity transform on failure.</returns>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneLocalTransform(System.String)">
            <summary>
            Returns the local space transform of a bone by its name.
            </summary>
            <param name="boneName">Name of the bone to calculate transform of.</param>
            <returns>The local space transform, or an identity transform on failure.</returns>
        </member>
        <member name="M:Sandbox.SceneModel.SetMaterialGroup(System.String)">
            <summary>
            Set material group to replace materials of the model as set up in ModelDoc.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetBodyGroup(System.String,System.Int32)">
            <summary>
            Set which body group to use.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetAttachment(System.String,System.Boolean)">
            <summary>
            Get attachment transform by name.
            </summary>
            <param name="name">Name of the attachment to calculate transform of.</param>
            <param name="worldspace">Whether the transform should be in world space (relative to the scene world), or local space (relative to the scene object)</param>
            <returns></returns>
        </member>
        <member name="P:Sandbox.SceneModel.UseAnimGraph">
            <summary>
            Allows the scene model to not use the anim graph so it can play sequences directly
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.RootMotion">
            <summary>
            Get the calculated motion from animgraph since last frame
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.CurrentSequence">
            <summary>
            Allows playback of sequences directly, rather than using an animation graph.
            Requires <see cref="P:Sandbox.SceneModel.UseAnimGraph"/> disabled if the scene model has one.
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.Morphs">
            <summary>
            Access this sceneobject's morph collection. Morphs are generally used in the model to control
            the face, for things like emotions and lip sync.
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.DirectPlayback">
            <summary>
            Access this sceneobject's direct playback. Direct playback is used to control the direct playback node in an animgraph
            to play sequences directly in code
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.OnFootstepEvent">
            <summary>
            Called when a footstep event happens
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.OnGenericEvent">
            <summary>
            Called when a generic event happens
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.OnSoundEvent">
            <summary>
            Called when a sound event happens
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.OnAnimTagEvent">
            <summary>
            Called when a anim tag event happens
            </summary>
        </member>
        <member name="T:Sandbox.SceneModel.AnimTagStatus">
            <summary>
            Enumeration that describes how the AnimGraph tag state changed. Used in <see cref="T:Sandbox.SceneModel.AnimTagEvent"/>.
            </summary>
        </member>
        <member name="F:Sandbox.SceneModel.AnimTagStatus.Fired">
            <summary>
            Tag was activated and deactivated on the same frame
            </summary>
        </member>
        <member name="F:Sandbox.SceneModel.AnimTagStatus.Start">
            <summary>
            The tag has become active
            </summary>
        </member>
        <member name="F:Sandbox.SceneModel.AnimTagStatus.End">
            <summary>
            The tag has become inactive
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,System.Boolean)">
            <summary>
            Sets a boolean animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,System.Single)">
            <summary>
            Sets a float animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,Vector3)">
            <summary>
            Sets a vector animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,System.Int32)">
            <summary>
            Sets a integer animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,Rotation)">
            <summary>
            Sets a rotation animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.ResetAnimParameters">
            <summary>
            Reset all animgraph parameters to their default values.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetRotation(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetVector3(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetBool(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetFloat(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetInt(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.Update(System.Single)">
            <summary>
            Update this animation. Delta is the time you want to advance, usually RealTime.Delta
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.Update(System.Single,System.Action)">
            <summary>
            Update this animation. Delta is the time you want to advance, usually RealTime.Delta
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.UpdateToBindPose">
            <summary>
            Update all of the bones to the bind pose
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.UpdateToBindPose(System.Action)">
            <summary>
            Update all of the bones to the bind pose
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.FinishBoneUpdate">
            <summary>
            Updates attachments, ao proxies etc
            Should be called any time the world transform change
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.MergeBones(Sandbox.SceneModel)">
            <summary>
            Update our bones to match the target's bones. This is a manual bone merge.
            </summary>
        </member>
        <member name="T:Sandbox.SceneObject">
            <summary>
            A model scene object that can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.World">
            <summary>
            The scene world this object belongs to.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.Delete">
            <summary>
            Delete this scene object. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Transform">
            <summary>
            Transform of this scene object, relative to its <see cref="P:Sandbox.SceneObject.Parent"/>, or <see cref="T:Sandbox.SceneWorld"/> if parent is not set.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Rotation">
            <summary>
            Rotation of this scene object, relative to its <see cref="P:Sandbox.SceneObject.Parent"/>, or <see cref="T:Sandbox.SceneWorld"/> if parent is not set.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Position">
            <summary>
            Position of this scene object, relative to its <see cref="P:Sandbox.SceneObject.Parent"/>, or <see cref="T:Sandbox.SceneWorld"/> if parent is not set.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Bounds">
            <summary>
            Set or get the axis aligned bounding box for this object.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.LocalBounds">
            <summary>
            Set the axis aligned bounding box by transforming by this objects transform.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.RenderingEnabled">
            <summary>
            Whether this scene object should render or not.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.ColorTint">
            <summary>
            Color tint of this scene object.
            </summary>
        </member>
        <member name="F:Sandbox.SceneObject.ClipPlane">
            <summary>
            Clipping plane for this scene object. Requires <see cref="F:Sandbox.SceneObject.ClipPlaneEnabled"/> to be <c>true</c>.
            </summary>
        </member>
        <member name="F:Sandbox.SceneObject.ClipPlaneEnabled">
            <summary>
            Whether or not to use the clipping plane defined in <see cref="F:Sandbox.SceneObject.ClipPlane"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Parent">
            <summary>
            Movement parent of this scene object, if any.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.AddChild(System.String,Sandbox.SceneObject)">
            <summary>
            Add a named child scene object to this one. The child scene object will have its parent set.
            </summary>
            <remarks>
            The name can be used to look up children by name, but it is not bound. (SceneObject_FindChild)
            </remarks>
        </member>
        <member name="M:Sandbox.SceneObject.RemoveChild(Sandbox.SceneObject)">
            <summary>
            Unlink given scene object as a child from this one. The child scene object will have its parent set to null. It will not be deleted.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Model">
            <summary>
            The model this scene object will render.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.MeshGroupMask">
            <summary>
            State of all bodygroups of this object's model. You might be looking for <see cref="M:Sandbox.SceneModel.SetBodyGroup(System.String,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.LodOverride">
            <summary>
            Override current LOD level, -1 to disable.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.SetMaterialOverride(Sandbox.Material)">
            <summary>
            Override all materials on this object's <see cref="P:Sandbox.SceneObject.Model"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.ClearMaterialOverride">
            <summary>
            Clear all material replacements.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.SetMaterialOverride(Sandbox.Material,System.String,System.Int32)">
             <summary>
             Replaces all materials of the model that have the given <b>User Material Attribute</b> set to <b>"1"</b>, with given material.
            
             <para>The system checks both the models' default material group materials and the materials of the active material group.</para>
             </summary>
             <param name="material">Material to replace with.</param>
             <param name="attributeName">Name of the <b>User Material Attribute</b> to test on each material of the model. They are set in the Material Editor's <b>Attributes</b> tab.</param>
             <param name="attributeValue">Value of the attribute to test for.</param>
        </member>
        <member name="M:Sandbox.SceneObject.SetMaterialGroup(System.String)">
            <summary>
            Set material group to replace materials of the model as set up in ModelDoc.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Batchable">
            <summary>
            This object is not batchable by material for some reason ( example: has dynamic attributes that affect rendering )
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.GameObject">
            <summary>
            For storing and retrieving the GameObject this SceneObject belongs to
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Component">
            <summary>
            The component that created this object
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.UpdateFlagsBasedOnMaterial">
            <summary>
            Updates flags like transparent/opaque based on object's material, this is usually called automatically.
            But some procedural workflows (mesh editor) may want to call this manually.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Flags">
            <summary>
            Access to various advanced scene object flags.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.CastShadows">
            <summary>
            Whether this scene object should cast shadows.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.ExcludeGameLayer">
            <summary>
            Don't render in the opaque/translucent game passes. This is useful when you
            want to only render in the Bloom layer, rather than additionally to it.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.NeedsEnvironmentMap">
            <summary>
            True if this object needs cubemap information
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.WantsFrameBufferCopy">
            <summary>
            Automatically sets the "FrameBufferCopyTexture" attribute within the material.
            This does the same thing as Render.CopyFrameBuffer(); except automatically if
            the pass allows for it.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.IncludeInCubemap">
            <summary>
            Draw this in cubemaps
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.RenderLayer">
            <summary>
            For a layer to draw this object, the target layer must match (or be unset)
            and the flags must match
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Tags">
            <summary>
            List of tags for this scene object.
            </summary>
        </member>
        <member name="T:Sandbox.SceneRenderLayer">
            <summary>
            SceneObjects can be rendered on layers other than the main game layer.
            This is useful if, for example, you want to render on top of everything without
            applying post processing.
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayer.Default">
            <summary>
            Draw wherever makes sense based on the flags, default behaviour
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayer.ViewModel">
            <summary>
            Layer drawn on top of everything else - with altered depth
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayer.OverlayWithDepth">
            <summary>
            Overlay - after post processing - but still with the scene's depth
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayer.OverlayWithoutDepth">
            <summary>
            Overlay - after post processing - without depth (draw over)
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayerHelper.Names">
            <summary>
            Internally we don't pass these enums, they're just string tokens.
            No need to expose the actual string tokens to people unless we expose the render pipeline fully to them.
            </summary>
        </member>
        <member name="T:Sandbox.SceneOrthoLight">
            <summary>
            Keep this internal for now
            </summary>
        </member>
        <member name="T:Sandbox.SceneParticles">
            <summary>
            A SceneObject used to render particles.
            We need to be careful with what we do here, because this object is created for in-engine particles
            as well as custom scene object particles.
            With custom particles there's no automatic Simulate, or deletion.. You're completely on your own. This
            is perhaps a good thing though, it's maybe what you want to happen. To be completely isolated and completely
            in control. But at the same time maybe it's not and it's something we need to sort out.
            </summary>
        </member>
        <member name="M:Sandbox.SceneParticles.#ctor(Sandbox.SceneWorld,System.String)">
            <summary>
            Create scene particles.
            </summary>
            <param name="world">The scene world to create the particles in.</param>
            <param name="particleSystem">Path to the particle system file.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.#ctor(Sandbox.SceneWorld,Sandbox.ParticleSystem)">
            <summary>
            Create scene particles.
            </summary>
            <param name="world">The scene world to create the particles in.</param>
            <param name="particleSystem">Particle system resource.</param>
        </member>
        <member name="P:Sandbox.SceneParticles.RenderParticles">
            <summary>
            Whether to render the particles or not.
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.EmissionStopped">
            <summary>
            Stop (or start) the particle system emission.
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.PhysicsWorld">
            <summary>
            Particle collisions use this physics world to perform traces.
            </summary>
        </member>
        <member name="M:Sandbox.SceneParticles.IsControlPointSet(System.Int32)">
            <summary>
            Whether given control point has any data set.
            </summary>
            <param name="index">The control point index. Range is 0-63.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.GetControlPointPosition(System.Int32)">
            <summary>
            Returns the position set on a given control point.
            </summary>
            <param name="index">The control point index. Range is 0-63.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Vector3)">
            <summary>
            Set position on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="position">The position to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Rotation)">
            <summary>
            Set rotation on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="rotation">The rotation to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Transform)">
            <summary>
            Set transform on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="transform">The transform to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Sandbox.ParticleSnapshot)">
            <summary>
            Set snapshot on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="snapshot">The snapshot to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Sandbox.Model)">
            <summary>
            Set model on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="model">The model to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetNamedValue(System.String,Vector3)">
            <summary>
            Set vector on given named value.
            </summary>
            <param name="name">The name of the key.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.Simulate(System.Single)">
            <summary>
            Simulate the particles for given amount of time.
            </summary>
            <param name="f">Amount of time has passed since last simulation.</param>
        </member>
        <member name="P:Sandbox.SceneParticles.ActiveParticlesSelf">
            <summary>
            The amount of particles 
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.ActiveParticlesTotal">
            <summary>
            The amount of particles including child systems
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.MaximumParticles">
            <summary>
            The total allowed particle count
            </summary>
        </member>
        <member name="M:Sandbox.SceneParticles.Emit(System.Int32)">
            <summary>
            Manually emit a bunch of particles
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.Finished">
            <summary>
            True if particle system has reached the end
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.SimulationTime">
            <summary>
            Get or set the simulation time
            </summary>
        </member>
        <member name="T:Sandbox.SceneSkyBox">
            <summary>
            Renders a skybox within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSkyBox.SkyMaterial">
            <summary>
            The skybox material. Typically it should use the "Sky" shader.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSkyBox.SkyTint">
            <summary>
            Skybox color tint.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSkyBox.FogParams">
            <summary>
            Controls the skybox specific fog.
            </summary>
        </member>
        <member name="M:Sandbox.SceneSkybox3D.Delete">
            <summary>
            Delete this fog volume. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="T:Sandbox.SceneSpotLight">
            <summary>
            A simple spot light scene object for use in a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSpotLight.ConeInner">
            <summary>
            The inner cone of the spotlight, in half angle degrees.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSpotLight.ConeOuter">
            <summary>
            The outer cone of the spotlight, in half angle degrees
            </summary>
        </member>
        <member name="T:Sandbox.SceneTrailObject">
            <summary>
            I don't want to expose SceneObjects to people anymore. They should be using the scene system.
            It's better if we can keep things internal so we don't have the burden of supporting api layout.
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrailObject.MaxPoints">
            <summary>
            Total maximum points we're allowing
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrailObject.PointDistance">
            <summary>
            Wait until we're this far away before adding a new point
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrailObject.Texturing">
            <summary>
            Texture details, in a nice stuct to hide the bs
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrailObject.LifeTime">
            <summary>
            How long the trail lasts - or 0 for infinite
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrailObject.TryAddPosition(Vector3)">
            <summary>
            Try to add a position to this trail. Returns true on success.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrailObject.TryAddPosition(Vector3,Vector3)">
            <summary>
            Try to add a position to this trail. Returns true on success.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrailObject.AdvanceTime(System.Single)">
            <summary>
            Advance the time for this trail. Will fade out points and scoll the texture.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrailObject.Build">
            <summary>
            Build the vertices for this object.
            TODO: We can move this to build automatically in a thread
            </summary>
        </member>
        <member name="T:Sandbox.TrailTextureConfig">
            <summary>
            Defines how a trail is going to be textured. Used by TrailRenderer.
            </summary>
        </member>
        <member name="P:Sandbox.TrailTextureConfig.Clamp">
            <summary>
            If true the texture will be clamped instead of repeating
            </summary>
        </member>
        <member name="T:Sandbox.SceneWorld">
             <summary>
             A scene world that contains <see cref="T:Sandbox.SceneObject"/>s. See <a href="https://sbox.game/api/Tools.Utility.CreateSceneWorld()">Utility.CreateSceneWorld</a>.
            
             <para>You may also want a <see cref="T:Sandbox.SceneCamera"/> to manually render the scene world.</para>
             </summary>
        </member>
        <member name="P:Sandbox.SceneWorld.SceneObjects">
            <summary>
            List of scene objects belonging to this scene world.
            </summary>
        </member>
        <member name="F:Sandbox.SceneWorld.GradientFog">
            <summary>
            Controls gradient fog settings.
            </summary>
        </member>
        <member name="F:Sandbox.SceneWorld.AmbientLightColor">
            <summary>
            Sets the ambient lighting color
            </summary>
        </member>
        <member name="F:Sandbox.SceneWorld.ClearColor">
            <summary>
            Sets the clear color, if nothing else is drawn, this is the color you will see
            </summary>
        </member>
        <member name="P:Sandbox.SceneWorld.IsTransient">
            <summary>
            If a world is transient, it means it was created by game code, and should
            be deleted at the end of the game session. If they're non transient then
            they were created in the menu, or by the engine code and will be released
            properly by that code.
            </summary>
        </member>
        <member name="M:Sandbox.SceneWorld.Delete">
            <summary>
            Delete this scene world. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="M:Sandbox.SceneWorld.DeletePendingObjects">
            <summary>
            Deleted objects are actually deleted at the end of each frame. Call this
            to actually delete pending deletes right now instead of waiting. 
            </summary>
        </member>
        <member name="M:Sandbox.SceneWorld.UpdateObjectsForRendering(Vector3,System.Single)">
            <summary>
            This finishes any loads and actually spawns the world sceneobjects
            </summary>
        </member>
        <member name="M:Sandbox.SceneWorld.AddSceneMap(Sandbox.SceneMap)">
            <summary>
            Add a scenemap to this world
            </summary>
        </member>
        <member name="P:Sandbox.SceneWorld.Trace">
            <summary>
            Trace against all scene objects in this scene world
            </summary>
        </member>
        <member name="F:Sandbox.StereoTargetEye.None">
            <summary>
            Don't render in stereo
            </summary>
        </member>
        <member name="F:Sandbox.StereoTargetEye.LeftEye">
            <summary>
            Only render the left eye
            </summary>
        </member>
        <member name="F:Sandbox.StereoTargetEye.RightEye">
            <summary>
            Only render the right eye
            </summary>
        </member>
        <member name="F:Sandbox.StereoTargetEye.Both">
            <summary>
            Render both eyes in stereo
            </summary>
        </member>
        <member name="P:Sandbox.Tasks.ExpirableSynchronizationContext.HasExpired">
            <summary>
            When true, any continuations that attempt to run on this instance will
            log an exception, unless whitelisted by <see cref="M:Sandbox.Tasks.ExpirableSynchronizationContext.AllowPersistentTaskMethods(System.Reflection.Assembly)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.ExpirableSynchronizationContext.#ctor(System.Boolean)">
            <param name="warnNonYieldingTasks">If true, warn when tasks don't yield after <see cref="F:Sandbox.Tasks.ExpirableSynchronizationContext.MaxTimeBetweenYieldsMillis"/>.</param>
        </member>
        <member name="M:Sandbox.Tasks.ExpirableSynchronizationContext.WatchDogAsync">
            <summary>
            Logs a warning if any actions posted to this sync context take
            too long before returning.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.ExpirableSynchronizationContext.CheckValid(System.Object,System.Boolean@)">
            <summary>
            Returns true if <see cref="P:Sandbox.Tasks.ExpirableSynchronizationContext.HasExpired"/> is false, or if <paramref name="state"/> represents
            a task method that is allowed to persist after context expiry. Logs an error otherwise.
            </summary>
        </member>
        <member name="P:Sandbox.Tasks.SyncContext.MainThread">
            <summary>
            Current sync context for the main thread. This will be null until <see cref="M:Sandbox.Tasks.SyncContext.Init"/> has been
            called for the first time.
            </summary>
        </member>
        <member name="P:Sandbox.Tasks.SyncContext.WorkerThread">
            <summary>
            Current sync context for worker threads. This will be null until <see cref="M:Sandbox.Tasks.SyncContext.Init"/> has been
            called for the first time.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.SyncContext.Init">
            <summary>
            Sets both <see cref="P:Sandbox.Tasks.SyncContext.MainThread"/> and <see cref="P:System.Threading.SynchronizationContext.Current"/> to be a new
            instance of <see cref="T:Sandbox.Tasks.ExpirableSynchronizationContext"/>. Only has an effect the first time it's called.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.SyncContext.Reset">
            <summary>
            Invalidates <see cref="P:Sandbox.Tasks.SyncContext.MainThread"/> and <see cref="P:Sandbox.Tasks.SyncContext.WorkerThread"/>, and replaces
            them with a new instance.
            Any tasks that try to continue on the old instances will log an error, unless they
            are whitelisted with <see cref="M:Sandbox.Tasks.ExpirableSynchronizationContext.AllowPersistentTaskMethods(System.Reflection.Assembly)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.SyncContext.RunBlocking(System.Threading.Tasks.Task)">
            <summary>
            Run an async task in a synchronous blocking manner.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.SyncContext.RunBlocking``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Run an async task in a synchronous blocking manner and returns the result.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.SyncContext.Scope(System.Threading.SynchronizationContext)">
            <summary>
            Create a scope that sets the current synchronization context to the provided context.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.WorkerThread.Start">
            <summary>
            Starts a bunch of long-running tasks in the worker thread pool that
            keep calling <see cref="M:Sandbox.Tasks.ExpirableSynchronizationContext.ProcessQueue"/> on
            <see cref="P:Sandbox.Tasks.SyncContext.WorkerThread"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if tasks are already running.</exception>
        </member>
        <member name="M:Sandbox.Tasks.WorkerThread.Stop(System.Int32)">
            <summary>
            Forces the tasks created by <see cref="M:Sandbox.Tasks.WorkerThread.Start"/> to cancel, to be restarted later.
            This doesn't cancel tasks created with Sandbox.TaskSource.RunInThreadAsync, they
            just get suspended until <see cref="M:Sandbox.Tasks.WorkerThread.Start"/> is called again.
            </summary>
            <param name="millisecondsTimeout">
            Log an error if any tasks take longer than this to return.
            </param>
        </member>
        <member name="T:Sandbox.MainThread">
            <summary>
            Utility functions that revolve around the main thread
            </summary>
        </member>
        <member name="M:Sandbox.MainThread.Wait">
            <summary>
            Wait to execute on the main thread
            </summary>
        </member>
        <member name="M:Sandbox.MainThread.Run``1(System.Int32,System.Func{``0})">
            <summary>
            Run a function on the main thread and wait for the result.
            </summary>
        </member>
        <member name="M:Sandbox.MainThread.Queue(System.Action)">
            <summary>
            When running in another thread you can queue a method to run in the main thread.
            If you are on the main thread we will execute the method immediately and return.
            </summary>
        </member>
        <member name="M:Sandbox.MainThread.RunMainThreadQueues">
            <summary>
            Run queued actions on the main thread
            </summary>
        </member>
        <member name="T:Sandbox.GameTask">
            <summary>
            A generic <see cref="T:Sandbox.TaskSource"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameTask.Yield">
            <inheritdoc cref="M:Sandbox.TaskSource.Yield"/>
        </member>
        <member name="M:Sandbox.GameTask.Delay(System.Int32)">
            <inheritdoc cref="M:Sandbox.TaskSource.Delay(System.Int32)"/>
        </member>
        <member name="M:Sandbox.GameTask.Delay(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.Delay(System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelaySeconds(System.Single)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelaySeconds(System.Single)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelaySeconds(System.Single,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelaySeconds(System.Single,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelayRealtime(System.Int32)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtime(System.Int32)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelayRealtime(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtime(System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelayRealtimeSeconds(System.Single)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtimeSeconds(System.Single)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelayRealtimeSeconds(System.Single,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtimeSeconds(System.Single,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sandbox.GameTask.RunInThreadAsync(System.Action)">
            <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync(System.Action)"/>
        </member>
        <member name="M:Sandbox.GameTask.RunInThreadAsync``1(System.Func{``0})">
            <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync``1(System.Func{``0})"/>
        </member>
        <member name="M:Sandbox.GameTask.RunInThreadAsync(System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync(System.Func{System.Threading.Tasks.Task})"/>
        </member>
        <member name="M:Sandbox.GameTask.RunInThreadAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync``1(System.Func{System.Threading.Tasks.Task{``0}})"/>
        </member>
        <member name="P:Sandbox.GameTask.CompletedTask">
            <inheritdoc cref="P:Sandbox.TaskSource.CompletedTask"/>
        </member>
        <member name="M:Sandbox.GameTask.FromResult``1(``0)">
            <inheritdoc cref="M:Sandbox.TaskSource.FromResult``1(``0)"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAll(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAll(System.Threading.Tasks.Task[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAll``1(System.Threading.Tasks.Task{``0}[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAny(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAny(System.Threading.Tasks.Task[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAny``1(System.Threading.Tasks.Task{``0}[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})"/>
        </member>
        <member name="M:Sandbox.GameTask.WaitAll(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WaitAll(System.Threading.Tasks.Task[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WaitAny(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WaitAny(System.Threading.Tasks.Task[])"/>
        </member>
        <member name="M:Sandbox.GameTask.MainThread">
            <inheritdoc cref="M:Sandbox.TaskSource.MainThread"/>
        </member>
        <member name="M:Sandbox.GameTask.MainThread(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.MainThread"/>
        </member>
        <member name="M:Sandbox.GameTask.WorkerThread">
            <inheritdoc cref="M:Sandbox.TaskSource.WorkerThread"/>
        </member>
        <member name="M:Sandbox.GameTask.WorkerThread(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.WorkerThread"/>
        </member>
        <member name="T:Sandbox.TaskSource">
            <summary>
            Provides a way for us to cancel tasks after common async shit is executed.
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.CreateLinkedTokenSource">
            <summary>
            Create a token source, which will also be cancelled when sessions end
            </summary>
        </member>
        <member name="P:Sandbox.TaskSource.IsValid">
            <inheritdoc cref="P:Sandbox.IValid.IsValid"/>
        </member>
        <member name="M:Sandbox.TaskSource.Expire">
            <summary>
            Marks this task source as invalid. All associated running tasks will be canceled ASAP.
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.Delay(System.Int32)">
            <summary>
            A task that does nothing for given amount of time in milliseconds.
            </summary>
            <param name="ms">Time to wait in milliseconds.</param>
        </member>
        <member name="M:Sandbox.TaskSource.Delay(System.Int32,System.Threading.CancellationToken)">
            <summary>
            A task that does nothing for given amount of time in milliseconds.
            </summary>
            <param name="ms">Time to wait in milliseconds.</param>
            <param name="ct">Token to cancel the delay early.</param>
        </member>
        <member name="M:Sandbox.TaskSource.DelaySeconds(System.Single)">
            <summary>
            A task that does nothing for given amount of time in seconds.
            </summary>
            <param name="seconds">>Time to wait in seconds.</param>
        </member>
        <member name="M:Sandbox.TaskSource.DelaySeconds(System.Single,System.Threading.CancellationToken)">
            <summary>
            A task that does nothing for given amount of time in seconds.
            </summary>
            <param name="seconds">>Time to wait in seconds.</param>
            <param name="ct">Token to cancel the delay early.</param>
        </member>
        <member name="M:Sandbox.TaskSource.MainThread">
            <summary>
            Continues on the main thread.
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.WorkerThread">
            <summary>
            Continues on a worker thread.
            </summary>
        </member>
        <member name="P:Sandbox.TaskSource.CompletedTask">
            <inheritdoc cref="P:System.Threading.Tasks.Task.CompletedTask" />
        </member>
        <member name="M:Sandbox.TaskSource.FromResult``1(``0)">
            <inheritdoc cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
        </member>
        <member name="M:Sandbox.TaskSource.FromCanceled(System.Threading.CancellationToken)">
            <inheritdoc cref="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
        </member>
        <member name="M:Sandbox.TaskSource.FromException(System.Exception)">
            <inheritdoc cref="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAll(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAny(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
        </member>
        <member name="M:Sandbox.TaskSource.WaitAny(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WaitAll(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
        </member>
        <member name="M:Sandbox.TaskSource.Yield">
            <inheritdoc cref="M:System.Threading.Tasks.Task.Yield" />
        </member>
        <member name="M:Sandbox.TaskSource.Frame">
            <summary>
            Wait until the start of the next frame
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.FrameEnd">
            <summary>
            Wait until the end of the frame
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.FixedUpdate">
            <summary>
            Wait until the next fixed update
            </summary>
        </member>
        <member name="T:Sandbox.UI.KeyFrames">
            <summary>
            Represents a CSS <c>@keyframes</c> rule.
            </summary>
        </member>
        <member name="P:Sandbox.UI.KeyFrames.Name">
            <summary>
            Name of the <c>@keyframes</c> rule.
            </summary>
        </member>
        <member name="T:Sandbox.UI.KeyFrames.Block">
            <summary>
            A keyframe within the animation.
            </summary>
        </member>
        <member name="P:Sandbox.UI.KeyFrames.Block.Interval">
            <summary>
            The position of the keyframe within the overall animation. 0 to 1, where 0 is the start, and 1 is the end of the animation.
            </summary>
        </member>
        <member name="P:Sandbox.UI.KeyFrames.Block.Styles">
            <summary>
            The styles that should be applied at this position in the animation.
            </summary>
        </member>
        <member name="F:Sandbox.UI.KeyFrames.Blocks">
            <summary>
            List of keyframes with in the <c>@keyframes</c> rule.
            </summary>
        </member>
        <member name="T:Sandbox.UI.BasePopup">
            <summary>
            A panel that gets deleted automatically when clicked away from
            </summary>
        </member>
        <member name="P:Sandbox.UI.BasePopup.StayOpen">
            <summary>
            Stay open, even when CloseAll popups is called
            </summary>
        </member>
        <member name="T:Sandbox.UI.Image">
            <summary>
            A generic box that displays a given texture within itself.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Image.Texture">
            <summary>
            The texture being displayed by this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Image.SetTexture(System.String)">
            <summary>
            Set <see cref="P:Sandbox.UI.Image.Texture"/> from a file path. URLs supported.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Construct.ImageConstructor.Image(Sandbox.UI.Construct.PanelCreator,System.String,System.String)">
            <summary>
            Create an image with given texture and CSS classname.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Construct.LabelConstructor.Label(Sandbox.UI.Construct.PanelCreator,System.String,System.String)">
            <summary>
            Create a simple text label with given text and CSS classname.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Construct.PanelCreator">
            <summary>
            Used for <see cref="P:Sandbox.UI.Panel.Add"/> for quick panel creation with certain settings. Other panels types are added via extension methods.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Construct.PanelCreator.panel">
            <summary>
            The panel to add children to.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Construct.PanelCreator.Panel">
            <summary>
            Add a new blank panel as a child.
            </summary>
            <returns>The crated panel.</returns>
        </member>
        <member name="M:Sandbox.UI.Construct.PanelCreator.Panel(System.String)">
            <summary>
            Add a new blank panel with given CSS classes as a child.
            </summary>
            <returns>The crated panel.</returns>
        </member>
        <member name="T:Sandbox.UI.Label">
            <summary>
            A generic text label. Can be made editable.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Label.StringInfo">
            <summary>
            Information about the <see cref="P:Sandbox.UI.Label.Text"/> on a per-element scale. It handles multi-character Unicode units (graphemes) correctly.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.Selectable">
            <summary>
            Can be selected
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.Text">
            <summary>
            Text to display on the label.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.IsRich">
            <summary>
            Set to true if this is rich text. This means it can support some inline html elements.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.CaretPosition">
            <summary>
            Position of the text cursor/caret within the text, at which newly typed characters are inserted.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.TextLength">
            <summary>
            Amount of characters in the text of the text entry. Not bytes.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.CaretSantity">
            <summary>
            Ensure the text caret and selection are in sane positions, that is, not outside of the text bounds.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.GetSelectedText">
            <summary>
            Returns the selected text.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.LanguageChanged">
            <summary>
            When the language changes, if we're token based we need to update to the new phrase.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.Multiline">
            <summary>
            Enables multi-line support for editing purposes.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.ReplaceSelection(System.String)">
            <summary>
            Replace the currently selected text with given text.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.SetSelection(System.Int32,System.Int32)">
            <summary>
            Sets the text selection.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.SetCaretPosition(System.Int32,System.Boolean)">
            <summary>
            Set the text caret position to the given index.
            </summary>
            <param name="pos">Where to move the text caret to within the text.</param>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.ScrollToCaret">
            <summary>
            Put the caret within the visible region.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.MoveToWordBoundaryLeft(System.Boolean)">
            <summary>
            Move the text caret to the closest word start or end to the left of current position.<br/>
            This simulates holding Control key while pressing left arrow key.
            </summary>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.MoveToWordBoundaryRight(System.Boolean)">
            <summary>
            Move the text caret to the closest word start or end to the right of current position.<br/>
            This simulates holding Control key while pressing right arrow key.
            </summary>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.MoveCaretPos(System.Int32,System.Boolean)">
            <summary>
            Move the text caret by given amount.
            </summary>
            <param name="delta">How many characters to the right to move. Negative values move left.</param>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.InsertText(System.String,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Insert given text at given position.
            </summary>
            <param name="text">Text to insert.</param>
            <param name="pos">Position to insert the text at.</param>
            <param name="endpos">If set, the end position in the current <see cref="P:Sandbox.UI.Label.Text"/>,
            which will be used to replace portion of the existing text with the given <paramref name="text"/>.</param>
        </member>
        <member name="M:Sandbox.UI.Label.RemoveText(System.Int32,System.Int32)">
            <summary>
            Remove given amount of characters from the label at given <paramref name="start"/> position.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.MoveToLineStart(System.Boolean)">
            <summary>
            Move the text caret to the start of the current line.
            </summary>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.MoveToLineEnd(System.Boolean)">
            <summary>
            Move the text caret to the end of the current line.
            </summary>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.MoveCaretLine(System.Int32,System.Boolean)">
            <summary>
            Move the text caret to next or previous line.
            </summary>
            <param name="offset_line">How many lines to offset. Negative values move up.</param>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.SelectWord(System.Int32)">
            <summary>
            Select a work at given word position.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.GetWordBoundaryIndices">
            <summary>
            Returns a list of positions in the text of each side of each word within the <see cref="P:Sandbox.UI.Label.Text"/>.<br/>
            This is used for Control + Arrow Key navigation.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.IsNewline(System.String)">
            <summary>
            Returns true if the input string is a 1 or 2 (\r\n) character newline symbol.
            </summary>
        </member>
        <member name="T:Sandbox.UI.ScenePanel">
            <summary>
            Allows to render a scene world onto a panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.World">
            <summary>
            Shortcut to Camera.World
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.Camera">
            <summary>
            The camera we're going to be using to render
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.RenderOnce">
            <summary>
            If enabled, the scene will only render once. That isn't totally accurate though, because we'll
            also re-render the scene when the size of the panel changes.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.RenderTexture">
            <summary>
            The texture that the panel is rendering to internally. This will change to a different
            texture if the panel changes size, so I wouldn't hold onto this object.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.RenderScene">
            <summary>
            The Scene this panel renders.
            </summary>
        </member>
        <member name="M:Sandbox.UI.ScenePanel.#ctor(System.String)">
            <summary>
            Creates and loads a Scene from a file to render to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.ScenePanel.RenderNextFrame">
            <summary>
            Render the panel again next frame. This is meant to be used with RenderOnce, where
            you might want to render on demand or only once.
            </summary>
        </member>
        <member name="T:Sandbox.UI.SvgPanel">
            <summary>
            A generic panel that draws an SVG scaled to size
            </summary>
        </member>
        <member name="P:Sandbox.UI.SvgPanel.Src">
            <summary>
            Content path to the SVG file
            </summary>
        </member>
        <member name="P:Sandbox.UI.SvgPanel.Color">
            <summary>
            Optional color to draw the SVG with
            </summary>
        </member>
        <member name="T:Sandbox.UI.WebPanel">
            <summary>
            A panel that displays an interactive web page.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WebPanel.Surface">
            <summary>
            Access to the HTML surface to change URL, etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.WebPanel.BrowserDataChanged(System.ReadOnlySpan{System.Byte},Vector2)">
            <summary>
            The texture has changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.LayoutCascade.ApplyCascading(Sandbox.UI.Styles)">
            <summary>
            Some properties cascade from their parent onto children if the children
            don't set them. Things like font size, color, cursor.
            </summary>
        </member>
        <member name="M:Sandbox.UI.TextBlock.Render(Sandbox.UI.PanelRenderer,Sandbox.UI.RenderState@,Sandbox.UI.Styles,Sandbox.Rect,System.Single)">
            <summary>
            Proper Rendering
            </summary>
        </member>
        <member name="M:Sandbox.UI.TextBlock.SizeFinalized(System.Single,System.Single)">
            <summary>
            Called on layout. We should decide here if we actually need to rebuild
            </summary>
        </member>
        <member name="M:Sandbox.UI.TextBlock.RebuildTexture(System.Single,System.Single)">
            <summary>
            Actually recreate the texture
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse0">
            <summary>
            Left Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse1">
            <summary>
            Muddle Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse2">
            <summary>
            Right Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse3">
            <summary>
            Back Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse4">
            <summary>
            Forward Button
            </summary>
        </member>
        <member name="T:Sandbox.UI.ButtonEvent">
            <summary>
            Keyboard (and mouse) key press <see cref="T:Sandbox.UI.PanelEvent"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.Button">
            <summary>
            The button that triggered the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.Pressed">
            <summary>
            Whether the button was pressed in, or release.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.KeyboardModifiers">
            <summary>
            The keyboard modifier keys that were held down at the moment the event triggered.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.HasShift">
            <summary>
            Whether <c>Shift</c> key was being held down at the time of the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.HasCtrl">
            <summary>
            Whether <c>Control</c> key was being held down at the time of the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.HasAlt">
            <summary>
            Whether <c>Alt</c> key was being held down at the time of the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.StopPropagation">
            <summary>
            Set to <see langword="true"/> to prevent the event from propagating to the parent panel.
            </summary>
        </member>
        <member name="T:Sandbox.UI.InputEventQueue">
            <summary>
            Queue input events on here to be processed by the UISystem.
            </summary>
        </member>
        <member name="T:Sandbox.UI.InputFocus">
            <summary>
            Handles input focus for <see cref="T:Sandbox.UI.Panel"/>s.
            </summary>
        </member>
        <member name="P:Sandbox.UI.InputFocus.Current">
            <summary>
            The panel that currently has input focus.
            </summary>
        </member>
        <member name="P:Sandbox.UI.InputFocus.Next">
            <summary>
            The panel that will have the input focus next.
            </summary>
        </member>
        <member name="M:Sandbox.UI.InputFocus.Set(Sandbox.UI.Panel)">
            <summary>
            Set the focus to this panel (or its nearest ancestor with AcceptsFocus).
            Note that <see cref="P:Sandbox.UI.InputFocus.Current"/> won't change until the next frame.
            </summary>
        </member>
        <member name="M:Sandbox.UI.InputFocus.Clear(Sandbox.UI.Panel)">
            <summary>
            Clear focus away from this panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelInput.Hovered">
            <summary>
            Panel we're currently hovered over
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelInput.Active">
            <summary>
            Panel we're currently pressing down
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelInput.AddMouseWheel(Vector2,Sandbox.KeyboardModifiers)">
            <summary>
            Called from input when mouse wheel changes
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelInput.AddMouseButton(NativeEngine.ButtonCode,System.Boolean,Sandbox.KeyboardModifiers)">
            <summary>
            Called from input when mouse wheel changes
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelInput.SetCursor(System.String)">
            <summary>
            The cursor should change. Name could be null, meaning default.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelInput.MouseButtonState.DragTarget">
            <summary>
            Then panel that is potentially being dragged
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelInput.MouseButtonState.StartHoldOffsetLocal">
            <summary>
            The point where we first pressed on the Active element
            </summary>
        </member>
        <member name="T:Sandbox.UI.WorldInput">
            <summary>
            WorldInput can be used to simulate standard mouse inputs on WorldPanels.
            </summary>
            <remarks>
            <para>
            You need to set <see cref="P:Sandbox.UI.WorldInput.Ray"/> and <see cref="P:Sandbox.UI.WorldInput.MouseLeftPressed"/> to simulate inputs,
            ideally this should be done in a BuildInput event.
            </para>
            </remarks>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Enabled">
            <summary>
            This input won't tick when this is false.
            Any hovered panels will be cleared.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Ray">
            <summary>
            The Ray used to intersect with your world panels, simulating mouse position.
            </summary>
            <remarks>
            This should ideally be set in BuildInput or FrameSimulate.
            </remarks>
        </member>
        <member name="P:Sandbox.UI.WorldInput.MouseWheel">
            <summary>
            Simulate the mouse scroll wheel.
            You could use <seealso cref="P:Sandbox.Input.MouseWheel"/>
            Or you could simulate it with the camera view delta for example.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.UseMouseInput">
            <summary>
            Instead of simulating mouse input, this will simply use the mouse input.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Hovered">
            <summary>
            The <see cref="T:Sandbox.UI.Panel"/> that is currently hovered by this input.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Active">
            <summary>
            The <see cref="T:Sandbox.UI.Panel"/> that is currently pressed by this input.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelInputType.UI">
            <summary>
            Regular expected behaviour.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelInputType.Game">
            <summary>
            Redirect to the game's Input system
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.activeRules">
            <summary>
            This could be a local variable if we wanted to create a new class every time
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.LastActiveRules">
            <summary>
            Store the last active rules so we can compare them when they change and trigger sounds etc on new styles
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.ActiveRulesGuid">
            <summary>
            Cache of the active rules that are applied, that way we can trigger stuff only if they actually changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelStyle.UnderlyingStyleHasChanged">
            <summary>
            Should be called when a stylesheet in our bundle has changed. This can happen as a result of
            editing it in the style editor.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.StyleBlocks">
            <summary>
            All these styles could possibly apply to us. To get this list we get the stylesheets from
            ourself and our anscestors and then filter them by the broadphase. The broadphase is a check
            against classes, element names and ids, things that don't change in a recursive way.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.broadPhaseHash">
            <summary>
            A hash of the things that are checked in the broadphase.
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelStyle.HasBeforeElement">
            <summary>
            This style has a ::before element available. This is signalling to the panel system that if we 
            apply this style, we should also create a ::before element.
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelStyle.HasAfterElement">
            <summary>
            This style has a ::after element available. This is signalling to the panel system that if we 
            apply this style, we should also create a ::after element.
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelStyle.InvalidateBroadphase">
            <summary>
            Called when a stylesheet has been added or removed from ourselves or one of
            our ancestor panels - because under that condition we need to rebuild our
            broadphase.
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelStyle.BuildRulesInThread">
            <summary>
            Called from the root panel in a thread. We replace activeRules with all of the rules that
            we want applied and return true if the rules changed.
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelStyle.ContainsStyle(Sandbox.UI.Styles)">
            <summary>
            Returns true if we have the style
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.MouseDelta">
            <summary>
            For ondrag event - the delta of the mouse movement
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.LocalGrabPosition">
            <summary>
            The position on the Target panel where the drag started
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.ScreenGrabPosition">
            <summary>
            The position relative to the screen where the drag started
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.LocalPosition">
            <summary>
            The current mouse position relative to target
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.ScreenPosition">
            <summary>
            The current position relative to the screen
            </summary>
        </member>
        <member name="T:Sandbox.UI.MousePanelEvent">
            <summary>
            Mouse related <see cref="T:Sandbox.UI.PanelEvent"/>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.MousePanelEvent.LocalPosition">
            <summary>
            Position of the cursor relative to the panel's top left corner at the time the event was triggered.
            </summary>
        </member>
        <member name="F:Sandbox.UI.MousePanelEvent.Button">
            <summary>
            Which button triggered the event, in string form.
            </summary>
        </member>
        <member name="P:Sandbox.UI.MousePanelEvent.MouseButton">
            <summary>
            Which button triggered the event, as a <see cref="T:Sandbox.MouseButtons"/> enum.
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelEvent">
            <summary>
            Base <see cref="T:Sandbox.UI.Panel"/> event.<br/>
            See <see cref="M:Sandbox.UI.Panel.CreateEvent(Sandbox.UI.PanelEvent)"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelEvent.This">
            <summary>
            The panel on which the event is being called. For example, if you have a button with a label.. when the
            button gets clicked the actual click event might come from the label. When the event is called on the
            label, This will be the label. When the event propagates up to the button This will be the button - but
            Target will be the label. This is mainly of use with Razor callbacks, where you want to get the actual
            panel that created the event.
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelEventAttribute">
            <summary>
            Add an event listener to a <see cref="T:Sandbox.UI.Panel"/> event with the given name.<br/>
            See <see cref="M:Sandbox.UI.Panel.CreateEvent(System.String,System.Object,System.Nullable{System.Single})"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelEventAttribute.Name">
            <summary>
            Name of the event to listen to.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Panel">
            <summary>
            A simple User Interface panel. Can be styled with <a href="https://en.wikipedia.org/wiki/CSS">CSS</a>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel._beforeElement">
            <summary>
            if we have a ::before element, this is it.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel._afterElement">
            <summary>
            if we have a ::after element, this is it.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.UpdateBeforeAfterElements">
            <summary>
            Called during tick to create or destroy the ::before and ::after elements.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.BuildPseudoElement(System.Boolean,Sandbox.UI.PseudoClass,Sandbox.UI.Panel@)">
            <summary>
            Called to update the state of a before or after element. Either destroying it or creating it.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Add">
            <summary>
            Quickly add common panels with certain values as children.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel._children">
            <inheritdoc cref="P:Sandbox.UI.Panel.Children"/>
        </member>
        <member name="F:Sandbox.UI.Panel._parent">
            <inheritdoc cref="P:Sandbox.UI.Panel.Parent"/>
        </member>
        <member name="P:Sandbox.UI.Panel.Children">
            <summary>
            List of panels that are attached/<see cref="P:Sandbox.UI.Panel.Parent">parented</see> directly to this one.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasChildren">
            <summary>
            Whether this panel has any <see cref="P:Sandbox.UI.Panel.Children">child panels</see> at all.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Parent">
            <summary>
            The panel we are directly attached to. This panel will be positioned relative to the given parent, and therefore move with it, typically also be hidden by the parents bounds.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RemoveChild(Sandbox.UI.Panel)">
            <summary>
            Called internally when a child is removed, to remove from our Children list
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnChildRemoved(Sandbox.UI.Panel)">
            <summary>
            A child panel has been removed from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DeleteChildren(System.Boolean)">
            <summary>
            Deletes all child panels via <see cref="M:Sandbox.UI.Panel.Delete(System.Boolean)"/>.
            </summary>
            <inheritdoc cref="M:Sandbox.UI.Panel.Delete(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.UI.Panel.AddChild``1(``0)">
            <summary>
            Add given panel as a child to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InternalAddChild(Sandbox.UI.Panel)">
            <summary>
            Called internally when a child is added, to add to our <see cref="P:Sandbox.UI.Panel.Children">children</see> list.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnChildAdded(Sandbox.UI.Panel)">
            <summary>
            A child panel has been added to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren(System.Comparison{Sandbox.UI.Panel})">
            <summary>
            Sort the <see cref="P:Sandbox.UI.Panel.Children">children</see> using given comparison function.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren``1(System.Func{``0,System.Int32})">
            <summary>
            Sort the <see cref="P:Sandbox.UI.Panel.Children">children</see> using given comparison function.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren(System.Func{Sandbox.UI.Panel,System.Int32})">
            <summary>
            Sort the <see cref="P:Sandbox.UI.Panel.Children">children</see> using given comparison function.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.SiblingIndex">
            <summary>
            The index of this panel in its parent's child list.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddChild``1(System.String)">
            <summary>
            Creates a panel of given type and makes it our child.
            </summary>
            <typeparam name="T">The panel to create.</typeparam>
            <param name="classnames">Optional CSS class names to apply to the newly created panel.</param>
            <returns>The created panel.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.AddChild``1(``0@,System.String)">
            <summary>
            Creates a panel of given type and makes it our child, returning it as an out argument.
            </summary>
            <typeparam name="T">The panel to create.</typeparam>
            <param name="outPanel">The created panel.</param>
            <param name="classnames">Optional CSS class names to apply to the newly created panel.</param>
            <returns>Always returns <see langword="true"/>.</returns>
        </member>
        <member name="P:Sandbox.UI.Panel.AncestorsAndSelf">
            <summary>
            Returns this panel and all its <see cref="P:Sandbox.UI.Panel.Ancestors">ancestors</see>, i.e. the <see cref="P:Sandbox.UI.Panel.Parent">Parent</see>, parent of its parent, etc.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Ancestors">
            <summary>
            Returns all ancestors, i.e. the parent, parent of our parent, etc.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Descendants">
            <summary>
            List of all panels that are attached to this panel, recursively, i.e. all <see cref="P:Sandbox.UI.Panel.Children">children</see> of this panel, children of those children, etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.IsAncestor(Sandbox.UI.Panel)">
            <summary>
            Is the given panel a parent, grandparent, etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FindRootPanel">
            <summary>
            Returns the <see cref="T:Sandbox.UI.RootPanel"/> we are ultimately attached to, if any.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FindPopupPanel">
            <summary>
            Returns the first <see cref="P:Sandbox.UI.Panel.Ancestors">ancestor</see> panel that has no parent.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Scene">
            <summary>
            Returns the scene that this panel belongs to
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetChildIndex(Sandbox.UI.Panel)">
            <summary>
            Returns the index at which the given panel is <see cref="P:Sandbox.UI.Panel.Parent">parented</see> to this panel, or -1 if it is not.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetChild(System.Int32,System.Boolean)">
            <summary>
            Return a child at given index.
            </summary>
            <param name="index">Index at which to look.</param>
            <param name="loop">Whether to loop indices when out of bounds, i.e. -1 becomes last child, 11 becomes second child in a list of 10, etc.</param>
            <returns>Returns the requested child, or <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="P:Sandbox.UI.Panel.ChildrenCount">
            <summary>
            Amount of panels directly <see cref="P:Sandbox.UI.Panel.Parent">parented</see> to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ChildrenOfType``1">
            <summary>
            Returns a list of <see cref="P:Sandbox.UI.Panel.Children">child panels</see> of given type.
            </summary>
            <typeparam name="T">The type of panels to retrieve.</typeparam>
        </member>
        <member name="P:Sandbox.UI.Panel.Class">
            <summary>
            A list of CSS classes applied to this panel.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel._class">
            <inheritdoc cref="P:Sandbox.UI.Panel.Class"/>
        </member>
        <member name="P:Sandbox.UI.Panel.Classes">
            <summary>
            All CSS classes applied to this panel, separated with spaces.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddClass(System.String)">
            <summary>
            Adds CSS class(es) separated by spaces to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetClass(System.String,System.Boolean)">
            <summary>
            Sets a specific CSS class active or not.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FlashClass(System.String,System.Single)">
            <summary>
            Add a class for a set amount of seconds. If called multiple times, we will stomp the earlier call.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ToggleClass(System.String)">
            <summary>
            Add a class if we don't have it, remove a class if we do have it
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddClasses(System.String)">
            <summary>
            Add multiple CSS classes separated by spaces to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RemoveClass(System.String)">
            <summary>
            Removes given CSS class from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.HasClass(System.String)">
            <summary>
            Whether we have the given CSS class or not.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.HasClasses(System.String[])">
            <summary>
            Whether if we have <b>all</b> of these CSS classes.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DirtyStylesRecursive">
            <summary>
            Dirty the styles on this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DirtyStylesWithStyle(Sandbox.UI.Styles,System.Boolean)">
            <summary>
            Dirty the styles of this class and its children recursively.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.BindClass(System.String,System.Func{System.Boolean})">
            <summary>
            Switch the class on or off depending on the value of the bool.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ElementName">
            <summary>
            The element name. If you've created this Panel via a template this will be whatever the element
            name is on there. If not then it'll be the name of the class (ie Panel, Button)
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Id">
            <summary>
            Works the same as the html id="" attribute. If you set Id to "poop", it'll match any styles
            that define #poop in their selector.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.SourceFile">
            <summary>
            If this was created by razor, this is the file in which it was created
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.SourceLine">
            <summary>
            If this was created by razor, this is the line number in the file
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.Task">
            <summary>
            Quick access to timing events, for async/await.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.StyleSheet">
            <summary>
            A collection of stylesheets applied to this panel directly.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.PseudoClass">
            <summary>
            Special flags used by the styling system for hover, active etc..
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasFocus">
            <summary>
            Whether this panel has the <c>:focus</c> pseudo class active.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasActive">
            <summary>
            Whether this panel has the <c>:active</c> pseudo class active.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasHovered">
            <summary>
            Whether this panel has the <c>:hover</c> pseudo class active.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasIntro">
            <summary>
            Whether this panel has the <c>:intro</c> pseudo class active.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasOutro">
            <summary>
            Whether this panel has the <c>:outro</c> pseudo class active.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnHotloaded">
            <summary>
            Called when a hotload happened. (Not necessarily on this panel)
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.AllStyleSheets">
            <summary>
            List of all <see cref="T:Sandbox.UI.StyleSheet"/>s applied to this panel and all its <see cref="P:Sandbox.UI.Panel.AncestorsAndSelf">ancestors</see>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Switch(Sandbox.UI.PseudoClass,System.Boolean)">
            <summary>
            Switch a pseudo class on or off.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsVisible">
            <summary>
            Return true if this panel isn't hidden by opacity or displaymode.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsVisibleSelf">
            <summary>
            Return true if this panel isn't hidden by opacity or displaymode.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Tick">
            <summary>
            Called every frame. This is your "Think" function.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnParentChanged">
            <summary>
            Called after the parent of this panel has changed.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.WantsMouseInput">
            <summary>
            Returns true if this panel would like the mouse cursor to be visible.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelDelta(Vector2)">
            <summary>
            Convert a point from the screen to a point representing a delta on this panel where
            the top left is [0,0] and the bottom right is [1,1]
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelPosition(Vector2)">
            <summary>
            Convert a point from the screen to a position relative to the top left of this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PanelPositionToScreenPosition(Vector2)">
            <summary>
            Convert a point from local space to screen space
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FindInRect(Sandbox.Rect,System.Boolean)">
            <summary>
            Find and return any children of this panel (including self) within the given rect.
            </summary>
            <param name="box">The area to look for panels in, in screen-space coordinates.</param>
            <param name="fullyInside">Whether we want only the panels that are completely within the given bounds.</param>
        </member>
        <member name="P:Sandbox.UI.Panel.AllowChildSelection">
            <summary>
            Allow selecting child text
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDragSelect(Sandbox.UI.SelectionEvent)">
            <summary>
            Called when the player moves the mouse after "press and holding" (or dragging) the panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SelectAllInChildren">
            <summary>
            If AllowChildSelection is enabled, we'll try to select all children text
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.UnselectAllInChildren">
            <summary>
            Clear any selection in children
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.LanguageChanged">
            <summary>
            Called when the current language has changed. This allows you to rebuild
            anything that might need rebuilding. Tokenized text labels should automatically update.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Invoke(System.Single,System.Action)">
            <summary>
            Invoke a method after a delay. If the panel is deleted before this delay the method will not be called.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InvokeOnce(System.String,System.Single,System.Action)">
            <summary>
            Invoke a method after a delay. If the panel is deleted before this delay the method will not be called. If the invoke is called
            while the old one is waiting, the old one will be cancelled.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.CancelInvoke(System.String)">
            <summary>
            Cancel a named invocation
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.StringValue">
            <summary>
            Set via <c>"value"</c> property from HTML.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateValueEvent(System.String,System.Object)">
            <summary>
            Call this when the value has changed due to user input etc. This updates any
            bindings, backwards. Also triggers $"{name}.changed" event, with value being the Value on the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsDeleting">
            <summary>
            Whether <see cref="M:Sandbox.UI.Panel.Delete(System.Boolean)"/> was called on this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Delete(System.Boolean)">
            <summary>
            Deletes the panel.
            </summary>
            <param name="immediate">If <see langword="true"/>, will skip any outros. (<c>:outro</c> CSS pseudo class)</param>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDeleted">
            <summary>
            Called when the panel is about to be deleted.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDeleteRecursive">
            <summary>
            Called on delete.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.WantsDrag">
            <summary>
            Return true if this panel wants to be dragged
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.CanDragScroll">
            <summary>
            Set this to false if you want to opt out of drag scrolling
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FindDragTarget">
            <summary>
            Find a panel in our heirachy that wants to be dragged
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InternalDragEvent(Sandbox.UI.DragEvent)">
            <summary>
            Distribute the drag events to specific virtual functions
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasScrollX">
            <summary>
            Return true if this panel is scrollable on the X axis
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasScrollY">
            <summary>
            Return true if this panel is scrollable on the Y axis
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InitializeEvents">
            <summary>
            Called on creation and hotload to delete and re-initialize event listeners.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddEventListener(System.String,System.Action{Sandbox.UI.PanelEvent})">
            <summary>
            Runs given callback when the given event is triggered.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddEventListener(System.String,System.Action)">
            <summary>
            Runs given callback when the given event is triggered, without access to the <see cref="T:Sandbox.UI.PanelEvent"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateEvent(System.String,System.Object,System.Nullable{System.Single})">
            <summary>
            Create a new event and pass it to the panels event queue.
            </summary>
            <param name="name">Event name.</param>
            <param name="value">Event value.</param>
            <param name="debounce">Time, in seconds, to wait before firing the event.<br/>
            All subsequent calls to <see cref="M:Sandbox.UI.Panel.CreateEvent(System.String,System.Object,System.Nullable{System.Single})"/> with the same event
            name will update the original event instead of creating a new event, until it finally triggers.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateEvent(Sandbox.UI.PanelEvent)">
            <summary>
            Pass given event to the event queue.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnEvent(Sandbox.UI.PanelEvent)">
            <summary>
            Called when various <see cref="T:Sandbox.UI.PanelEvent"/>s happen. Handles event listeners and many standard events by default.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnClick(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player releases their left mouse button (Mouse 1) while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMiddleClick(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player releases their middle mouse button (Mouse 3) while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnRightClick(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player releases their right mouse button (Mouse 2) while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseDown(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player presses down the left or right mouse buttons while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseUp(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player releases left or right mouse button.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDoubleClick(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player double clicks the panel with the left mouse button.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseMove(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the cursor moves while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseOver(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the cursor enters this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseOut(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the cursor leaves this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnBack(Sandbox.UI.PanelEvent)">
            <summary>
            Called when the player presses the "Back" button while hovering this panel, which is typically "mouse 5", aka one of the mouse buttons on its side.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnForward(Sandbox.UI.PanelEvent)">
            <summary>
            Called when the player presses the "Forward" button while hovering this panel, which is typically "mouse 4", aka one of the mouse buttons on its side.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnEscape(Sandbox.UI.PanelEvent)">
            <summary>
            Called when the escape key is pressed
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnFocus(Sandbox.UI.PanelEvent)">
            <summary>
            Called when this panel receives input focus.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnBlur(Sandbox.UI.PanelEvent)">
            <summary>
            Called when this panel loses input focus.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.MousePosition">
            <summary>
            Current mouse position local to this panels top left corner.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetTransformPosition(Vector2)">
            <summary>
            Called by <see cref="M:Sandbox.UI.PanelInput.CheckHover(Sandbox.UI.Panel,Vector2,Sandbox.UI.Panel@)" /> to transform
            the current mouse position using the panel's LocalMatrix (by default). This can be overriden for special cases.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.UI.Panel.IsInside(Vector2)">
            <summary>
            Whether given screen position is within this panel. This will accurately handle border radius as well.
            </summary>
            <param name="pos">The position to test, in screen coordinates.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.IsInside(Sandbox.Rect,System.Boolean)">
            <summary>
            Whether the given rect is inside this panels bounds. (<see cref="F:Sandbox.UI.Box.Rect"/>)
            </summary>
            <param name="rect">The rect to test, which should have screen-space coordinates.</param>
            <param name="fullyInside"><see langword="true"/> to test if the given rect is completely inside the panel. <see langword="false"/> to test for an intersection.</param>
        </member>
        <member name="P:Sandbox.UI.Panel.AcceptsFocus">
            <summary>
            False by default, can this element accept keyboard focus. If an element accepts
            focus it'll be able to receive keyboard input.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ButtonInput">
            <summary>
            Describe what to do with keyboard input. The default is InputMode.UI which means that when
            focused, this panel will receive Keys Typed and Button Events.
            If you set this to InputMode.Game, this panel will redirect its inputs to the game, which means
            for example that if you're focused on this panel and press space, it'll send the jump button to the game.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.AcceptsImeInput">
            <summary>
            False by default. Anything that is capable of accepting IME input should return true. Which is probably just a TextEntry.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Focus">
            <summary>
            Give input focus to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Blur">
            <summary>
            Remove input focus from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnButtonEvent(Sandbox.UI.ButtonEvent)">
            <summary>
            Called when any button, mouse (except for mouse4/5) and keyboard, are pressed or depressed while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnKeyTyped(System.Char)">
            <summary>
            Called when a printable character has been typed (pressed) while this panel has input focus. (<see cref="M:Sandbox.UI.Panel.Focus"/>)
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnButtonTyped(Sandbox.UI.ButtonEvent)">
            <summary>
            Called when any keyboard button has been typed (pressed) while this panel has input focus. (<see cref="M:Sandbox.UI.Panel.Focus"/>)
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnPaste(System.String)">
            <summary>
            Called when the user presses CTRL+V while this panel has input focus.
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Sandbox.UI.Panel.GetClipboardValue(System.Boolean)">
            <summary>
            If we have a value that can be copied to the clipboard, return it here.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseWheel(Vector2)">
            <summary>
            Called when the player scrolls their mouse wheel while hovering this panel.
            </summary>
            <param name="value">The scroll wheel delta. Positive values are scrolling down, negative - up.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.TryScroll(Vector2)">
            <summary>
            Called from <see cref="M:Sandbox.UI.Panel.OnMouseWheel(Vector2)"/> to try to scroll.
            </summary>
            <param name="value">The scroll wheel delta. Positive values are scrolling down, negative - up.</param>
            <returns>Return true to NOT propagate the event to the <see cref="P:Sandbox.UI.Panel.Parent"/>.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.TryScrollToBottom">
            <summary>
            Scroll to the bottom, if the panel has scrolling enabled.
            </summary>
            <returns>Whether we scrolled to the bottom or not.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.SetMouseCapture(System.Boolean)">
            <summary>
            Captures the mouse cursor while active. The cursor will be hidden and will be stuck in place.
            <para>You will want to use <see cref="P:Sandbox.Mouse.Delta"/> in
            <see cref="M:Sandbox.UI.Panel.Tick"/> while <see cref="P:Sandbox.UI.Panel.HasMouseCapture"/> to read mouse movements.</para>
            <para>You can call this from <see cref="M:Sandbox.UI.Panel.OnButtonEvent(Sandbox.UI.ButtonEvent)"/> for mouse clicks.</para>
            </summary>
            <param name="b">Whether to enable or disable the capture.</param>
        </member>
        <member name="P:Sandbox.UI.Panel.HasMouseCapture">
            <summary>
            Whether this panel is capturing the mouse cursor. See <see cref="M:Sandbox.UI.Panel.SetMouseCapture(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RayToLocalPosition(Ray,Vector2@,System.Single@)">
            <summary>
            Transform a ray in 3D space to a position on the panel. This is used for world panel input.
            </summary>
            <param name="ray">The ray in 3D world space to test against this panel.</param>
            <param name="position">Position on the panel where the intersection happened, local to the panel's top left corner.</param>
            <param name="distance">Distance from the ray's origin to the intersection in 3D space.</param>
            <returns>Return true if a hit/intersection was detected.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.Sandbox#Internal#IPanel#UpdateTooltip(Sandbox.Internal.IPanel)">
            <summary>
            If the tooltip text changed, we'll update it here. I haven't exposed this to game code yet
            because I doubt the usefulness to people that are manually creating tooltip panels.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PushLayer(Sandbox.UI.PanelRenderer)">
            <summary>
            Called before rendering this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PopLayer(Sandbox.UI.PanelRenderer,Sandbox.RenderTarget)">
            <summary>
            Called after rendering this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DrawPreFilterShadows">
            <summary>
            Draws shadows for the current layer 
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DrawPreFilterBorder">
            <summary>
            Draws borders for the current layer
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Box">
            <summary>
            Access to various bounding boxes of this panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasContent">
            <summary>
            If true, calls <see cref="M:Sandbox.UI.Panel.DrawContent(Sandbox.UI.RenderState@)"/>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.ScrollVelocity">
            <summary>
            The velocity of the current scroll
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ScrollOffset">
            <summary>
            Offset of the panel's children position for scrolling purposes.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ScaleToScreen">
            <summary>
            Scale of the panel on the screen.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ScaleFromScreen">
            <summary>
            Inverse scale of <see cref="P:Sandbox.UI.Panel.ScaleToScreen"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.LocalMatrix">
            <summary>
            If this panel has transforms, they'll be reflected here
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.GlobalMatrix">
            <summary>
            If this panel or its parents have transforms, they'll be compounded here.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.TransformMatrix">
            <summary>
            The matrix that is applied as a result of transform: styles
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasBackdropFilter">
            <summary>
            The computed style has a non-default backdrop filter property
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasFilter">
            <summary>
            The computed style has a non-default filter property
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasBackground">
            <summary>
            The computed style has a renderable background
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Opacity">
            <summary>
            The currently calculated opacity.
            This is set by multiplying our current style opacity with our parent's opacity.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnLayout(Sandbox.Rect@)">
            <summary>
            This panel has just been laid out. You can modify its position now and it will affect its children.
            This is a useful place to restrict shit to the screen etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FinalLayout(Vector2)">
            <summary>
            Takes a <see cref="T:Sandbox.UI.LayoutCascade"/> and returns an outer rect
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.PreferScrollToBottom">
            <summary>
            If true, we'll try to stay scrolled to the bottom when the panel changes size
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsScrollAtBottom">
            <summary>
            Whether the scrolling is currently pinned to the bottom of the panel as dictated by <see cref="P:Sandbox.UI.Panel.PreferScrollToBottom"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ScrollSize">
            <summary>
            The size of the scrollable area within this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FinalLayoutChildren(Vector2)">
            <summary>
            Layout the children of this panel.
            </summary>
            <param name="offset">The parent's position.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.ConstrainScrolling(Vector2)">
            <summary>
            Constrain <see cref="P:Sandbox.UI.Panel.ScrollOffset">scrolling</see> to the given size.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PlaySound(System.String)">
            <summary>
            Play a sound from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.MoveAfterSibling(Sandbox.UI.Panel)">
            <summary>
            Move this panel to be after the given sibling.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetChildIndex(Sandbox.UI.Panel,System.Int32)">
            <summary>
            Move given child panel to be given index, where 0 is the first child.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.templateBindsChanged">
            <summary>
            True when a bind has changed and OnParametersSet call is pending a call
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetPropertyObject(System.String,System.Object)">
            <summary>
            Same as <see cref="M:Sandbox.UI.Panel.SetProperty(System.String,System.String)"/>, but first tries to set the property on the panel object, then process any special properties such as <c>class</c>.
            </summary>
            <inheritdoc cref="M:Sandbox.UI.Panel.SetProperty(System.String,System.String)"/>
        </member>
        <member name="M:Sandbox.UI.Panel.SetProperty(System.String,System.String)">
            <summary>
            Set a property on the panel, such as special properties (<c>class</c>, <c>id</c>, <c>style</c> and <c>value</c>, etc.) and properties of the panel's C# class.
            </summary>
            <param name="name">name of the property to modify.</param>
            <param name="value">Value to assign to the property.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.SetAttribute(System.String,System.String)">
            <summary>
            Used in templates, gets an attribute that was set in the template.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetAttribute(System.String,System.String)">
            <summary>
            Used in templates, try to get the attribute that was set in creation.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnParametersSet">
            <summary>
            Called after all templated panel binds have been set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnParametersSetAsync">
            <summary>
            Called after all templated panel binds have been set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetContent(System.String)">
            <summary>
            Called by the templating system when an element has content between its tags.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.razorTreeDirty">
            <summary>
            true when the tree should be re-rendered next frame.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.StateHasChanged">
            <summary>
            For razor panels, call when the state of the render tree has changed such that
            it would be a good idea to re-render the tree. You would usually not need to call
            this manually.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetRenderTreeChecksum">
            <summary>
            Overridden/implemented by Razor templating, contains render tree checksum to determine when the render tree content has changed.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder)">
            <summary>
            Overridden/implemented by Razor templating to build a render tree.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.BuildHash">
            <summary>
            By overriding this you can return a hash of variables used by the Razor layout, which
            will cause a rebuild when changed. This is useful when your layout uses a global variable
            because by adding it to a HashCode.Combine here you can easily trigger a build when it changes.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnRenderFragmentChanged(Sandbox.UI.Panel)">
            <summary>
            A RenderFragment has been set on us, so our tree has potential changes now.
            Lets update and see.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InternalRenderTree">
            <summary>
            Allows building render tree from outside of the class.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnAfterTreeRender(System.Boolean)">
            <summary>
            Called after the razor tree has been created/rendered.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ClearRenderTree">
            <summary>
            Delete all children generated by the Razor render tree.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DrawContent(Sandbox.UI.RenderState@)">
            <summary>
            Called when <see cref="P:Sandbox.UI.Panel.HasContent"/> is set to <see langword="true"/> to custom draw the panels content.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DrawBackground(Sandbox.UI.RenderState@)">
            <summary>
            Called to draw the panels background.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ComputedStyle">
            <summary>
            This is the style that we computed last. If you're looking to see which
            styles are set on this panel then this is what you're looking for.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ActiveStyleBlocks">
            <summary>
            A importance sorted list of style blocks that are active on this panel
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Style">
            <summary>
            Allows you to set styles specifically on this panel. Setting the style will
            only affect this panel and no others and will override any other styles.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.TryFindKeyframe(System.String,Sandbox.UI.KeyFrames@)">
            <summary>
            Try to find <c>@keyframes</c> CSS rule with given name in <see cref="P:Sandbox.UI.Panel.AllStyleSheets"/>.
            </summary>
            <param name="name">The name to search for.</param>
            <param name="keyframes">The keyframes, if any are found, or <see langword="null"/>.</param>
            <returns><see langword="true"/> if <c>@keyframes</c> with given name were found.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.StyleSelectorsChanged(System.Boolean,System.Boolean,Sandbox.UI.RootPanel)">
            <summary>
            Should be called when something happens that means that this panel's stylesheets need to be
            re-evaluated. Like becoming hovered or classes changed. You don't call this when changing styles
            directly on the panel, just on anything that will change which stylesheets should get selected.
            </summary>
            <param name="ancestors">Also re-evaluate all ancestor panels. (for <c>:has()</c>)</param>
            <param name="descendants">Also re-evaluate all child panels. (for parent selectors)</param>
            <param name="root">Root panel cache so we don't need to keep looking it up.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.LoadStyleSheetFromAttribute">
            <summary>
            Loads a stylesheet from one specified within a [StyleSheet] attribute.
            </summary>
            <returns>True if the attribute exists and we loaded from it, otherwise false</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.LoadStyleSheetAuto">
            <summary>
            Loads a stylesheet from one based on the class name.
            </summary>
            <returns>True if the attribute exists and we loaded from it, otherwise false</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.LoadStyleSheetFromPath(System.String,System.Boolean)">
            <summary>
            Loads a stylesheet from the specified path.
            </summary>
            <returns>True if the stylesheet was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.OnTemplateSlot(Sandbox.Html.INode,System.String,Sandbox.UI.Panel)">
            <summary>
            TODO: Obsolete this and instead maybe we have something like [PanelSlot( "slotname" )] that 
            is applied on properties. Then when we find a slot="slotname" we chase up the heirachy and set the property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Tooltip">
            <summary>
            A string to show when hovering over this panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.TooltipClass">
            <summary>
            The created tooltip element will have this class, if set.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasTooltip">
            <summary>
            You should override and return true if you're overriding <see cref="M:Sandbox.UI.Panel.CreateTooltipPanel"/>.
            Otherwise this will return true if <see cref="P:Sandbox.UI.Panel.Tooltip"/> is not empty.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PushGlobalContext">
            <summary>
            Pushes the global context to whatever is suitable for this panel.
            This should never really have to be called, when panels tick render etc. they'll already be in the right context.
            This is for when the UI system is used outside of the standard contexts, like tooltips.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateTooltipPanel">
            <summary>
            Create a tooltip panel. You can override this to create a custom tooltip panel.<br/>
            If you're overriding this and not setting <see cref="P:Sandbox.UI.Panel.Tooltip"/>, then you must override and return true in <see cref="P:Sandbox.UI.Panel.HasTooltip"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Transitions">
            <summary>
            Handles the storage, progression and application of CSS transitions.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasActiveTransitions">
            <summary>
            Returns true if this panel has any active CSS transitions.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SkipTransitions">
            <summary>
            Any transitions running, or about to run, will jump straight to the end.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.UserData">
            <summary>
            Can be used to store random data without sub-classing the panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.DeletionToken">
            <summary>
            Get a token that is cancelled when the panel is deleted
            </summary>
        </member>
        <member name="T:Sandbox.UI.Box">
            <summary>
            Represents position and size of a <see cref="T:Sandbox.UI.Panel"/> on the screen.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.RectOuter">
            <summary>
            Position and size of the element on the screen, <b>including both - its padding AND margin</b>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.RectInner">
            <summary>
            Position and size of only the element's inner content on the screen, <i>without padding OR margin</i>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.Padding">
            <summary>
            The size of padding.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.Border">
            <summary>
            The size of border.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.Margin">
            <summary>
            The size of border.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.Rect">
            <summary>
            Position and size of the element on the screen, <b>including its padding</b>, <i>but not margin</i>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.ClipRect">
            <summary>
            <see cref="F:Sandbox.UI.Box.Rect"/> minus the border sizes.
            Used internally to "clip" (hide) everything outside of these bounds, if the panels <see cref="T:Sandbox.UI.OverflowMode"/> is not set to <see cref="F:Sandbox.UI.OverflowMode.Visible"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Box.Left">
            <summary>
            Position of the left edge in screen coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Box.Right">
            <summary>
            Position of the right edge in screen coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Box.Top">
            <summary>
            Position of the top edge in screen coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Box.Bottom">
            <summary>
            Position of the bottom edge in screen coordinates.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.ParseStyles(Sandbox.Parse@,Sandbox.UI.Styles,System.Boolean)">
            <summary>
            Parse the styles as you would if they were passed in an style="width: 100px" attribute
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.Selector(System.String,Sandbox.UI.StyleBlock)">
            <summary>
            Here we divide the selectors into groups
            .fucker, .cocks, .hairy
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.ParseSingleSelector(System.String,Sandbox.UI.StyleBlock)">
            <summary>
            Parse a single rule, which as "panel.closed.error:hover"
            </summary>
            <returns></returns>
        </member>
        <member name="F:Sandbox.UI.PanelRenderer.Scissor">
            <summary>
            Software scissor, panels outside of this should not be rendered
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelRenderer.ScissorGPU">
            <summary>
            Scissor passed to gpu shader to be transformed
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.ShouldEarlyCull(Sandbox.UI.Panel)">
            <summary>
            Quick check to see if a panel should be culled based on the current scissor
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.Render(Sandbox.UI.Panel,Sandbox.UI.RenderState)">
            <summary>
            Render a panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.PopLayer(Sandbox.UI.Panel,Sandbox.RenderTarget)">
            <returns>Will return <c>false</c> if we're at the top of the layer stack.</returns>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.DrawBoxShadows(Sandbox.UI.Panel,Sandbox.UI.RenderState@,System.Boolean)">
            <summary>
            Draw the outset box shadows - this is called *before* drawing the background
            </summary>
        </member>
        <member name="T:Sandbox.UI.RootPanel">
            <summary>
            A root panel. Serves as a container for other panels, handles things such as rendering.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.PanelBounds">
            <summary>
            Bounds of the panel, i.e. its size and position on the screen.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.ChildrenWantMouseInput">
            <summary>
            If any of our panels are visible and want mouse input (pointer-events != none) then
            this will be set to true.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.Scale">
            <summary>
            The scale of this panel and its children.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.RenderedManually">
            <summary>
            If set to true this panel won't be rendered to the screen like a normal panel.
            This is true when the panel is drawn via other means (like as a world panel).
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.IsWorldPanel">
            <summary>
            True if this is a world panel, so should be skipped when determining cursor visibility etc
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.IsVR">
            <summary>
            If this panel belongs to a VR overlay
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.IsHighQualityVR">
            <summary>
            If this panel should be rendered with ~4K resolution.
            </summary>
        </member>
        <member name="F:Sandbox.UI.RootPanel.MousePos">
            <summary>
            Current global mouse position, projected onto plane for world panels.
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.Layout">
            <summary>
            This is called from tests to emulate the regular root panel simulate loop
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.UpdateBounds(Sandbox.Rect)">
            <summary>
            Called before layout to lock the bounds of this root panel to the screen size (which is passed).
            Internally this sets PanelBounds to rect and calls UpdateScale.
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.UpdateScale(Sandbox.Rect)">
            <summary>
            Work out scaling here. Default is to scale relative to the screen being
            1920 wide. ie - scale = screensize.Width / 1920.0f;
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.RenderManual(System.Single)">
            <summary>
            Render this panel manually. This gives more flexibility to where UI is rendered, to texture for example.
            <see cref="P:Sandbox.UI.RootPanel.RenderedManually"/> must be set to true.
            </summary>
        </member>
        <member name="F:Sandbox.UI.RootPanel.styleRuleUpdates">
            <summary>
            A list of panels that are waiting to have their styles re-evaluated
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.AddToBuildStyleRulesList(Sandbox.UI.Panel)">
            <summary>
            Add this panel to a list to have their styles re-evaluated. This should be done any
            time the panel changes in a way that could affect its style selector.. like if its child
            index changed, or classes added or removed, or became hovered etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.BuildStyleRules">
            <summary>
            Run through all panels that are pending a re-check on their style rules.
            Only properly invalidate them if their rules actually change.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TransitionDesc">
            <summary>
            Describes transition of a single CSS property, a.k.a. the values of a <c>transition</c> CSS property.
            <para>Utility to create a transition by comparing the
            panel style before and after the scope.</para>
            </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionDesc.Property">
            <summary>
            The CSS property to transition.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionDesc.Duration">
            <summary>
            Duration of the transition between old value and new value.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionDesc.Delay">
            <summary>
            If set, delay before starting the transition after the property was changed.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionDesc.TimingFunction">
            <summary>
            The timing or "easing" function. <c>transition-timing-function</c> CSS property.
            Example values would be <c>ease</c>,  <c>ease-in</c>,  <c>ease-out</c> and  <c>ease-in-out</c>.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TransitionList">
             <summary>
             A list of CSS properties that should transition when changed.
            
             Utility to create a transition by comparing the
             panel style before and after the scope.
             </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionList.List">
            <summary>
            The actual list of CSS properties that should be transitioned.
            </summary>
        </member>
        <member name="M:Sandbox.UI.TransitionList.Clear">
            <summary>
            Clear the list of CSS transitions.
            </summary>
        </member>
        <member name="T:Sandbox.UI.BaseStyles">
            <summary>
            Auto generated container class for majority of CSS properties available.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.Dirty">
            <summary>
            Called when any CSS properties are changed.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Overflow">
            <summary>
            Represents the <c>overflow</c> CSS property.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.Add(Sandbox.UI.BaseStyles)">
            <summary>
            Copy over only the styles that are set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.From(Sandbox.UI.BaseStyles)">
            <summary>
            Copy all styles from given style set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.Set(System.String,System.String)">
            <summary>
            Copy all styles from given style set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.SetRect(Sandbox.Rect@,System.Single)">
            <summary>
            Set Left, Right, Width and Height based on this rect. Scale can be used to scale the rect (maybe you want to use Panel.ScaleFromScreen etc)
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Content">
            <summary>
            Represents the <c>content</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Width">
            <summary>
            Represents the <c>width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MinWidth">
            <summary>
            Represents the <c>min-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaxWidth">
            <summary>
            Represents the <c>max-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Height">
            <summary>
            Represents the <c>height</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MinHeight">
            <summary>
            Represents the <c>min-height</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaxHeight">
            <summary>
            Represents the <c>max-height</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Left">
            <summary>
            Represents the <c>left</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Top">
            <summary>
            Represents the <c>top</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Right">
            <summary>
            Represents the <c>right</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Bottom">
            <summary>
            Represents the <c>bottom</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Opacity">
            <summary>
            Represents the <c>opacity</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundColor">
            <summary>
            Represents the <c>background-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PaddingLeft">
            <summary>
            Represents the <c>padding-left</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PaddingTop">
            <summary>
            Represents the <c>padding-top</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PaddingRight">
            <summary>
            Represents the <c>padding-right</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PaddingBottom">
            <summary>
            Represents the <c>padding-bottom</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MarginLeft">
            <summary>
            Represents the <c>margin-left</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MarginTop">
            <summary>
            Represents the <c>margin-top</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MarginRight">
            <summary>
            Represents the <c>margin-right</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MarginBottom">
            <summary>
            Represents the <c>margin-bottom</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderTopLeftRadius">
            <summary>
            Represents the <c>border-top-left-radius</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderTopRightRadius">
            <summary>
            Represents the <c>border-top-right-radius</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderBottomRightRadius">
            <summary>
            Represents the <c>border-bottom-right-radius</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderBottomLeftRadius">
            <summary>
            Represents the <c>border-bottom-left-radius</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderLeftWidth">
            <summary>
            Represents the <c>border-left-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderTopWidth">
            <summary>
            Represents the <c>border-top-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderRightWidth">
            <summary>
            Represents the <c>border-right-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderBottomWidth">
            <summary>
            Represents the <c>border-bottom-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderLeftColor">
            <summary>
            Represents the <c>border-left-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderTopColor">
            <summary>
            Represents the <c>border-top-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderRightColor">
            <summary>
            Represents the <c>border-right-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderBottomColor">
            <summary>
            Represents the <c>border-bottom-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontSize">
            <summary>
            Represents the <c>font-size</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontColor">
            <summary>
            Represents the <c>font-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontWeight">
            <summary>
            Represents the <c>font-weight</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontFamily">
            <summary>
            Represents the <c>font-family</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.CaretColor">
            <summary>
            Represents the <c>caret-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Cursor">
            <summary>
            Represents the <c>cursor</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PointerEvents">
            <summary>
            Represents the <c>pointer-events</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MixBlendMode">
            <summary>
            Represents the <c>mix-blend-mode</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Position">
            <summary>
            Represents the <c>position</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.OverflowX">
            <summary>
            Represents the <c>overflow-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.OverflowY">
            <summary>
            Represents the <c>overflow-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexDirection">
            <summary>
            Represents the <c>flex-direction</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.JustifyContent">
            <summary>
            Represents the <c>justify-content</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Display">
            <summary>
            Represents the <c>display</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexWrap">
            <summary>
            Represents the <c>flex-wrap</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AlignContent">
            <summary>
            Represents the <c>align-content</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AlignSelf">
            <summary>
            Represents the <c>align-self</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AlignItems">
            <summary>
            Represents the <c>align-items</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexBasis">
            <summary>
            Represents the <c>flex-basis</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexGrow">
            <summary>
            Represents the <c>flex-grow</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexShrink">
            <summary>
            Represents the <c>flex-shrink</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.RowGap">
            <summary>
            Represents the <c>row-gap</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.ColumnGap">
            <summary>
            Represents the <c>column-gap</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AspectRatio">
            <summary>
            Represents the <c>aspect-ratio</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextAlign">
            <summary>
            Represents the <c>text-align</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextOverflow">
            <summary>
            Represents the <c>text-overflow</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextFilter">
            <summary>
            Represents the <c>text-filter</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.WordBreak">
            <summary>
            Represents the <c>word-break</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationLine">
            <summary>
            Represents the <c>text-decoration-line</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationColor">
            <summary>
            Represents the <c>text-decoration-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationThickness">
            <summary>
            Represents the <c>text-decoration-thickness</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationSkipInk">
            <summary>
            Represents the <c>text-decoration-skip-ink</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationStyle">
            <summary>
            Represents the <c>text-decoration-style</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextUnderlineOffset">
            <summary>
            Represents the <c>text-underline-offset</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextOverlineOffset">
            <summary>
            Represents the <c>text-overline-offset</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextLineThroughOffset">
            <summary>
            Represents the <c>text-line-through-offset</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontStyle">
            <summary>
            Represents the <c>font-style</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Transform">
            <summary>
            Represents the <c>transform</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextTransform">
            <summary>
            Represents the <c>text-transform</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TransformOriginX">
            <summary>
            Represents the <c>transform-origin-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TransformOriginY">
            <summary>
            Represents the <c>transform-origin-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.LetterSpacing">
            <summary>
            Represents the <c>letter-spacing</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.LineHeight">
            <summary>
            Represents the <c>line-height</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.WordSpacing">
            <summary>
            Represents the <c>word-spacing</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.WhiteSpace">
            <summary>
            Represents the <c>white-space</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.ZIndex">
            <summary>
            Represents the <c>z-index</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Order">
            <summary>
            Represents the <c>order</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.SoundIn">
            <summary>
            Represents the <c>sound-in</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.SoundOut">
            <summary>
            Represents the <c>sound-out</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterBlur">
            <summary>
            Represents the <c>backdrop-filter-blur</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterBrightness">
            <summary>
            Represents the <c>backdrop-filter-brightness</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterContrast">
            <summary>
            Represents the <c>backdrop-filter-contrast</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterSaturate">
            <summary>
            Represents the <c>backdrop-filter-saturate</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterSepia">
            <summary>
            Represents the <c>backdrop-filter-sepia</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterInvert">
            <summary>
            Represents the <c>backdrop-filter-invert</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterHueRotate">
            <summary>
            Represents the <c>backdrop-filter-hue-rotate</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterBlur">
            <summary>
            Represents the <c>filter-blur</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterSaturate">
            <summary>
            Represents the <c>filter-saturate</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterSepia">
            <summary>
            Represents the <c>filter-sepia</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterBrightness">
            <summary>
            Represents the <c>filter-brightness</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterHueRotate">
            <summary>
            Represents the <c>filter-hue-rotate</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterInvert">
            <summary>
            Represents the <c>filter-invert</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterContrast">
            <summary>
            Represents the <c>filter-contrast</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterTint">
            <summary>
            Represents the <c>filter-tint</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterBorderWidth">
            <summary>
            Represents the <c>filter-border-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterBorderColor">
            <summary>
            Represents the <c>filter-border-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskMode">
            <summary>
            Represents the <c>mask-mode</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskRepeat">
            <summary>
            Represents the <c>mask-repeat</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskSizeX">
            <summary>
            Represents the <c>mask-size-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskSizeY">
            <summary>
            Represents the <c>mask-size-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskPositionX">
            <summary>
            Represents the <c>mask-position-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskPositionY">
            <summary>
            Represents the <c>mask-position-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskAngle">
            <summary>
            Represents the <c>mask-angle</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskScope">
            <summary>
            Represents the <c>mask-scope</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundSizeX">
            <summary>
            Represents the <c>background-size-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundSizeY">
            <summary>
            Represents the <c>background-size-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundPositionX">
            <summary>
            Represents the <c>background-position-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundPositionY">
            <summary>
            Represents the <c>background-position-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundRepeat">
            <summary>
            Represents the <c>background-repeat</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthLeft">
            <summary>
            Represents the <c>border-image-width-left</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthRight">
            <summary>
            Represents the <c>border-image-width-right</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthTop">
            <summary>
            Represents the <c>border-image-width-top</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthBottom">
            <summary>
            Represents the <c>border-image-width-bottom</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageFill">
            <summary>
            Represents the <c>border-image-fill</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageRepeat">
            <summary>
            Represents the <c>border-image-repeat</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageTint">
            <summary>
            Represents the <c>border-image-tint</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundBlendMode">
            <summary>
            Represents the <c>background-blend-mode</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundTint">
            <summary>
            Represents the <c>background-tint</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundAngle">
            <summary>
            Represents the <c>background-angle</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextBackgroundAngle">
            <summary>
            Represents the <c>text-background-angle</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PerspectiveOriginX">
            <summary>
            Represents the <c>perspective-origin-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PerspectiveOriginY">
            <summary>
            Represents the <c>perspective-origin-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextStrokeColor">
            <summary>
            Represents the <c>text-stroke-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextStrokeWidth">
            <summary>
            Represents the <c>text-stroke-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.ImageRendering">
            <summary>
            Represents the <c>image-rendering</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationDelay">
            <summary>
            Represents the <c>animation-delay</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationDirection">
            <summary>
            Represents the <c>animation-direction</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationDuration">
            <summary>
            Represents the <c>animation-duration</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationFillMode">
            <summary>
            Represents the <c>animation-fill-mode</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationIterationCount">
            <summary>
            Represents the <c>animation-iteration-count</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationName">
            <summary>
            Represents the <c>animation-name</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationPlayState">
            <summary>
            Represents the <c>animation-play-state</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationTimingFunction">
            <summary>
            Represents the <c>animation-timing-function</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontSmooth">
            <summary>
            Represents the <c>font-smooth</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.ObjectFit">
            <summary>
            Represents the <c>object-fit</c> CSS property.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.AddGenerated(Sandbox.UI.BaseStyles)">
            <summary>
            Copy over only the styles that are set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.FromGenerated(Sandbox.UI.BaseStyles)">
            <summary>
            Copy all styles from given style set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.SetGenerated(System.String,System.String)">
            <summary>
            Set a CSS property via its string name.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.FromLerp(Sandbox.UI.BaseStyles,Sandbox.UI.BaseStyles,System.Single)">
            <summary>
            Lerp every property in this stylesheet
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.LerpProperty(System.String,Sandbox.UI.BaseStyles,Sandbox.UI.BaseStyles,System.Single)">
            <summary>
            Lerp a specific property by name
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.Clone">
            <summary>
            Perform a deep copy of this stylesheet
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.HasAnimation">
            <summary>
            Whether there is an active CSS animation.
            </summary>
        </member>
        <member name="T:Sandbox.UI.StyleBlock">
            <summary>
            A CSS rule - ie ".chin { width: 100%; height: 100%; }"
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.Selectors">
            <summary>
            A list of appropriate selectors for this block (ie ".button")
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.SelectorStrings">
            <summary>
            A list of selectors for this block
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleBlock.GetRawValues">
            <summary>
            Get the list of raw style values
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleBlock.SetRawValue(System.String,System.String,System.String)">
            <summary>
            Update a raw style value
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.FileName">
            <summary>
            The filename of the file containing this style block (or null if none)
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.AbsolutePath">
            <summary>
            The absolute on disk filename for this style block (or null if not on disk)
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.FileLine">
            <summary>
            The line in the file containing this style block
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleBlock.Styles">
            <summary>
            The styles that are defined in this block
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleBlock.Test(Sandbox.UI.IStyleTarget,Sandbox.UI.PseudoClass)">
            <summary>
            Test whether target passes our selector tests. We use forceFlag to do alternate tests for flags like ::before and ::after.
            It's basically added to the target's pseudo class list for the test.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleBlock.TestBroadphase(Sandbox.UI.IStyleTarget)">
            <summary>
            Tests a few broadphase conditions to build a list of feasible
            styleblocks tailored for a panel.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Styles">
            <summary>
            Represents all supported CSS properties and their currently assigned values.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Styles.ResetAnimation">
            <summary>
            Stops the animation. If we have animation vars we'll start again.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Styles.StartAnimation(System.String,System.Single,System.Int32,System.Single,System.String,System.String,System.String)">
            <summary>
            Stop any previous animations and start this one. Make it last this long.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Styles.HasTransitions">
            <summary>
            Whether this style sheet has any transitions that would need to be run.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Styles.Transitions">
            <summary>
            List of transitions this style sheet has.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Styles.BuildTransformMatrix(Vector2)">
            <summary>
            Creates a matrix based on this style's "transform" and other related properties
            </summary>
        </member>
        <member name="M:Sandbox.UI.Styles.MarkPanelsDirty">
            <summary>
            Try to find all panels using this style and mark them dirty so they'll
            redraw with the style. This should be called when the style is changed. Which
            is only technically when done via the editor.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Styles.SetImage(System.String,System.Func{System.Lazy{Sandbox.Texture},System.Boolean},System.Func{System.String,System.Boolean},System.Func{System.String,System.Boolean},System.Func{System.Single,System.Boolean})">
            <param name="value"></param>
            <param name="setImage">Optional</param>
            <param name="setSize">Optional</param>
            <param name="setRepeat">Optional</param>
            <param name="setAngle">Optional</param>
        </member>
        <member name="T:Sandbox.UI.StyleSelector">
            <summary>
            A CSS selector like "Panel.button.red:hover .text"
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleSelector.Id">
            <summary>
            The Id selector - minus the #
            https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleSelector.Parent">
            <summary>
            Descendant combinator
            A B
            Child combinator
            A > B
            Adjacent sibling combinator
            A + B
            General sibling combinator
            A ~B
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleSelector.UniversalSelector">
            <summary>
            True if this has a universal selector (*)
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleSelector.AdjacentSibling">
            <summary>
            For + combinator
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleSelector.GeneralSibling">
            <summary>
            For ~ combinator
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSelector.Test(Sandbox.UI.IStyleTarget,Sandbox.UI.PseudoClass)">
            <summary>
            Test whether target passes our selector test. We use forceFlag to do alternate tests for flags like ::before and ::after.
            It's basically added to the target's pseudo class list for the test.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheet.InitStyleSheets">
            <summary>
            Between sessions we clear the stylesheets, so one gamemode can't accidentally
            use cached values from another.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheet.Release">
            <summary>
            Releases the filesystem watcher so we won't get file changed events.
            </summary>
        </member>
        <member name="T:Sandbox.UI.StyleSheetCollection">
            <summary>
            A collection of <see cref="T:Sandbox.UI.StyleSheet"/> objects applied directly to a panel.
            See <see cref="F:Sandbox.UI.Panel.StyleSheet"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Add(Sandbox.UI.StyleSheet)">
            <summary>
            Add a stylesheet directly
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Load(System.String,System.Boolean,System.Boolean)">
            <summary>
            Load the stylesheet from a file.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Parse(System.String,System.Boolean)">
            <summary>
            Load the stylesheet from a string.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Remove(Sandbox.UI.StyleSheet)">
            <summary>
            Remove a specific <see cref="T:Sandbox.UI.StyleSheet"/> from the collection.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Remove(System.String)">
            <summary>
            Remove all stylesheets whose filename matches this wildcard glob.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.CollectVariables">
            <summary>
            Returns all CSS variables from the owning panel and its ancestors.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Transitions">
            <summary>
            Handles the storage, progression and application of CSS transitions for a single <see cref="T:Sandbox.UI.Panel"/>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Transitions.Entries">
            <summary>
            Active CSS transitions.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Transitions.HasAny">
            <summary>
            Whether there are any active CSS transitions.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Transitions.Clear">
            <summary>
            Clear all transitions. This will immediately remove transitions, leaving styles wherever they are.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Transitions.Kill">
            <summary>
            Immediately snaps all transitions to the end point, at which point they're removed.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Clipboard.SetText(System.String)">
            <summary>
            Sets the clipboard text
            </summary>
        </member>
        <member name="T:Sandbox.UI.Emoji">
            <summary>
            Helper class for working with Unicode emoji.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Emoji.FindEmoji(System.String)">
            <summary>
            Find a Unicode emoji from a <c>:emoji_name:</c> format.
            </summary>
            <param name="lookup">Input emoji text in <c>:emoji_name:</c> format.</param>
            <returns>The emoji or <see langword="null"/>.</returns>
        </member>
        <member name="T:Sandbox.UI.ImageRect">
            <summary>
            We share a lot of code between mask-image and background-image - so this handles all image rect calculations.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Layout.GridLayout">
            <summary>
            Layout objects in a grid
            </summary>
        </member>
        <member name="P:Sandbox.UI.Layout.GridLayout.ItemWidth">
            <summary>
            Fixed item width ( 1). Values set below 1 are clamped to 1.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Layout.GridLayout.ItemHeight">
            <summary>
            Fixed item height ( 1). Values set below 1 are clamped to 1.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Layout.GridLayout.Spacing">
            <summary>
            Gaps between cells. X = column gap, Y = row gap.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Layout.GridLayout.ScaleUp">
            <summary>
            If true, stretches cell width to be flush on the right edge and
            preserves aspect ratio by scaling height accordingly.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.GridLayout.Update(Sandbox.UI.Box,System.Single,System.Single)">
            <summary>
            Update layout state from the given box, scale, scroll, and justification.
            Returns true when internal state changed (i.e., layout is dirty).
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.GridLayout.GetVisibleRange(System.Int32@,System.Int32@)">
            <summary>
            Compute the visible index range [firstIndex, lastIndex).
            Uses the outer viewport height and compensates for inner top offset
            so top padding does not cull early rows.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.GridLayout.GetPosition(System.Int32)">
            <summary>
            Get the rectangle for the cell at the given index.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.GridLayout.Position(System.Int32,Sandbox.UI.Panel)">
            <summary>
            Apply the cell rectangle for <paramref name="index"/> to <paramref name="panel"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.GridLayout.GetHeight(System.Int32)">
            <summary>
            Calculate total content height for the given item count.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Layout.VerticalListLayout">
            <summary>
            Layout items in a vertical list
            </summary>
        </member>
        <member name="P:Sandbox.UI.Layout.VerticalListLayout.ItemHeight">
            <summary>
            Fixed item height ( 1).
            Values set below 1 are clamped to 1.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Layout.VerticalListLayout.Spacing">
            <summary>
            Gaps between items.
            X is ignored; Y is row gap.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.VerticalListLayout.Update(Sandbox.UI.Box,System.Single,System.Single)">
            <summary>
            Update layout state from the given box, scale, and scroll.
            Returns true when internal state changed.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.VerticalListLayout.GetVisibleRange(System.Int32@,System.Int32@)">
            <summary>
            Compute the visible index range [firstIndex, lastIndex).
            Compensates for inner top offset so top padding does not cull early items.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.VerticalListLayout.GetPosition(System.Int32)">
            <summary>
            Get the rectangle for the item at the given index.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.VerticalListLayout.Position(System.Int32,Sandbox.UI.Panel)">
            <summary>
            Apply the item rectangle for <paramref name="index"/> to <paramref name="panel"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Layout.VerticalListLayout.GetHeight(System.Int32)">
            <summary>
            Calculate total content height for the given item count.
            </summary>
        </member>
        <member name="T:Sandbox.UI.VirtualGrid">
            <summary>
            A virtualized, scrollable grid panel that only creates item panels when visible.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualGrid.Layout">
            <summary>
            Grid layout used to position/measure items. (Swappable later if needed.)
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualGrid.NeedsRebuild">
            <summary>
            When true, forces a layout rebuild on the next <see cref="M:Sandbox.UI.VirtualGrid.Tick"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualGrid.Item">
            <summary>
            Template used to render an item into a cell panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualGrid.OnCreateCell">
            <summary>
            Called when a cell is created. Allows you to fill the cell in
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualGrid.OnLastCell">
            <summary>
            Called when the last cell has been viewed. This allows you to view more.
            </summary>
        </member>
        <member name="M:Sandbox.UI.VirtualGrid.#ctor">
            <summary>
            Initializes a new <see cref="T:Sandbox.UI.VirtualGrid"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualGrid.ItemSize">
            <summary>
            Fixed width of each item. If &lt; 0, layout may stretch to fill width.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualGrid.Items">
            <summary>
            Replaces the current items. Only triggers a rebuild if the sequence is actually different.
            </summary>
        </member>
        <member name="M:Sandbox.UI.VirtualGrid.AddItem(System.Object)">
            <summary>
            Adds a single item and marks the grid for rebuild.
            </summary>
            <param name="item">The item to append.</param>
        </member>
        <member name="M:Sandbox.UI.VirtualGrid.AddItems(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Adds multiple items and marks the grid for rebuild.
            </summary>
            <param name="items">Items to append.</param>
        </member>
        <member name="M:Sandbox.UI.VirtualGrid.Clear">
            <summary>
            Clears all items and destroys created panels.
            </summary>
        </member>
        <member name="M:Sandbox.UI.VirtualGrid.Tick">
            <summary>
            Per-frame update: adjusts spacing from CSS, updates layout, creates/destroys visible panels.
            </summary>
        </member>
        <member name="M:Sandbox.UI.VirtualGrid.HasData(System.Int32)">
            <summary>
            Returns true if <paramref name="i"/> is a valid item index.
            </summary>
            <param name="i">Item index.</param>
            <returns>True if within bounds; otherwise false.</returns>
        </member>
        <member name="M:Sandbox.UI.VirtualGrid.FinalLayoutChildren(Vector2)">
            <summary>
            Final layout pass for child panels and scroll bounds.
            </summary>
            <param name="offset">Layout offset.</param>
        </member>
        <member name="M:Sandbox.UI.VirtualGrid.SetItems(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Convenience helper that sets <see cref="P:Sandbox.UI.VirtualGrid.Items"/>.
            </summary>
            <param name="enumerable">New items sequence.</param>
        </member>
        <member name="T:Sandbox.UI.VirtualList">
            <summary>
            A virtualized, scrollable grid panel that only creates item panels when visible.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualList.Layout">
            <summary>
            Grid layout used to position/measure items. (Swappable later if needed.)
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualList.NeedsRebuild">
            <summary>
            When true, forces a layout rebuild on the next <see cref="M:Sandbox.UI.VirtualList.Tick"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualList.Item">
            <summary>
            Template used to render an item into a cell panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualList.OnCreateCell">
            <summary>
            Called when a cell is created. Allows you to fill the cell in
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualList.OnLastCell">
            <summary>
            Called when the last cell has been viewed. This allows you to view more.
            </summary>
        </member>
        <member name="M:Sandbox.UI.VirtualList.#ctor">
            <summary>
            Initializes a new <see cref="T:Sandbox.UI.VirtualGrid"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualList.ItemHeight">
            <summary>
            Fixed width of each item. If &lt; 0, layout may stretch to fill width.
            </summary>
        </member>
        <member name="P:Sandbox.UI.VirtualList.Items">
            <summary>
            Replaces the current items. Only triggers a rebuild if the sequence is actually different.
            </summary>
        </member>
        <member name="M:Sandbox.UI.VirtualList.AddItem(System.Object)">
            <summary>
            Adds a single item and marks the grid for rebuild.
            </summary>
            <param name="item">The item to append.</param>
        </member>
        <member name="M:Sandbox.UI.VirtualList.AddItems(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Adds multiple items and marks the grid for rebuild.
            </summary>
            <param name="items">Items to append.</param>
        </member>
        <member name="M:Sandbox.UI.VirtualList.Clear">
            <summary>
            Clears all items and destroys created panels.
            </summary>
        </member>
        <member name="M:Sandbox.UI.VirtualList.Tick">
            <summary>
            Per-frame update: adjusts spacing from CSS, updates layout, creates/destroys visible panels.
            </summary>
        </member>
        <member name="M:Sandbox.UI.VirtualList.HasData(System.Int32)">
            <summary>
            Returns true if <paramref name="i"/> is a valid item index.
            </summary>
            <param name="i">Item index.</param>
            <returns>True if within bounds; otherwise false.</returns>
        </member>
        <member name="M:Sandbox.UI.VirtualList.FinalLayoutChildren(Vector2)">
            <summary>
            Final layout pass for child panels and scroll bounds.
            </summary>
            <param name="offset">Layout offset.</param>
        </member>
        <member name="M:Sandbox.UI.VirtualList.SetItems(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Convenience helper that sets <see cref="P:Sandbox.UI.VirtualList.Items"/>.
            </summary>
            <param name="enumerable">New items sequence.</param>
        </member>
        <member name="T:Sandbox.UI.WorldPanel">
            <summary>
            An interactive 2D panel rendered in the 3D world.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.SceneObject">
            <summary>
            Scene object that renders the panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.Transform">
            <summary>
            Transform of the world panel in 3D space.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.Tags">
            <summary>
            Tags that are applied to the underlying SceneObject
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.Position">
            <summary>
            Position of the world panel in 3D space.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.Rotation">
            <summary>
            Rotation of the world panel in 3D space.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.WorldScale">
            <summary>
            Scale of the world panel in 3D space.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.MaxInteractionDistance">
            <summary>
            Maximum distance at which a player can interact with this world panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.WorldPanel.UpdateBounds(Sandbox.Rect)">
            <summary>
            Update the bounds for this panel. We purposely do nothing here because
            on world panels you can change the bounds by setting <see cref="P:Sandbox.UI.RootPanel.PanelBounds"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.WorldPanel.UpdateScale(Sandbox.Rect)">
            <summary>
            We override this to prevent the scale automatically being set based on screen
            size changing.. because that's obviously not needed here.
            </summary>
        </member>
        <member name="T:Sandbox.UISystem">
            <summary>
            Holds onto a list of root panels to tick, input and draw
            </summary>
        </member>
        <member name="M:Sandbox.UISystem.AddDeferredDeletion(Sandbox.UI.Panel)">
            <summary>
            This panel should get deleted at some point
            </summary>
        </member>
        <member name="M:Sandbox.UISystem.RunDeferredDeletion(System.Boolean)">
            <summary>
            Delete all panels that were deferred and are no longer playing outro transitions
            </summary>
        </member>
        <member name="T:Sandbox.ScenePanelObject">
            <summary>
            Renders a panel in a scene world. You are probably looking for <a href="https://sbox.game/api/Sandbox.UI.WorldPanel">WorldPanel</a>.
            </summary>
        </member>
        <member name="F:Sandbox.ScenePanelObject.ScreenToWorldScale">
            <summary>
            Global scale for panel rendering within a scene world.
            </summary>
        </member>
        <member name="P:Sandbox.ScenePanelObject.Panel">
            <summary>
            The panel that will be rendered.
            </summary>
        </member>
        <member name="T:Sandbox.Compression.LZ4">
            <summary>
            Encode and decode LZ4 compressed data.
            </summary>
        </member>
        <member name="M:Sandbox.Compression.LZ4.CompressBlock(System.ReadOnlySpan{System.Byte})">
            <summary>
            Encode data as an LZ4 block.
            </summary>
            <param name="data">Input buffer</param>
            <returns>Compressed LZ4 block data</returns>
        </member>
        <member name="M:Sandbox.Compression.LZ4.DecompressBlock(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>
            Decode raw LZ4 block data.
            </summary>
            <param name="src">Input buffer, compressed LZ4 block data</param>
            <param name="dest">Output buffer, uncompressed</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Sandbox.Compression.LZ4.CompressFrame(System.ReadOnlySpan{System.Byte})">
            <summary>
            Encode data as an LZ4 frame.
            </summary>
            <param name="data">Input buffer</param>
            <returns>Compressed LZ4 frame data</returns>
        </member>
        <member name="M:Sandbox.Compression.LZ4.DecompressFrame(System.ReadOnlySpan{System.Byte})">
            <summary>
            Decode an LZ4 frame.
            </summary>
            <param name="data">Input buffer, compressed LZ4 frame data</param>
            <returns>Uncompressed data</returns>
        </member>
        <member name="T:Sandbox.Utility.EditorTools">
            <summary>
            Functions to interact with the tools system. Does nothing if tools aren't enabled.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.EditorTools.InspectorObject">
            <summary>
            Set the object to be inspected by the inspector in the editor
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Parallel">
            <summary>
            Wrappers of the parallel class.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Steam.CategorizeSteamId(Sandbox.SteamId)">
            <summary>
            Return what type os SteamId this is
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Steam.SteamId">
            <summary>
            The current user's SteamId
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Steam.PersonaName">
            <summary>
            The current user's persona name (Steam name)
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Steam.IsFriend(Sandbox.SteamId)">
            <summary>
            Return true if this is a friend
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Steam.IsOnline(Sandbox.SteamId)">
            <summary>
            Return true if this person is online
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.DownloadFile(System.String,System.String,System.Threading.CancellationToken,Sandbox.Utility.DataProgress.Callback)">
            <summary>
            Download a file to a target filename (todo - progress)
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.GrabFile(System.String,System.Threading.CancellationToken,System.Action{System.Int32})">
            <summary>
            Download a file to a byte array
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.DownloadString(System.String,System.Threading.CancellationToken)">
            <summary>
            Download a url to a string
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.DownloadJson``1(System.String,System.Threading.CancellationToken)">
            <summary>
            Download a url to a string
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.PutAsync(System.IO.Stream,System.String,System.Threading.CancellationToken,Sandbox.Utility.DataProgress.Callback)">
            <summary>
            Download a file to a target filename (todo - progress)
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.PathFillType">
            <summary>
            How to determine which sections of the path are filled.
            </summary>
        </member>
        <member name="F:Sandbox.Utility.Svg.PathFillType.Winding">
            <summary>
            Clockwise paths are filled, counter-clockwise are empty.
            </summary>
        </member>
        <member name="F:Sandbox.Utility.Svg.PathFillType.EvenOdd">
            <summary>
            Regions that are enclosed by an odd number of paths are filled, other regions are empty.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.PathArcSize">
            <summary>
            Controls arc size in <see cref="T:Sandbox.Utility.Svg.ArcToPathCommand"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.PathDirection">
            <summary>
            Controls arc direction in <see cref="T:Sandbox.Utility.Svg.ArcToPathCommand"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.PathCommand">
            <summary>
            Base class for SVG path commands.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddCirclePathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddCirclePathCommand.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddOvalPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/ellipse"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddOvalPathCommand.#ctor(Sandbox.Rect)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/ellipse"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddPolyPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline"/>, <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddPolyPathCommand.#ctor(System.Collections.Generic.IReadOnlyList{Vector2},System.Boolean)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline"/>, <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddRectPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddRectPathCommand.#ctor(Sandbox.Rect)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddRoundRectPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddRoundRectPathCommand.#ctor(Sandbox.Rect,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.ArcToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#arcs"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.ArcToPathCommand.#ctor(System.Single,System.Single,System.Single,Sandbox.Utility.Svg.PathArcSize,Sandbox.Utility.Svg.PathDirection,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#arcs"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.ClosePathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.CubicToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.CubicToPathCommand.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.LineToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.LineToPathCommand.#ctor(System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.MoveToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.MoveToPathCommand.#ctor(System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.QuadToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.QuadToPathCommand.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.SvgPath">
            <summary>
            A shape in a <see cref="T:Sandbox.Utility.Svg.SvgDocument"/>, described as a vector path.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.FillType">
            <summary>
            How to determine which sections of the path are filled.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.Commands">
            <summary>
            Description of how the path is constructed out of basic elements.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.IsEmpty">
            <summary>
            If true, this path has no commands.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.Bounds">
            <summary>
            Enclosing bounding box for this path.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.StrokeColor">
            <summary>
            Optional outline color for this path.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.FillColor">
            <summary>
            Optional fill color for this path.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.SvgDocument">
            <summary>
            Helper class for reading Scalable Vector Graphics files.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.SvgDocument.FromString(System.String)">
            <summary>
            Reads an SVG document from the given string, returning a list of path elements
            describing the shapes in the image.
            </summary>
            <param name="contents">SVG document contents.</param>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgDocument.Paths">
            <summary>
            List of all shapes in the document.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxEngineExtensions.AsFloatSpan(System.Span{System.Single})">
            <summary>
            Convert to a FloatSpan, which allows easy SIMD/AVX2 instructions
            </summary>
        </member>
        <member name="T:Sandbox.Event">
            <summary>
            The event system.
            </summary>
        </member>
        <member name="M:Sandbox.Event.UnregisterAssembly(System.Reflection.Assembly)">
            <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
        </member>
        <member name="M:Sandbox.Event.RegisterAssembly(System.Reflection.Assembly)">
            <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
        </member>
        <member name="M:Sandbox.Event.Register(System.Object)">
            <summary>
            Register an object to start receiving events
            </summary>
        </member>
        <member name="M:Sandbox.Event.Unregister(System.Object)">
            <summary>
            Unregister an object, stop reviving events
            </summary>
        </member>
        <member name="M:Sandbox.Event.Run(System.String)">
            <summary>
            Run an event.
            </summary>
        </member>
        <member name="M:Sandbox.Event.Run``1(System.String,``0)">
            <summary>
            Run an event with an argument of arbitrary type.
            </summary>
            <typeparam name="T">Arbitrary type for the argument.</typeparam>
            <param name="name">Name of the event to run.</param>
            <param name="arg0">Argument to pass down to event handlers.</param>
        </member>
        <member name="M:Sandbox.Event.Run``2(System.String,``0,``1)">
            <summary>
            Run an event with 2 arguments of arbitrary type.
            </summary>
            <typeparam name="T">Arbitrary type for the first argument.</typeparam>
            <typeparam name="U">Arbitrary type for the second argument.</typeparam>
            <param name="name">Name of the event to run.</param>
            <param name="arg0">First argument to pass down to event handlers.</param>
            <param name="arg1">Second argument to pass down to event handlers.</param>
        </member>
        <member name="M:Sandbox.Event.Run``3(System.String,``0,``1,``2)">
            <summary>
            Run an event with 3 arguments of arbitrary type.
            </summary>
            <typeparam name="T">Arbitrary type for the first argument.</typeparam>
            <typeparam name="U">Arbitrary type for the second argument.</typeparam>
            <typeparam name="V">Arbitrary type for the third argument.</typeparam>
            <param name="name">Name of the event to run.</param>
            <param name="arg0">First argument to pass down to event handlers.</param>
            <param name="arg1">Second argument to pass down to event handlers.</param>
            <param name="arg2">Third argument to pass down to event handlers.</param>
        </member>
        <member name="T:Sandbox.Event.Streamer">
            <summary>
            Stream API related events. See Sandbox.Streamer.
            </summary>
        </member>
        <member name="T:Sandbox.Event.Streamer.JoinChatAttribute">
            <summary>
            Event called when joined a chat
            </summary>
        </member>
        <member name="T:Sandbox.Event.Streamer.LeaveChatAttribute">
            <summary>
            Event called when left a chat
            </summary>
        </member>
        <member name="T:Sandbox.Event.Streamer.ChatMessageAttribute">
            <summary>
            Event called when chat message comes in
            </summary>
        </member>
        <member name="F:Sandbox.FixedUpdate.Frequency">
            <summary>
            How many times a second FixedUpdate runs
            </summary>
        </member>
        <member name="F:Sandbox.FixedUpdate.step">
            <summary>
            Accumulate frame time up until a maximum amount (maxSteps). While this value
            is above the <see cref="P:Sandbox.FixedUpdate.Delta"/> time we will invoke a fixed update.
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.RemoveAll">
            <summary>
            Remove all tags from the set.
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.Has(System.String)">
            <summary>
            Does this set have the specified tag?
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:Sandbox.ITagSet.Add(System.String)">
            <summary>
            Add a tag to the set.
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:Sandbox.ITagSet.Remove(System.String)">
            <summary>
            Remove a tag from the set.
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:Sandbox.ITagSet.Set(System.String,System.Boolean)">
            <summary>
            Add or remove this tag, based on state
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.TryGetAll">
            <summary>
            Try to get all tags in the set.
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.GetTokens">
            <summary>
            Try to get all tags in the set.
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.GetSuggested">
            <summary>
            Get all default tags for this set.
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.SetFrom(Sandbox.ITagSet)">
            <summary>
            Set the tags to match this other tag set
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.Add(Sandbox.ITagSet)">
            <summary>
            Add the tags from another set, to this set
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.Toggle(System.String)">
            <summary>
            If this tag is already here, remove it, else add it.
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.HasAny(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Does this set have any of the specified tag?
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.HasAny(Sandbox.ITagSet)">
            <inheritdoc cref="M:Sandbox.ITagSet.HasAny(System.Collections.Generic.IEnumerable{System.String})"/>
        </member>
        <member name="M:Sandbox.ITagSet.HasAny(System.String[])">
            <inheritdoc cref="M:Sandbox.ITagSet.HasAny(System.Collections.Generic.IEnumerable{System.String})"/>
        </member>
        <member name="M:Sandbox.ITagSet.HasAll(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Does this set have all of the specified tags?
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.HasAll(Sandbox.ITagSet)">
            <inheritdoc cref="M:Sandbox.ITagSet.HasAll(System.Collections.Generic.IEnumerable{System.String})"/>
        </member>
        <member name="M:Sandbox.ITagSet.HasAll(System.String[])">
            <inheritdoc cref="M:Sandbox.ITagSet.HasAll(Sandbox.ITagSet)"/>
        </member>
        <member name="M:Sandbox.ITagSet.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.ITagSet.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Sandbox.IJsonConvert">
            <summary>
            Allows writing JsonConverter in a more compact way, without having to pre-register them.
            </summary>
        </member>
        <member name="T:Sandbox.InterfaceConverter`1.Wrapper">
            <summary>
            A simple type value wrapper that indicates what type the value is.
            </summary>
            <param name="Type"></param>
            <param name="Value"></param>
        </member>
        <member name="M:Sandbox.InterfaceConverter`1.Wrapper.#ctor(System.String,System.Text.Json.JsonElement)">
            <summary>
            A simple type value wrapper that indicates what type the value is.
            </summary>
            <param name="Type"></param>
            <param name="Value"></param>
        </member>
        <member name="P:Sandbox.InterfaceConverter`1.Wrapper.Type">
            <summary></summary>
        </member>
        <member name="P:Sandbox.InterfaceConverter`1.Wrapper.Value">
            <summary></summary>
        </member>
        <member name="T:Sandbox.Json">
            <summary>
            A convenience JSON helper that handles <see cref="T:Sandbox.Resource"/> types for you.
            </summary>
        </member>
        <member name="M:Sandbox.Json.Initialize">
            <summary>
            Should be called on startup and when hotloading. 
            The reason for doing on hotloading is to clear all the types in JsonSerializableFactory
            </summary>
        </member>
        <member name="M:Sandbox.Json.Deserialize(System.String,System.Type)">
            <summary>
            Try to deserialize given source to given type.
            </summary>
        </member>
        <member name="M:Sandbox.Json.Deserialize``1(System.String)">
            <summary>
            Try to deserialize given source to given type.
            </summary>
        </member>
        <member name="M:Sandbox.Json.TryDeserialize(System.String,System.Type,System.Object@)">
            <summary>
            Try to deserialize given source to given type. Return true if it was a success
            </summary>
        </member>
        <member name="M:Sandbox.Json.TryDeserialize``1(System.String,``0@)">
            <summary>
            Try to deserialize given source to given type. Return true if it was a success
            </summary>
        </member>
        <member name="M:Sandbox.Json.Serialize(System.Object)">
            <summary>
            Serialize an object.
            </summary>
        </member>
        <member name="M:Sandbox.Json.ParseToJsonObject(System.String)">
            <summary>
            Parse some Json to a JsonObject
            </summary>
        </member>
        <member name="M:Sandbox.Json.ParseToJsonNode(System.String)">
            <summary>
            Parse some Json to a JsonNode
            </summary>
        </member>
        <member name="M:Sandbox.Json.ParseToJsonObject(System.Text.Json.Utf8JsonReader@)">
            <summary>
            Parse some Json to a JsonNode
            </summary>
        </member>
        <member name="M:Sandbox.Json.DeserializeToObject(System.Object,System.String)">
            <summary>
            Deserialize to this existing object
            </summary>
        </member>
        <member name="M:Sandbox.Json.ToNode(System.Object)">
            <summary>
            Serialize a single object to a JsonNode
            </summary>
        </member>
        <member name="M:Sandbox.Json.ToNode(System.Object,System.Type)">
            <summary>
            Serialize a single object to a JsonNode with the given expected type
            </summary>
        </member>
        <member name="M:Sandbox.Json.FromNode(System.Text.Json.Nodes.JsonNode,System.Type)">
            <summary>
            Deserialize a single object to a type
            </summary>
        </member>
        <member name="M:Sandbox.Json.FromNode``1(System.Text.Json.Nodes.JsonNode)">
            <summary>
            Deserialize a single object to a type
            </summary>
        </member>
        <member name="M:Sandbox.Json.SerializeAsObject(System.Object)">
            <summary>
            Serialize this object property by property - even if JsonConvert has other plans
            </summary>
        </member>
        <member name="M:Sandbox.Json.WalkJsonTree(System.Text.Json.Nodes.JsonNode,System.Func{System.String,System.Text.Json.Nodes.JsonValue,System.Text.Json.Nodes.JsonNode},System.Func{System.String,System.Text.Json.Nodes.JsonObject,System.Text.Json.Nodes.JsonObject})">
            <summary>
            Deep walk though an entire Json tree, optionally changing values of nodes.
            </summary>
        </member>
        <member name="T:Sandbox.Json.ObjectIdentifier">
            <summary>
            Uniquely identifies a tracked object by its type and identifier value.
            </summary>
        </member>
        <member name="T:Sandbox.Json.PropertyOverride">
            <summary>
            Represents a property change to apply during patching.
            </summary>
        </member>
        <member name="F:Sandbox.Json.PropertyOverride.Target">
            <summary>The object whose property should be modified</summary>
        </member>
        <member name="F:Sandbox.Json.PropertyOverride.Property">
            <summary>The name of the property to modify</summary>
        </member>
        <member name="F:Sandbox.Json.PropertyOverride.Value">
            <summary>The new value to assign to the property</summary>
        </member>
        <member name="T:Sandbox.Json.AddedObject">
            <summary>
            Represents an object that needs to be added during patching.
            </summary>
        </member>
        <member name="F:Sandbox.Json.AddedObject.Id">
            <summary>The identifier for the new object</summary>
        </member>
        <member name="F:Sandbox.Json.AddedObject.Parent">
            <summary>The parent object that will contain this object</summary>
        </member>
        <member name="F:Sandbox.Json.AddedObject.PreviousElement">
            <summary>The previous sibling when adding to an array (null if first or not in array)</summary>
        </member>
        <member name="F:Sandbox.Json.AddedObject.ContainerProperty">
            <summary>The property name in the parent that will contain this object</summary>
        </member>
        <member name="F:Sandbox.Json.AddedObject.IsContainerArray">
            <summary>Whether this object is being added to an array (true) or as a direct property (false)</summary>
        </member>
        <member name="F:Sandbox.Json.AddedObject.Data">
            <summary>The data for the new object</summary>
        </member>
        <member name="T:Sandbox.Json.RemovedObject">
            <summary>
            Represents an object that should be removed during patching.
            </summary>
        </member>
        <member name="F:Sandbox.Json.RemovedObject.Id">
            <summary>The identifier of the object to remove</summary>
        </member>
        <member name="T:Sandbox.Json.MovedObject">
            <summary>
            Represents an object that should be moved to a new location during patching.
            </summary>
        </member>
        <member name="F:Sandbox.Json.MovedObject.Id">
            <summary>The identifier of the object to move</summary>
        </member>
        <member name="F:Sandbox.Json.MovedObject.NewParent">
            <summary>The new parent object</summary>
        </member>
        <member name="F:Sandbox.Json.MovedObject.NewContainerProperty">
            <summary>The property name in the new parent that will contain this object</summary>
        </member>
        <member name="F:Sandbox.Json.MovedObject.IsNewContainerArray">
            <summary>Whether the object is being moved to an array (true) or as a direct property (false)</summary>
        </member>
        <member name="F:Sandbox.Json.MovedObject.NewPreviousElement">
            <summary>The previous sibling in the new location (null if first or not in array)</summary>
        </member>
        <member name="T:Sandbox.Json.TrackedObjectDefinition">
            <summary>
            Defines characteristics of an object type that should be tracked within a JSON tree structure.
            These definitions are used to identify, track, and manage specific types of objects during JSON diffing and patching operations.
            </summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObjectDefinition.Type">
            <summary>
            A unique identifier for this object type. This is used to categorize objects.
            </summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObjectDefinition.MatchScore">
            <summary>
            Determines whether a JSON object should be considered an instance of this tracked object type.
            </summary>
            <remarks>
            The function returns a float value indicating how well the JSON object matches this definition.
            A return value of 0 indicates no match, while higher values indicate stronger matches.
            This allows for heuristic-based matching when exact matches aren't possible.
            </remarks>
        </member>
        <member name="F:Sandbox.Json.TrackedObjectDefinition.ToId">
            <summary>
            Maps a JSON object to a unique identifier string.
            </summary>
            <remarks>
            The identifier could be derived from a specific property, a combination of properties, or a computed hash.
            It's critical that this function:
            1. Produces a truly unique value for each distinct object of this type
            2. Never maps two different objects to the same ID
            3. Is deterministic - always returns the same ID when applied to the same object
            
            If you can just use a UUID or other guaranteed unique identifier.
            </remarks>
        </member>
        <member name="F:Sandbox.Json.TrackedObjectDefinition.ParentType">
            <summary>
            Specifies the required type of the parent object. If null, AllowedAsRoot must be true.
            </summary>
            <remarks>
            This enforces type hierarchy constraints within the JSON structure.
            </remarks>
        </member>
        <member name="F:Sandbox.Json.TrackedObjectDefinition.AllowedAsRoot">
            <summary>
            If true, objects of this type can be the root of the object tree.
            </summary>
            <remarks>
            Root objects don't require a parent, and they don't need an ID since there can only be one root.
            If AllowedAsRoot is false, ParentType must be specified.
            </remarks>
        </member>
        <member name="F:Sandbox.Json.TrackedObjectDefinition.Atomic">
            <summary>
            When true, treats this object as an atomic unit during tracking operations.
            </summary>
            <remarks>
            Objects with AtomicTracking enabled:
            1. Have their children excluded from individual tracking
            2. Skip property-level diffing (changes are handled as whole object replacements)
            3. Are treated as "black boxes" where internal structure is ignored
            
            This is useful for:
            - Objects containing data that shouldn't be tracked independently (like patches)
            - Preventing recursive tracking of complex nested structures
            </remarks>
        </member>
        <member name="M:Sandbox.Json.TrackedObjectDefinition.CreatePresenceBasedDefinition(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a TrackedObjectDefinition that identifies objects based on the presence of specific fields.
            </summary>
        </member>
        <member name="T:Sandbox.Json.TrackedObject">
            <summary>
            Represents a tracked object in a JSON tree with metadata for diffing and patching operations.
            </summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObject.Id">
            <summary>The unique identifier for this object</summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObject.Definition">
            <summary>The defintion taht was used to track this object.</summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObject.Data">
            <summary>The object's JSON data without its children</summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObject.Parent">
            <summary>Reference to this object's parent (null for root objects)</summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObject.ContainerProperty">
            <summary>The property name in parent that contains this object</summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObject.IsContainedInArray">
            <summary>Whether this object is contained in an array (true) or as a direct property (false)</summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObject.PreviousElement">
            <summary>The previous sibling element when contained in an array (null if first or not in array)</summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObject.Path">
            <summary>The path to this object in the JSON structure</summary>
        </member>
        <member name="F:Sandbox.Json.TrackedObject.Children">
            <summary>Child objects belonging to this object</summary>
        </member>
        <member name="M:Sandbox.Json.TrackedObject.ToJson">
            <summary>
            Reconstructs a complete JSON tree from this object and all its children.
            </summary>
        </member>
        <member name="T:Sandbox.Json.Patch">
            <summary>
            Represents a complete set of changes to be applied to a JSON structure.
            </summary>
            <remarks>
            A patch contains all the operations needed to transform one JSON structure into another
            while preserving object identity and relationships.
            </remarks>
        </member>
        <member name="P:Sandbox.Json.Patch.AddedObjects">
            <summary>
            Objects that need to be added to the target structure.
            </summary>
        </member>
        <member name="P:Sandbox.Json.Patch.RemovedObjects">
            <summary>
            Objects that need to be removed from the target structure.
            </summary>
        </member>
        <member name="P:Sandbox.Json.Patch.PropertyOverrides">
            <summary>
            Property values that need to be changed on existing objects.
            </summary>
        </member>
        <member name="P:Sandbox.Json.Patch.MovedObjects">
            <summary>
            Objects that need to be moved to a different location in the structure.
            </summary>
        </member>
        <member name="M:Sandbox.Json.CalculateDifferences(System.Text.Json.Nodes.JsonObject,System.Text.Json.Nodes.JsonObject,System.Collections.Generic.HashSet{Sandbox.Json.TrackedObjectDefinition})">
            <summary>
            Compares two JSON object trees and calculates the differences between them.
            </summary>
            <param name="oldRoot">The original JSON object tree</param>
            <param name="newRoot">The updated JSON object tree</param>
            <param name="definitions">Set of definitions for tracked object types in the JSON structure</param>
            <returns>A Patch object containing all changes needed to transform oldRoot into newRoot</returns>
        </member>
        <member name="M:Sandbox.Json.ApplyPatch(System.Text.Json.Nodes.JsonObject,Sandbox.Json.Patch,System.Collections.Generic.HashSet{Sandbox.Json.TrackedObjectDefinition})">
            <summary>
            Applies a patch to transform a JSON object tree, with support for partial patch application
            when the source tree has been modified after the patch was created.
            </summary>
            <param name="sourceRoot">The JSON object tree to modify</param>
            <param name="patch">The patch containing all changes to apply</param>
            <param name="definitions">Set of definitions for tracked object types</param>
            <returns>A new JSON object tree with all applicable changes applied</returns>
            <remarks>
            Partial patch application semantics:
            
            Object Removal:
            - Skipped if object doesn't exist in source
            - Proceeds if object exists even if parent has changed
            
            Object Addition:
            - Only added if parent exists in source
            - Skipped if parent is missing
            
            Object Moves:
            - Requires both object and target parent to exist
            - Object is removed if target parent doesn't exist
            
            Property Overrides:
            - Only applied if target object exists
            
            Array Ordering:
            - Best effort based on neighbourhood information (previous element)
            - Objects without previous elements are placed at start
            
            Operations are processed in this order: removals, additions, moves,
            reordering, and finally property overrides.
            </remarks>
        </member>
        <member name="M:Sandbox.Json.AppendToPath(System.String,System.String)">
            <summary>
            Helper method to append a property name to a path string
            </summary>
        </member>
        <member name="M:Sandbox.Json.AppendToPath(System.String,System.Int32)">
            <summary>
            Helper method to append an array index to a path string
            </summary>
        </member>
        <member name="T:Sandbox.Json.Pointer">
            <summary>
            Represents a JSON Pointer as defined in RFC 6901.
            </summary>
        </member>
        <member name="P:Sandbox.Json.Pointer.ReferenceTokens">
            <summary>
            The reference tokens that make up the JSON Pointer.
            </summary>
        </member>
        <member name="F:Sandbox.Json.Pointer.Root">
            <summary>
            A static instance representing the root JSON Pointer (i.e., "/").
            </summary>
        </member>
        <member name="M:Sandbox.Json.Pointer.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Sandbox.Json.Pointer"/> class with the specified string.
            </summary>
            <param name="value">The string value of the JSON Pointer.</param>
        </member>
        <member name="M:Sandbox.Json.Pointer.#ctor(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Sandbox.Json.Pointer"/> class with the specified tokens.
            </summary>
            <param name="tokens">The tokens that make up the JSON Pointer.</param>
        </member>
        <member name="M:Sandbox.Json.Pointer.Append(System.String)">
            <summary>
            Appends a token to the JSON Pointer and returns a new <see cref="T:Sandbox.Json.Pointer"/>.
            </summary>
            <param name="token">The token to append.</param>
            <returns>A new <see cref="T:Sandbox.Json.Pointer"/> with the appended token.</returns>
        </member>
        <member name="M:Sandbox.Json.Pointer.Append(System.Int32)">
            <summary>
            Appends an integer index as a token to the JSON Pointer and returns a new <see cref="T:Sandbox.Json.Pointer"/>.
            </summary>
            <param name="index">The integer index to append.</param>
            <returns>A new <see cref="T:Sandbox.Json.Pointer"/> with the appended index.</returns>
        </member>
        <member name="M:Sandbox.Json.Pointer.GetParent">
            <summary>
            Returns a new <see cref="T:Sandbox.Json.Pointer"/> representing the parent of the current pointer.
            </summary>
            <returns>A new <see cref="T:Sandbox.Json.Pointer"/> for the parent path.</returns>
        </member>
        <member name="T:Sandbox.Json.PointerJsonConverter">
            <summary>
            Custom JSON converter for the Pointer class that serializes a Pointer as a string
            and deserializes a string back into a Pointer using the Parse method.
            </summary>
        </member>
        <member name="M:Sandbox.Json.PopulateReflectionCache(Sandbox.Internal.TypeLibrary)">
            <summary>
            Try to do any reflection / code gen immediately, so we don't do anything too slow during gameplay.
            </summary>
        </member>
        <member name="T:Sandbox.IJsonPopulator">
            <summary>
            Objects that need to be deserialized into can implement this interface
            which allows them to be populated from a JSON object.
            </summary>
        </member>
        <member name="M:Sandbox.JsonUpgrader.Upgrade(System.Int32,System.Text.Json.Nodes.JsonObject,System.Type)">
            <summary>
            Runs through all upgraders that match its class where our version is lower than the specified version.
            </summary>
            <param name="version">The current version that's serialized in the json object</param>
            <param name="json"></param>
            <param name="targetType"></param>
        </member>
        <member name="T:Sandbox.FloatSpan">
            <summary>
            Allows easy SIMD/AVX2 fast math on a span of floats
            </summary>
        </member>
        <member name="M:Sandbox.FloatSpan.Max">
            <summary>
            Uses SIMD/AVX2 to find the maximum value in a span of floats.
            </summary>
        </member>
        <member name="M:Sandbox.FloatSpan.Min">
            <summary>
            Uses SIMD/AVX2 to find the minimum value in a span of floats.
            </summary>
        </member>
        <member name="T:Sandbox.Metadata">
            <summary>
            A simple class for storing and retrieving metadata values.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.Deserialize(System.String)">
            <summary>
            Deserialize metadata from a JSON string.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.Serialize">
            <summary>
            Serialize the metadata to a JSON string.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.SetValue(System.String,System.Object)">
            <summary>
            Set a value with the specified key.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.TryGetValue``1(System.String,``0@)">
            <summary>
            Try to get a value of the specified type.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.GetValueOrDefault``1(System.String,``0)">
            <summary>
            Get the a value. If it's missing or the wrong type then use the default value.
            </summary>
        </member>
        <member name="T:Sandbox.Mouse">
            <summary>
            Gives access to mouse position etc
            </summary>
        </member>
        <member name="M:Sandbox.Mouse.Frame">
            <summary>
            Called once per frame
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.Position">
            <summary>
            Access to local clients' cursor position, relative to game windows' top left corner.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.Delta">
            <summary>
            Change in local clients' cursor position since last frame.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.CursorType">
            <summary>
            Sets the cursor type until another panel stomps this value.
            Doesn't affect main menu.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.Active">
            <summary>
            Whether the local clients' cursor is active or not, meaning it can interact with UI elements, etc.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.Visible">
            <summary>
            DEPRECATED. Use Mouse.Visibility instead.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.Visibility">
            <summary>
            The visibility state of the mouse cursor. Auto will only show the mouse when clickable UI elements are visible.
            </summary>
        </member>
        <member name="T:Sandbox.MouseVisibility">
            <summary>
            The visibility state of the mouse cursor.
            </summary>
        </member>
        <member name="F:Sandbox.MouseVisibility.Visible">
            <summary>
            The mouse is visible and can interact with UI elements.
            </summary>
        </member>
        <member name="F:Sandbox.MouseVisibility.Auto">
            <summary>
            The mouse is only visible when UI elements with `pointer-events: auto` are on-screen.
            </summary>
        </member>
        <member name="F:Sandbox.MouseVisibility.Hidden">
            <summary>
            The mouse is locked to the game and cannot interact with UI elements.
            </summary>
        </member>
        <member name="T:Sandbox.ReflectionQueryCache">
            <summary>
            We cache results for some expensive reflection queries.
            This results in large performance improvements during various operations (Cloning, NetworkSpawn, Serilization...)
            </summary>
        </member>
        <member name="M:Sandbox.ReflectionQueryCache.ClearTypeCache">
            <summary>
            Clears the type cache, called after HotLoad and after a game ended.
            Called from EditorUtilities.ClearCloneTypeCache and Game.Close
            </summary>
        </member>
        <member name="M:Sandbox.ReflectionQueryCache.OrderedSerializableMembers(System.Type)">
            <summary>
            Returns all properties and fields that should be (de)serialized.
            Also sorts the members for historic reasons.
            </summary>
        </member>
        <member name="M:Sandbox.ReflectionQueryCache.RequiredComponentMembers(System.Type)">
            <summary>
            Returns all properties that have a [RequireComponent] attribute.
            </summary>
        </member>
        <member name="M:Sandbox.ReflectionQueryCache.SyncProperties(System.Type)">
            <summary>
            Returns all properties that have a [Sync] attribute.
            </summary>
        </member>
        <member name="M:Sandbox.ReflectionQueryCache.IsTypeCloneableByCopy(System.Type)">
            <summary>
            Determines if a type can be cloned by a simple copy.
            This recursively walks through all properties and fields of the type to determine if they are cloneable by copy.
            Since this is fairly expensive, we cache the results for each type.
            </summary>
        </member>
        <member name="T:Sandbox.Screen">
            <summary>
            Access screen dimension etc.
            </summary>
        </member>
        <member name="P:Sandbox.Screen.Size">
            <summary>
            The total size of the game screen
            </summary>
        </member>
        <member name="P:Sandbox.Screen.Width">
            <summary>
            The width of the game screen. Equal to Screen.x
            </summary>
        </member>
        <member name="P:Sandbox.Screen.Height">
            <summary>
            The height of the game screen. Equal to Screen.y
            </summary>
        </member>
        <member name="P:Sandbox.Screen.Aspect">
            <summary>
            The aspect ratio of the screen. Equal to Width/Height
            </summary>
        </member>
        <member name="P:Sandbox.Screen.DesktopScale">
            <summary>
            The desktop's dpi scale on the current monitor.
            </summary>
        </member>
        <member name="M:Sandbox.Screen.CreateVerticalFieldOfView(System.Single)">
            <summary>
            Converts a vertical field of view to a horizontal field of view based on the screen aspect ratio.
            </summary>
        </member>
        <member name="M:Sandbox.Screen.CreateVerticalFieldOfView(System.Single,System.Single)">
            <summary>
            Converts a vertical field of view to a horizontal field of view based on the given aspect ratio.
            </summary>
        </member>
        <member name="M:Sandbox.TagSet.GetTokens">
            <summary>
            Returns a list of ints, representing the tags. These are used internally by the engine.
            </summary>
        </member>
        <member name="P:Sandbox.Time.Now">
            <summary>
            The time since game startup
            </summary>
        </member>
        <member name="P:Sandbox.Time.Delta">
            <summary>
            The delta between the last frame and the current (for all intents and purposes)
            </summary>
        </member>
        <member name="T:Sandbox.TimeSince">
            <summary>
            A convenience struct to easily measure time since an event last happened, based on <see cref="P:Sandbox.Time.Now"/>.<br/>
            <br/>
            Typical usage would see you assigning 0 to a variable of this type to reset the timer.
            Then the struct would return time since the last reset. i.e.:
            <code>
            TimeSince lastUsed = 0;
            if ( lastUsed > 10 ) { /*Do something*/ }
            </code>
            </summary>
        </member>
        <member name="P:Sandbox.TimeSince.Absolute">
            <summary>
            Time at which the timer reset happened, based on <see cref="P:Sandbox.Time.Now"/>.
            </summary>
        </member>
        <member name="P:Sandbox.TimeSince.Relative">
            <summary>
            Time passed since last reset, in seconds.
            </summary>
        </member>
        <member name="T:Sandbox.TimeUntil">
            <summary>
            A convenience struct to easily manage a time countdown, based on <see cref="P:Sandbox.Time.Now"/>.<br/>
            <br/>
            Typical usage would see you assigning to a variable of this type a necessary amount of seconds.
            Then the struct would return the time countdown, or can be used as a bool i.e.:
            <code>
            TimeUntil nextAttack = 10;
            if ( nextAttack ) { /*Do something*/ }
            </code>
            </summary>
        </member>
        <member name="P:Sandbox.TimeUntil.Absolute">
            <summary>
            Time to which we are counting down to, based on <see cref="P:Sandbox.Time.Now"/>.
            </summary>
        </member>
        <member name="P:Sandbox.TimeUntil.Relative">
            <summary>
            The actual countdown, in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.TimeUntil.Passed">
            <summary>
            Amount of seconds passed since the countdown started.
            </summary>
        </member>
        <member name="P:Sandbox.TimeUntil.Fraction">
            <summary>
            The countdown, but as a fraction, i.e. a value from 0 (start of countdown) to 1 (end of countdown)
            </summary>
        </member>
        <member name="M:Sandbox.TokenBasedTagSet.GetTokens">
            <summary>
            Try to get all tags in the set.
            </summary>
        </member>
        <member name="M:Sandbox.VoiceManager.Uncompress(System.Byte[],System.Action{System.Memory{System.Int16}})">
            <summary>
            Uncompress a voice buffer and call ondata with the result
            </summary>
        </member>
        <member name="T:Sandbox.WebSocket">
            <summary>
            A WebSocket client for connecting to external services.
            </summary>
            <remarks>
            Events handlers will be called on the synchronization context that Connect was called on.
            </remarks>
        </member>
        <member name="T:Sandbox.WebSocket.MessageReceivedHandler">
            <summary>
            Event handler which processes text messages from the WebSocket service.
            </summary>
            <param name="message">The message text that was received.</param>
        </member>
        <member name="T:Sandbox.WebSocket.DataReceivedHandler">
            <summary>
            Event handler which processes binary messages from the WebSocket service.
            </summary>
            <param name="data">The binary message data that was received.</param>
        </member>
        <member name="T:Sandbox.WebSocket.DisconnectedHandler">
            <summary>
            Event handler which fires when the WebSocket disconnects from the server.
            </summary>
            <param name="status">The close status code from the server, or 0 if there was none. See known values here: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</param>
            <param name="reason">The reason string for closing the connection. This may not be populated, may be from the server, or may be a client exception message.</param>
        </member>
        <member name="P:Sandbox.WebSocket.IsConnected">
            <summary>
            Returns true as long as a WebSocket connection is established.
            </summary>
        </member>
        <member name="P:Sandbox.WebSocket.SubProtocol">
            <summary>
            Get the sub-protocol that was negotiated during the opening handshake.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnMessageReceived">
            <summary>
            Event which fires when a text message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnDataReceived">
            <summary>
            Event which fires when a binary message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnDisconnected">
            <summary>
            Event which fires when the connection to the WebSocket service is lost, for any reason.
            </summary>
        </member>
        <member name="P:Sandbox.WebSocket.EnableCompression">
            <summary>
            Enable or disable compression for the websocket. If the server supports it, compression will be enabled for all messages.
            Note: compression is disabled by default, and can be dangerous if you are sending secrets across the network.
            </summary>
        </member>
        <member name="M:Sandbox.WebSocket.#ctor(System.Int32)">
            <summary>
            Initialized a new WebSocket client.
            </summary>
            <param name="maxMessageSize">The maximum message size to allow from the server, in bytes. Default 64 KiB.</param>
        </member>
        <member name="M:Sandbox.WebSocket.Dispose">
            <summary>
            Cleans up resources used by the WebSocket client. This will also immediately close the connection if it is currently open.
            </summary>
        </member>
        <member name="M:Sandbox.WebSocket.AddSubProtocol(System.String)">
            <summary>
            Add a sub-protocol to be negotiated during the WebSocket connection handshake.
            </summary>
            <param name="protocol"></param>
        </member>
        <member name="M:Sandbox.WebSocket.Connect(System.String,System.Threading.CancellationToken)">
            <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
            <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
            <param name="ct">A <see cref="T:System.Threading.CancellationToken"/> which allows the connection attempt to be aborted if necessary.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the connection is established, or throws if it failed to connect.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Connect(System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
            <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
            <param name="headers">Headers to send with the connection request.</param>
            <param name="ct">A <see cref="T:System.Threading.CancellationToken"/> which allows the connection attempt to be aborted if necessary.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the connection is established, or throws if it failed to connect.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.String)">
            <summary>
            Sends a text message to the WebSocket server.
            </summary>
            <param name="message">The message text to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.Byte[])">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <remarks>
            The <see cref="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})"/> and <see cref="M:Sandbox.WebSocket.Send(System.Span{System.Byte})"/> overloads allow sending subsections of byte arrays.
            </remarks>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.Span{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="T:Sandbox.WebSurface">
            <summary>
            Enables rendering and interacting with a webpage
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.OnTexture">
            <summary>
            Called when the texture has changed and should be updated
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.Url">
            <summary>
            The current Url
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.CheckUrlIsAllowed(System.Uri)">
            <summary>
            Is this URL allowed
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.Size">
            <summary>
            The size of the browser
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.OnNeedsRepaint(Steamworks.Data.HTML_NeedsPaint_t)">
            <summary>
            Invoked when the browser needs to be repainted
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.OnStartRequest(Steamworks.Data.HTML_StartRequest_t)">
            <summary>
            A navigation has happened, allow or deny it
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:Sandbox.WebSurface.OnURLChanged(Steamworks.Data.HTML_URLChanged_t)">
            <summary>
            Invoked when the browser is navigating to a new url
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Sandbox.WebSurface.TellMouseMove(Vector2)">
            <summary>
            Tell the browser the mouse has moved
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.TellMouseWheel(System.Int32)">
            <summary>
            Tell the browser the mouse wheel has moved
            </summary>
            <param name="delta"></param>
        </member>
        <member name="M:Sandbox.WebSurface.TellMouseButton(Sandbox.MouseButtons,System.Boolean)">
            <summary>
            Tell the browser a mouse button has been pressed
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.TellChar(System.UInt32,Sandbox.KeyboardModifiers)">
            <summary>
            Tell the browser a unicode key has been pressed
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.TellKey(System.UInt32,Sandbox.KeyboardModifiers,System.Boolean)">
            <summary>
            Tell the browser a key has been pressed or released
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.HasKeyFocus">
            <summary>
            Tell the html control if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.ScaleFactor">
            <summary>
            DPI Scaling factor
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.InBackgroundMode">
            <summary>
            Enable/disable low-resource background mode, where javascript and repaint timers are throttled, resources are
            more aggressively purged from memory, and audio/video elements are paused. When background mode is enabled,
            all HTML5 video and audio objects will execute ".pause()" and gain the property "._steam_background_paused = 1".
            When background mode is disabled, any video or audio objects with that property will resume with ".play()".
            </summary>
        </member>
        <member name="T:Sandbox.Http">
            <summary>
            Lets your game make async HTTP requests.
            </summary>
        </member>
        <member name="P:Sandbox.Http.IsLocalAllowed">
            <summary>
            We shouldn't blindly let users opt into local http.
            But it's okay for editor, dedicated servers and standalone.
            </summary>
        </member>
        <member name="M:Sandbox.Http.IsAllowed(System.Uri)">
            <summary>
            Check if the given Uri matches the following requirements:
            1. Scheme is https/http or wss/ws
            2. If it's localhost, only allow ports 80/443/8080/8443
            3. Not an ip address
            </summary>
            <param name="uri">The Uri to check.</param>
            <returns>True if the Uri can be accessed, false if the Uri will be blocked.</returns>
        </member>
        <member name="M:Sandbox.Http.IsHeaderAllowed(System.String)">
            <summary>
            Checks if a given header is allowed to be set.
            </summary>
            <param name="header">The header name to check.</param>
            <returns>True if the header is allowed to be set.</returns>
        </member>
        <member name="M:Sandbox.Http.RequestStringAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Send a HTTP request to the specified URI and return the response body as a string in an asynchronous operation.
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to the response body as a string.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.RequestBytesAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Send a HTTP request to the specified URI and return the response body as a byte array in an asynchronous operation.
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to the response body as a byte array.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.RequestStreamAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Send a HTTP request to the specified URI and return the response body as a stream in an asynchronous operation.
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to the response body as a <see cref="T:System.IO.Stream"/>.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.RequestJsonAsync``1(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Sends a HTTP request to the specified URI and return the response body as a JSON deserialized object in an asynchronous operation.
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to the response body deserialized from JSON.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.RequestAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Sends a HTTP request to the specified URI and returns the response in an asynchronous operation. 
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to a <see cref="T:System.Net.Http.HttpResponseMessage"/> containing the response for the request.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.CreateJsonContent``1(``0)">
            <summary>
            Creates a new <see cref="T:System.Net.Http.HttpContent"/> instance containing the specified object serialized to JSON.
            </summary>
        </member>
        <member name="T:NativeEngine.CreateInterface">
            <summary>
            Mimmicks the engine internal CreateInterface system, allowing us to 
            get the interfaces without asking native.
            </summary>
        </member>
        <member name="P:NativeEngine.InputEvent.IsButtonPress">
            <summary>
            True if this is as a result of a button being pressed
            </summary>
        </member>
        <member name="P:NativeEngine.InputEvent.IsGameButton">
            <summary>
            We let some button presses skip the UI completely. These can then be used as key binds that
            can always run. We mainly do this with the F keys.
            </summary>
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.SHOULD_BE_DELETED_BEFORE_WORLD">
            For objects that can't be considered to be "owned" by the world they are in because they
            are owned by a manager. All this flag does is cause a warning when such an object is still
            in the world at world deletion time (a leak).
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.OWNED_BY_ANOTHER_SCENEOBJECT">
            if this flag is set, then the object will not be deleted when deleting the world, and will not be queued for delete. It's assumed that this object is going to be deleted inside of the destructor of another sceneobject
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.PARTIALLY_ALPHA_BLENDED">
            We have a mixture of alpha-blended and non-alpha blended draws
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.UNIQUE_BATCH_GROUP">
            A unique batch flag that allows objects to draw in a separate batch from their original group
        </member>
        <member name="F:NativeEngine.SceneSystemWellKnownRenderTargetID.SCENE_RTGT_SCRATCH_TEXTURE_8888">
            <summary>
            a scratch render target texture for use for monitor rendering and other temp storage
            </summary>
        </member>
        <member name="T:NativeEngine.HMaterial">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:NativeEngine.IndexBufferHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:NativeEngine.RenderBufferHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:NativeEngine.RenderInputLayout_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:NativeEngine.RenderShaderHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:NativeEngine.VertexBufferHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="M:NativeEngine.TextureCreationConfig_t.GetWithFixes">
            <summary>
            Get a version of this config with some fixes applied, to reduce the chance of runtime errors.
            </summary>
        </member>
        <member name="T:FBMGammaType_t">
            <summary>
            from FloatBitmap 
            </summary>
        </member>
        <member name="P:NetCore.NativeDllPath">
            <summary>
            Interop will try to load dlls from this path, e.g bin/win64/
            </summary>
        </member>
        <member name="M:NetCore.InitializeInterop(System.String)">
            <summary>
            From here we'll open the native dlls and inject our function pointers into them,
            and retrieve function pointers from them.
            </summary>
        </member>
        <member name="T:ConditionalVisibilityAttribute">
            <summary>
            Hide a property if a condition matches.
            </summary>
        </member>
        <member name="M:ConditionalVisibilityAttribute.TestCondition(System.Object,Sandbox.TypeDescription)">
            <summary>
            The test condition.
            </summary>
            <param name="targetObject">The class instance of the property this attribute is attached to.</param>
            <param name="td">Description of the <paramref name="targetObject"/>'s type.</param>
            <returns>Return true if the property should be visible.</returns>
        </member>
        <member name="T:HideIfAttribute">
            <summary>
            Hide this property if a given property within the same class has the given value. Used typically in the Editor Inspector.
            </summary>
        </member>
        <member name="P:HideIfAttribute.PropertyName">
            <summary>
            Property name to test.
            </summary>
        </member>
        <member name="P:HideIfAttribute.Value">
            <summary>
            Property value to test against.
            </summary>
        </member>
        <member name="T:ShowIfAttribute">
            <summary>
            Show this property if a given property within the same class has the given value. Used typically in the Editor Inspector.
            </summary>
        </member>
        <member name="T:Editor.MetaDataAttribute">
            <summary>
            Base attribute which allows adding FGD metadata to classes.
            </summary>
        </member>
        <member name="T:Editor.FieldMetaDataAttribute">
            <summary>
            Base attribute which allows adding metadata to properties.
            </summary>
        </member>
        <member name="T:Editor.HidePropertyAttribute">
            <summary>
            A way to hide properties from parent classes in tools.
            </summary>
        </member>
        <member name="M:Editor.HidePropertyAttribute.#ctor(System.String)">
            <param name="internal_name">The internal/fgd name to skip. Usually all lowercase and with underscores (_) instead of spaces.</param>
        </member>
        <member name="T:Editor.EnableColorAlphaAttribute">
            <summary>
            If used on a Color or Color32 property, enables alpha modification in editors.
            </summary>
        </member>
        <member name="T:Editor.HammerEntityAttribute">
            <summary>
            This is an entity that can be placed in Hammer.
            </summary>
        </member>
        <member name="T:Editor.SolidAttribute">
            <summary>
            This is a brush based entity class. It can only be a mesh tied to an entity.
            </summary>
        </member>
        <member name="T:Editor.SupportsSolidAttribute">
            <summary>
            This is a point class entity, but does support being a brush entity (a mesh tied to an entity).
            </summary>
        </member>
        <member name="T:Editor.PhysicsConstraintAttribute">
            <summary>
            Marks this entity as a physics constraint.
            This disables pre-settle for all <see cref="T:Editor.PhysicsSimulatedAttribute">PhysicsSimulated</see> entities this entity's keyvalues reference in Hammer.
            </summary>
        </member>
        <member name="T:Editor.PathAttribute">
            <summary>
            This is a path class, used with Hammer's Path Tool.
            </summary>
        </member>
        <member name="M:Editor.PathAttribute.#ctor(System.String,System.Boolean)">
            <param name="nodeClassName">Class name of the node entity.</param>
            <param name="spawnEnts">If set to true, will actually create node entities. If set to false, node data will be serialized to a JSON key-value.</param>
        </member>
        <member name="T:Editor.PathNodeAttribute">
            <summary>
            This is a path node class. May not necessarily be an entity.
            </summary>
        </member>
        <member name="T:Editor.AutoApplyMaterialAttribute">
            <summary>
            Apply this material to the mesh when tying one to this class. Typically used for triggers.
            </summary>
        </member>
        <member name="T:Editor.ModelAttribute">
            <summary>
            This makes it so the model, skin and bodygroups can be set and changed in Hammer.
            </summary>
        </member>
        <member name="P:Editor.ModelAttribute.Model">
            <summary>
            The default model to be set to.
            </summary>
        </member>
        <member name="P:Editor.ModelAttribute.BodyGroup">
            <summary>
            The default body group to be set to.
            </summary>
        </member>
        <member name="P:Editor.ModelAttribute.MaterialGroup">
            <summary>
            The default material group to be set to.
            </summary>
        </member>
        <member name="P:Editor.ModelAttribute.Archetypes">
            <summary>
            Marks this entity as a representative of a certain model archetype.
            This makes this entity class appear in ModelDoc under given archetype(s), which will be used to decide which entity class to use when dragging models from Hammer's Asset browser.
            </summary>
        </member>
        <member name="T:Editor.EditorSpriteAttribute">
            <summary>
            Declare a sprite to represent this entity in Hammer.
            </summary>
            <example>
            [EditorSprite( "editor/ai_goal_follow.vmat" )]
            </example>
        </member>
        <member name="T:Editor.ParticleAttribute">
            <summary>
            Tells Hammer that this entity has a particle effect keyvalue that needs to be visualized.
            </summary>
        </member>
        <member name="T:Editor.PhysicsTypeOverrideMeshAttribute">
            <summary>
            Indicate to the map builder that any meshes associated with the entity should have a mesh physics type.
            </summary>
        </member>
        <member name="T:Editor.PhysicsSimulatedAttribute">
            <summary>
            Indicate if the entity is simulated in game and should participate in the pre-settle simulation during map compile.
            Adds a pre-settle keyvalue to this entity class.
            </summary>
        </member>
        <member name="T:Editor.SkyboxAttribute">
            <summary>
            Helper to render skybox in hammer
            </summary>
        </member>
        <member name="T:Editor.VisGroup">
            <summary>
            Used to tell Hammer which automatic Visibility Groups an entity should belong to. See <see cref="T:Editor.VisGroupAttribute">VisGroupAttribute</see>.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Lighting">
            <summary>
            Entities that are primarily lights and that sort of thing.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Sound">
            <summary>
            The purpose of these entities is to emit light and not much else.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Logic">
            <summary>
            Pure logic entities, typically not shown in-game.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Trigger">
            <summary>
            Any sort of trigger volume, these usually don't show up in-game.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Navigation">
            <summary>
            Entities that are related to nav meshes.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Particles">
            <summary>
            The main reason these exist is to create particle systems.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Physics">
            <summary>
            Physics enabled entities.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Dynamic">
            <summary>
            Entities that do not move via physics but are still intractable with or otherwise non static.
            </summary>
        </member>
        <member name="T:Editor.VisGroupAttribute">
            <summary>
            Makes the entity show up under given automatic visibility group in Hammer.
            </summary>
        </member>
        <member name="T:Editor.DrawAnglesAttribute">
            <summary>
            Draws the movement direction in Hammer.
            </summary>
            <example>
            [DrawAngles( "movedir", "movedir_islocal" )]
            </example>
        </member>
        <member name="T:Editor.DoorHelperAttribute">
            <summary>
            Draws the door movement and the final open position in Hammer.
            </summary>
        </member>
        <member name="T:Editor.RenderFieldsAttribute">
            <summary>
            Adds the render color and other related options to the entity class in Hammer.
            </summary>
            <example>
            [RenderFields]
            </example>
        </member>
        <member name="T:Editor.FrustumBoundlessAttribute">
            <summary>
            Draws a frustum that doesn't contribute to bounds calculations.
            </summary>
        </member>
        <member name="T:Editor.SphereAttribute">
            <summary>
            Displays a sphere in Hammer with a radius tied to given property and with given color.
            The sphere's radius can be manipulated in Hammer's 2D views. You can have multiple of these.
            </summary>
        </member>
        <member name="P:Editor.SphereAttribute.IsLean">
            <summary>
            If set to true, the sphere will appear as 3 circles in 3D view, rather than a wireframe sphere.
            </summary>
        </member>
        <member name="M:Editor.SphereAttribute.#ctor(System.String,System.UInt32,System.Boolean)">
            <param name="variableName">Name of the variable to use as sphere radius.</param>
            <param name="color">Color as an unsigned integer. For example 0xFF99CC, where 0xBBGGRR.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="M:Editor.SphereAttribute.#ctor(System.String,System.String,System.Boolean)">
            <param name="variableName">Name of the variable to use as sphere radius.</param>
            <param name="color">Color as an unsigned integer. For example 0xFF99CC, where 0xBBGGRR.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="M:Editor.SphereAttribute.#ctor(System.String,System.Byte,System.Byte,System.Byte,System.Boolean)">
            <param name="variableName">Name of the variable to use as sphere radius.</param>
            <param name="red">Red component of the sphere's color.</param>
            <param name="green">Green component of the sphere's color.</param>
            <param name="blue">Blue component of the sphere's color.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="M:Editor.SphereAttribute.#ctor(System.Single,System.Byte,System.Byte,System.Byte,System.Boolean)">
            <param name="radius">Range of the sphere to show.</param>
            <param name="red">Red component of the sphere's color.</param>
            <param name="green">Green component of the sphere's color.</param>
            <param name="blue">Blue component of the sphere's color.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="T:Editor.TextAttribute">
            <summary>
            Displays text in Hammer on the entity.
            </summary>
        </member>
        <member name="M:Editor.TextAttribute.#ctor(System.String,System.String,System.Boolean)">
            <param name="text">The text to display.</param>
            <param name="offsetVariable">The name of the property that will act as the position of the text.</param>
            <param name="worldspace">Whether the position from the variable should be interpreted in world space (true) or in local space (false).</param>
        </member>
        <member name="T:Editor.LineAttribute">
            <summary>
            Draws a line in Hammer. You can have multiple of this attribute.
            </summary>
        </member>
        <member name="M:Editor.LineAttribute.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Draws lines between this entity and all entities which have a key named '<paramref name="startKey">startKey</paramref>' and its value matches
            the value of our '<paramref name="startKeyValue">startKeyValue</paramref>'.
            </summary>
            <param name="startKey">Name of the key to search on other entities. This typically will be 'targetname'.</param>
            <param name="startKeyValue">Name of our key whose value will be used to match other entities.</param>
            <param name="onlySelected">Only draw the line when the entity is selected.</param>
        </member>
        <member name="M:Editor.LineAttribute.#ctor(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Draws lines between all entities, starting from each entity that has a key named '<paramref name="startKey">startKey</paramref>' and its value matches
            the value of our '<paramref name="startKeyValue">startKeyValue</paramref>' and going to each entity that has a key named <paramref name="endKey">endKey</paramref>
            with a value of '<paramref name="endKeyValue">endKeyValue</paramref>'s value.
            </summary>
            <param name="startKey">Name of the key to search on other entities. This typically will be 'targetname'.</param>
            <param name="startKeyValue">Name of our key whose value will be used to match other entities.</param>
            <param name="endKey">Name of the key to search on other entities.</param>
            <param name="endKeyValue">Name of our key whose value will be used to match other entities.</param>
            <param name="onlySelected">Only draw the line when the entity is selected.</param>
        </member>
        <member name="T:Editor.PointLineAttribute">
            <summary>
            Draws a line in Hammer from the entity's origin to a point that can be moved with a gizmo and is stored in this property.
            </summary>
        </member>
        <member name="P:Editor.PointLineAttribute.Local">
            <summary>
            Write local to entity coordinates to the provided key. Default is to write in world space.
            </summary>
        </member>
        <member name="T:Editor.BoxSizeAttribute">
            <summary>
            For point entities without visualization (model/sprite), sets the size of the box the entity will appear as in Hammer.
            </summary>
        </member>
        <member name="T:Editor.BoundsHelperAttribute">
            <summary>
            Creates a resizable box helper in Hammer which outputs the size of the bounding box defined by the level designer into given keys/properties.
            You can have multiple of this attribute.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.MinsKey">
            <summary>
            Key (classname) of the entity to store the "Mins" of the bounding box.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.MaxsKey">
            <summary>
            Key (classname) of the entity to store the "Maxs" of the bounding box.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.ExtentsKey">
            <summary>
            Key (classname) of the entity to store the bounding box as an "extents".
            This replaces <see cref="P:Editor.BoundsHelperAttribute.MinsKey"/> and <see cref="P:Editor.BoundsHelperAttribute.MaxsKey"/> and assumes the entity is in the middle of the bounds.
            The output value will be the total size of the bounds on each axis.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.AutoCenter">
            <summary>
            Always move the entity to the center of the bounds.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.IsWorldAligned">
            <summary>
            Make the bounds AABB (true), not OBB (false). Basically ignores rotation.
            </summary>
        </member>
        <member name="M:Editor.BoundsHelperAttribute.#ctor(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a box helper that outputs the size of the bounding box defined by the level designer as mins and maxs
            </summary>
            <param name="minsKey">The internal key name to output "mins" size to.</param>
            <param name="maxsKey">The internal key name to output "maxs" size to.</param>
            <param name="autoCenter">If set to true, editing this box in Hammer will automatically move the entity to the center of the box.</param>
            <param name="worldAliged">If set, the helper box will ignore entity rotation.</param>
        </member>
        <member name="M:Editor.BoundsHelperAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a box helper that outputs the size of the bounding box defined by the level designer as extents (maxs - mins).
            This assumes the entity is in the center of the box.
            </summary>
            <param name="extentsKey">The internal key name to output "extents" size to. This is the result of (maxs - mins).</param>
            <param name="worldAliged">If set, the helper box will ignore entity rotation.</param>
        </member>
        <member name="T:Editor.OrthoBoundsHelperAttribute">
            <summary>
            Creates a resizable box helper that represents an orthographic projection from the entity's origin in Hammer.
            The size of the bounding box as defined by the level designer is put into given keys/properties.
            </summary>
        </member>
        <member name="T:Editor.CanBeClientsideOnlyAttribute">
            <summary>
            Adds a property in Hammer that dictates whether the entity will be spawned on server or client.
            </summary>
        </member>
        <member name="T:Editor.EntityReportSourceAttribute">
            <summary>
            Makes value of this property appear in the Source File column of the Entity Report dialog in Hammer.
            There can be only one of such properties.
            </summary>
        </member>
        <member name="T:Editor.PostProcessingVolumeAttribute">
            <summary>
            Internally marks this class in Hammer as a post processing entity for preview purposes.
            </summary>
        </member>
        <member name="T:Editor.ToneMapAttribute">
            <summary>
            Internally marks this class in Hammer as a tonemap entity for preview purposes.
            </summary>
        </member>
        <member name="T:Editor.LightAttribute">
            <summary>
            Internally marks this class in Hammer as a light.
            </summary>
        </member>
        <member name="T:Editor.LightConeAttribute">
            <summary>
            The light_spot visualizer.
            </summary>
        </member>
        <member name="T:Editor.GlobalAttribute">
            <summary>
            Marks this entity as global, there should only be one entity with this global name in the map.
            Used internally for Preview purposes.
            </summary>
        </member>
        <member name="T:Editor.SimpleHelperAttribute">
            <summary>
            Adds a simple parameterless helper to the entity class.
            </summary>
        </member>
        <member name="T:Editor.BakeAmbientLightAttribute">
            <summary>
            Used by light_environment entity internally.
            </summary>
        </member>
        <member name="T:Editor.BakeAmbientOcclusionAttribute">
            <summary>
            Used by light_environment entity internally.
            </summary>
        </member>
        <member name="T:Editor.BakeSkyLightAttribute">
            <summary>
            Used by light_environment entity internally.
            </summary>
        </member>
        <member name="T:Editor.BakeResourceAttribute">
            <summary>
            Allows hammer to bake resources, mostly used for cubemaps and light probes
            </summary>
        </member>
        <member name="T:ValidateAttribute">
            <summary>
            Validates a property using a method.
            </summary>
        </member>
        <member name="M:ValidateAttribute.#ctor(System.String,System.String,Sandbox.LogLevel)">
            <summary>
            Specifies a method in the same class to use for validation.
            </summary>
            <param name="condition">Name of the validation method in the current class</param>
            <param name="message">Message to display when validation fails</param>
            <param name="status">severity level to use when validation fails</param>
            <code>
            [Validate(nameof(IsLineMaterial), "Material should derive from 'line.shader'.", LogLevel.Warn)]
            public Material Material { get; set; }
            
            private bool IsLineMaterial(Material material)
            {
                return material != null &amp;&amp; material.Shader.Name.Contains("line.shader");
            }
            </code>
        </member>
        <member name="M:ValidateAttribute.#ctor(System.Type,System.String,System.String,Sandbox.LogLevel)">
            <summary>
            Specifies a static method in another class to use for validation.
            </summary>
            <param name="type">The type containing the static validation method</param>
            <param name="condition">Name of the static validation method</param>
            <param name="message">Message to display when validation fails</param>
            <param name="status">severity level to use when validation fails</param>
            <code>
            [Validate(typeof(MaterialValidators), nameof(MaterialValidators.IsLineMaterial), "Material should derive from 'line.shader'.", LogLevel.Warn)]
            public Material Material { get; set; }
            
            // In MaterialValidators.cs
            public static class MaterialValidators
            {
                public static bool IsLineMaterial(Material material)
                {
                    return material != null &amp;&amp; material.Shader.Name.Contains("line.shader");
                }
            }
            </code>
        </member>
        <member name="M:ValidateAttribute.Validate(System.Object,Sandbox.TypeDescription,System.Object)">
            <summary>
            Validates a property value using the specified method.
            </summary>
        </member>
        <member name="T:DotRecast.Detour.Crowd.DtCrowd">
            
            	@defgroup crowd Crowd
            
            	Members in this module implement local steering and dynamic avoidance features.
            
            	The crowd is the big beast of the navigation features. It not only handles a
            	lot of the path management for you, but also local steering and dynamic
            	avoidance between members of the crowd. I.e. It can keep your agents from
            	running into each other.
            
            	Main class: #dtCrowd
            
            	The #dtNavMeshQuery and #dtPathCorridor classes provide perfectly good, easy
            	to use path planning features. But in the end they only give you points that
            	your navigation client should be moving toward. When it comes to deciding things
            	like agent velocity and steering to avoid other agents, that is up to you to
            	implement. Unless, of course, you decide to use #dtCrowd.
            
            	Basically, you add an agent to the crowd, providing various configuration
            	settings such as maximum speed and acceleration. You also provide a local
            	target to more toward. The crowd manager then provides, with every update, the
            	new agent position and velocity for the frame. The movement will be
            	constrained to the navigation mesh, and steering will be applied to ensure
            	agents managed by the crowd do not collide with each other.
            
            	This is very powerful feature set. But it comes with limitations.
            
            	The biggest limitation is that you must give control of the agent's position
            	completely over to the crowd manager. You can update things like maximum speed
            	and acceleration. But in order for the crowd manager to do its thing, it can't
            	allow you to constantly be giving it overrides to position and velocity. So
            	you give up direct control of the agent's movement. It belongs to the crowd.
            
            	The second biggest limitation revolves around the fact that the crowd manager
            	deals with local planning. So the agent's target should never be more than
            	256 polygons aways from its current position. If it is, you risk
            	your agent failing to reach its target. So you may still need to do long
            	distance planning and provide the crowd manager with intermediate targets.
            
            	Other significant limitations:
            
            	- All agents using the crowd manager will use the same #dtQueryFilter.
            	- Crowd management is relatively expensive. The maximum agents under crowd
            	  management at any one time is between 20 and 30.  A good place to start
            	  is a maximum of 25 agents for 0.5ms per frame.
            
            	@note This is a summary list of members.  Use the index or search
            	feature to find minor members.
            
            	@struct dtCrowdAgentParams
            	@see dtCrowdAgent, dtCrowd::addAgent(), dtCrowd::updateAgentParameters()
            
            	@var dtCrowdAgentParams::obstacleAvoidanceType
            	@par
            
            	#dtCrowd permits agents to use different avoidance configurations.  This value
            	is the index of the #dtObstacleAvoidanceParams within the crowd.
            
            	@see dtObstacleAvoidanceParams, dtCrowd::setObstacleAvoidanceParams(),
            		 dtCrowd::getObstacleAvoidanceParams()
            
            	@var dtCrowdAgentParams::collisionQueryRange
            	@par
            
            	Collision elements include other agents and navigation mesh boundaries.
            
            	This value is often based on the agent radius and/or maximum speed. E.g. radius * 8
            
            	@var dtCrowdAgentParams::pathOptimizationRange
            	@par
            
            	Only applicable if #updateFlags includes the #DT_CROWD_OPTIMIZE_VIS flag.
            
            	This value is often based on the agent radius. E.g. radius * 30
            
            	@see dtPathCorridor::optimizePathVisibility()
            
            	@var dtCrowdAgentParams::separationWeight
            	@par
            
            	A higher value will result in agents trying to stay farther away from each other at
            	the cost of more difficult steering in tight spaces.
            Provides local steering behaviors for a group of agents. 
            @ingroup crowd
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtCrowd.SetObstacleAvoidanceParams(System.Int32,DotRecast.Detour.Crowd.DtObstacleAvoidanceParams)">
            Sets the shared avoidance configuration for the specified index.
            @param[in] idx The index. [Limits: 0 &lt;= value &lt; #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]
            @param[in] option The new configuration.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtCrowd.GetObstacleAvoidanceParams(System.Int32)">
            Gets the shared avoidance configuration for the specified index.
            @param[in] idx The index of the configuration to retreive.
            [Limits: 0 &lt;= value &lt; #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]
            @return The requested configuration.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtCrowd.UpdateAgentParameters(DotRecast.Detour.Crowd.DtCrowdAgent,DotRecast.Detour.Crowd.DtCrowdAgentParams)">
            Updates the specified agent's configuration.
            @param[in] idx The agent index. [Limits: 0 &lt;= value &lt; #GetAgentCount()]
            @param[in] params The new agent configuration.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtCrowd.AddAgent(Vector3,DotRecast.Detour.Crowd.DtCrowdAgentParams)">
             @par
            
             The agent's position will be constrained to the surface of the navigation mesh.
             Adds a new agent to the crowd.
              @param[in]		pos		The requested position of the agent. [(x, y, z)]
              @param[in]		params	The configuration of the agent.
             @return The index of the agent in the agent pool. Or -1 if the agent could not be added.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtCrowd.RequestMoveTarget(DotRecast.Detour.Crowd.DtCrowdAgent,System.Int64,Vector3)">
             Submits a new move request for the specified agent.
             @param[in] idx The agent index. [Limits: 0 &lt;= value &lt; #GetAgentCount()]
             @param[in] ref The position's polygon reference.
             @param[in] pos The position within the polygon. [(x, y, z)]
             @return True if the request was successfully submitted.
            
             This method is used when a new target is set.
            
             The position will be constrained to the surface of the navigation mesh.
            
             The request will be processed during the next #Update().
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtCrowd.RequestMoveVelocity(DotRecast.Detour.Crowd.DtCrowdAgent,Vector3)">
            Submits a new move request for the specified agent.
            @param[in] idx The agent index. [Limits: 0 &lt;= value &lt; #GetAgentCount()]
            @param[in] vel The movement velocity. [(x, y, z)]
            @return True if the request was successfully submitted.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtCrowd.ResetMoveTarget(DotRecast.Detour.Crowd.DtCrowdAgent)">
            Resets any request for the specified agent.
            @param[in] idx The agent index. [Limits: 0 &lt;= value &lt; #GetAgentCount()]
            @return True if the request was successfully reseted.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtCrowd.GetActiveAgents">
             Gets the active agents int the agent pool.
            
             @return List of active agents
        </member>
        <member name="T:DotRecast.Detour.Crowd.DtCrowdAgent">
            Represents an agent managed by a #dtCrowd object.
            @ingroup crowd
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.state">
            The type of mesh polygon the agent is traversing. (See: #CrowdAgentState)
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.partial">
            True if the agent has valid path (targetState == DT_CROWDAGENT_TARGET_VALID) and the path does not lead to the requested position, else false.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.corridor">
            The path corridor the agent is using.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.boundary">
            The local boundary data for the agent.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.topologyOptTime">
            Time since the agent's path corridor was optimized.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.neis">
            The known neighbors of the agent.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.nneis">
            The number of neighbors.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.desiredSpeed">
            The desired speed.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.option">
            The agent's configuration parameters.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.corners">
            The local path corridor corners for the agent.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.ncorners">
            The number of corners.
        </member>
        <member name="T:DotRecast.Detour.Crowd.DtCrowdAgentParams">
            Configuration parameters for a crowd agent.
            @ingroup crowd
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.collisionQueryRange">
            Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.separationWeight">
            How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.updateFlags">
            the agent path.
            Flags that impact steering behavior. (See: #UpdateFlags)
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.obstacleAvoidanceType">
            The index of the avoidance configuration to use for the agent.
            [Limits: 0 &lt;= value &lt; #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.queryFilterType">
            The index of the query filter used by this agent.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.userData">
            User defined data attached to the agent.
        </member>
        <member name="T:DotRecast.Detour.Crowd.DtCrowdAgentState">
            The type of navigation mesh polygon the agent is currently traversing.
            @ingroup crowd
        </member>
        <member name="T:DotRecast.Detour.Crowd.DtCrowdAgentUpdateFlags">
            Crowd agent update flags.
            @ingroup crowd
            @see dtCrowdAgentParams::updateFlags
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdConst.DT_CROWDAGENT_MAX_NEIGHBOURS">
            The maximum number of neighbors that a crowd agent can take into account
            for steering decisions.
            @ingroup crowd
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdConst.DT_CROWDAGENT_MAX_CORNERS">
            The maximum number of corners a crowd agent will look ahead in the path.
            This value is used for sizing the crowd agent corner buffers.
            Due to the behavior of the crowd manager, the actual number of useful
            corners will be one less than this number.
            @ingroup crowd
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdConst.DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS">
            The maximum number of crowd avoidance configurations supported by the
            crowd manager.
            @ingroup crowd
            @see dtObstacleAvoidanceParams, dtCrowd::SetObstacleAvoidanceParams(), dtCrowd::GetObstacleAvoidanceParams(),
            dtCrowdAgentParams::obstacleAvoidanceType
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtCrowdConst.DT_CROWD_MAX_QUERY_FILTER_TYPE">
            The maximum number of query filter types supported by the crowd manager.
            @ingroup crowd
            @see dtQueryFilter, dtCrowd::GetFilter() dtCrowd::GetEditableFilter(),
            dtCrowdAgentParams::queryFilterType
        </member>
        <member name="T:DotRecast.Detour.Crowd.DtCrowdNeighbour">
            Provides neighbor data for agents managed by the crowd.
            @ingroup crowd
            @see dtCrowdAgent::neis, dtCrowd
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtObstacleAvoidanceQuery.ProcessSample(Vector3,System.Single,Vector3,System.Single,Vector3,Vector3,System.Single)">
             Calculate the collision penalty for a given velocity vector
            
             @param vcand
                        sampled velocity
             @param dvel
                        desired velocity
             @param minPenalty
                        threshold penalty for early out
        </member>
        <member name="T:DotRecast.Detour.Crowd.DtObstacleCircle">
            &lt; Max number of adaptive rings.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.p">
            Position of the obstacle 
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.vel">
            Velocity of the obstacle 
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.dvel">
            Velocity of the obstacle 
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.rad">
            Radius of the obstacle 
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.dp">
            Use for side selection during sampling. 
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.np">
            Use for side selection during sampling. 
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtObstacleSegment.p">
            End points of the obstacle segment 
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtObstacleSegment.q">
            End points of the obstacle segment 
        </member>
        <member name="T:DotRecast.Detour.Crowd.DtPathCorridor">
            Represents a dynamic polygon corridor used to plan agent movement.
            @ingroup crowd, detour
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.#ctor">
            		@class dtPathCorridor
            		@par
            
            		The corridor is loaded with a path, usually obtained from a #dtNavMeshQuery::findPath() query. The corridor
            		is then used to plan local movement, with the corridor automatically updating as needed to deal with inaccurate
            		agent locomotion.
            
            		Example of a common use case:
            
            		-# Construct the corridor object and call #init() to allocate its path buffer.
            		-# Obtain a path from a #dtNavMeshQuery object.
            		-# Use #reset() to set the agent's current position. (At the beginning of the path.)
            		-# Use #setCorridor() to load the path and target.
            		-# Use #findCorners() to plan movement. (This handles dynamic path straightening.)
            		-# Use #movePosition() to feed agent movement back into the corridor. (The corridor will automatically adjust as needed.)
            		-# If the target is moving, use #moveTargetPosition() to update the end of the corridor.
            		   (The corridor will automatically adjust as needed.)
            		-# Repeat the previous 3 steps to continue to move the agent.
            
            		The corridor position and target are always constrained to the navigation mesh.
            
            		One of the difficulties in maintaining a path is that floating point errors, locomotion inaccuracies, and/or local
            		steering can result in the agent crossing the boundary of the path corridor, temporarily invalidating the path.
            		This class uses local mesh queries to detect and update the corridor as needed to handle these types of issues.
            
            		The fact that local mesh queries are used to move the position and target locations results in two beahviors that
            		need to be considered:
            
            		Every time a move function is used there is a chance that the path will become non-optimial. Basically, the further
            		the target is moved from its original location, and the further the position is moved outside the original corridor,
            		the more likely the path will become non-optimal. This issue can be addressed by periodically running the
            		#optimizePathTopology() and #optimizePathVisibility() methods.
            
            		All local mesh queries have distance limitations. (Review the #dtNavMeshQuery methods for details.) So the most accurate
            		use case is to move the position and target in small increments. If a large increment is used, then the corridor
            		may not be able to accurately find the new location.  Because of this limiation, if a position is moved in a large
            		increment, then compare the desired and resulting polygon references. If the two do not match, then path replanning
            		may be needed.  E.g. If you move the target, check #getLastPoly() to see if it is the expected polygon.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.Init(System.Int32)">
             @par
            
             @warning Cannot be called more than once.
             Allocates the corridor's path buffer. 
              @param[in]		maxPath		The maximum path size the corridor can handle.
             @return True if the initialization succeeded.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.Reset(System.Int64,Vector3)">
             @par
            
             Essentially, the corridor is set of one polygon in size with the target
             equal to the position.
             
             Resets the path corridor to the specified position.
              @param[in]		ref		The polygon reference containing the position.
              @param[in]		pos		The new position in the corridor. [(x, y, z)]
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.FindCorners(System.Span{DotRecast.Detour.DtStraightPath},System.Int32,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
            		@par
            
            		This is the function used to plan local movement within the corridor. One or more corners can be
            		detected in order to plan movement. It performs essentially the same function as #dtNavMeshQuery::findStraightPath.
            
            		Due to internal optimizations, the maximum number of corners returned will be (@p maxCorners - 1)
            		For example: If the buffers are sized to hold 10 corners, the function will never return more than 9 corners.
            		So if 10 corners are needed, the buffers should be sized for 11 corners.
            
            		If the target is within range, it will be the last corner and have a polygon reference id of zero.
            Finds the corners in the corridor from the position toward the target. (The straightened path.)
             @param[out]	cornerVerts		The corner vertices. [(x, y, z) * cornerCount] [Size: &lt;= maxCorners]
             @param[out]	cornerFlags		The flag for each corner. [(flag) * cornerCount] [Size: &lt;= maxCorners]
             @param[out]	cornerPolys		The polygon reference for each corner. [(polyRef) * cornerCount] 
             								[Size: &lt;= @p maxCorners]
             @param[in]		maxCorners		The maximum number of corners the buffers can hold.
             @param[in]		navquery		The query object used to build the corridor.
             @param[in]		filter			The filter to apply to the operation.
            @return The number of corners returned in the corner buffers. [0 &lt;= value &lt;= @p maxCorners]
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.OptimizePathVisibility(Vector3,System.Single,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
            		@par
            
            		Inaccurate locomotion or dynamic obstacle avoidance can force the argent position significantly outside the
            		original corridor. Over time this can result in the formation of a non-optimal corridor. Non-optimal paths can
            		also form near the corners of tiles.
            
            		This function uses an efficient local visibility search to try to optimize the corridor
            		between the current position and @p next.
            
            		The corridor will change only if @p next is visible from the current position and moving directly toward the point
            		is better than following the existing path.
            
            		The more inaccurate the agent movement, the more beneficial this function becomes. Simply adjust the frequency
            		of the call to match the needs to the agent.
            
            		This function is not suitable for long distance searches.
            Attempts to optimize the path if the specified point is visible from the current position.
             @param[in]		next					The point to search toward. [(x, y, z])
             @param[in]		pathOptimizationRange	The maximum range to search. [Limit: > 0]
             @param[in]		navquery				The query object used to build the corridor.
             @param[in]		filter					The filter to apply to the operation.	
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.OptimizePathTopology(DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter,System.Int32)">
            		@par
            
            		Inaccurate locomotion or dynamic obstacle avoidance can force the agent position significantly outside the
            		original corridor. Over time this can result in the formation of a non-optimal corridor. This function will use a
            		local area path search to try to re-optimize the corridor.
            
            		The more inaccurate the agent movement, the more beneficial this function becomes. Simply adjust the frequency of
            		the call to match the needs to the agent.
            Attempts to optimize the path using a local area search. (Partial replanning.) 
             @param[in]		navquery	The query object used to build the corridor.
             @param[in]		filter		The filter to apply to the operation.	
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.MovePosition(Vector3,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
            		@par
            
            		Behavior:
            
            		- The movement is constrained to the surface of the navigation mesh.
            		- The corridor is automatically adjusted (shorted or lengthened) in order to remain valid.
            		- The new position will be located in the adjusted corridor's first polygon.
            
            		The expected use case is that the desired position will be 'near' the current corridor. What is considered 'near'
            		depends on local polygon density, query search half extents, etc.
            
            		The resulting position will differ from the desired position if the desired position is not on the navigation mesh,
            		or it can't be reached using a local search.
            Moves the position from the current location to the desired location, adjusting the corridor 
            as needed to reflect the change.
             @param[in]		npos		The desired new position. [(x, y, z)]
             @param[in]		navquery	The query object used to build the corridor.
             @param[in]		filter		The filter to apply to the operation.
            @return Returns true if move succeeded.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.MoveTargetPosition(Vector3,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
            		@par
            
            		Behavior:
            
            		- The movement is constrained to the surface of the navigation mesh.
            		- The corridor is automatically adjusted (shorted or lengthened) in order to remain valid.
            		- The new target will be located in the adjusted corridor's last polygon.
            
            		The expected use case is that the desired target will be 'near' the current corridor. What is considered 'near' depends on local polygon density, query search half extents, etc.
            
            		The resulting target will differ from the desired target if the desired target is not on the navigation mesh, or it can't be reached using a local search.
            Moves the target from the curent location to the desired location, adjusting the corridor
            as needed to reflect the change. 
             @param[in]		npos		The desired new target position. [(x, y, z)]
             @param[in]		navquery	The query object used to build the corridor.
             @param[in]		filter		The filter to apply to the operation.
            @return Returns true if move succeeded.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.SetCorridor(Vector3,System.Collections.Generic.List{System.Int64})">
             @par
            
             The current corridor position is expected to be within the first polygon in the path. The target 
             is expected to be in the last polygon. 
             
             @warning The size of the path must not exceed the size of corridor's path buffer set during #init().
             Loads a new path and target into the corridor.
              @param[in]		target		The target location within the last polygon of the path. [(x, y, z)]
              @param[in]		path		The path corridor. [(polyRef) * @p npolys]
              @param[in]		npath		The number of polygons in the path.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.IsValid(System.Int32,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
             @par
            
             The path can be invalidated if there are structural changes to the underlying navigation mesh, or the state of 
             a polygon within the path changes resulting in it being filtered out. (E.g. An exclusion or inclusion flag changes.)
             Checks the current corridor path to see if its polygon references remain valid.
             
              @param[in]		maxLookAhead	The number of polygons from the beginning of the corridor to search.
              @param[in]		navquery		The query object used to build the corridor.
              @param[in]		filter			The filter to apply to the operation.	
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetPos">
            Gets the current position within the corridor. (In the first polygon.)
            @return The current position within the corridor.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetTarget">
            Gets the current target within the corridor. (In the last polygon.)
            @return The current target within the corridor.
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetFirstPoly">
            The polygon reference id of the first polygon in the corridor, the polygon containing the position.
            @return The polygon reference id of the first polygon in the corridor. (Or zero if there is no path.)
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetLastPoly">
            The polygon reference id of the last polygon in the corridor, the polygon containing the target.
            @return The polygon reference id of the last polygon in the corridor. (Or zero if there is no path.)
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetPath">
            The corridor's path.
            @return The corridor's path. [(polyRef) * #getPathCount()]
        </member>
        <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetPathCount">
            The number of polygons in the current corridor path.
            @return The number of polygons in the current corridor path.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtPathQuery.startPos">
            Path find start and end location.
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtSegment.s">
            Segment start/end 
        </member>
        <member name="F:DotRecast.Detour.Crowd.DtSegment.d">
            Distance for pruning. 
        </member>
        <member name="T:DotRecast.Detour.DtBVNode">
            Bounding volume node.
            @note This structure is rarely if ever used by the end user.
            @see dtMeshTile
        </member>
        <member name="F:DotRecast.Detour.DtDetour.DT_VERTS_PER_POLYGON">
            The maximum number of vertices per navigation polygon.
            @ingroup detour
        </member>
        <member name="F:DotRecast.Detour.DtDetour.DT_NAVMESH_MAGIC">
            A magic number used to detect compatibility of navigation tile data. 
        </member>
        <member name="F:DotRecast.Detour.DtDetour.DT_NAVMESH_VERSION">
            A version number used to detect compatibility of navigation tile data. 
        </member>
        <member name="F:DotRecast.Detour.DtDetour.DT_NAVMESH_STATE_MAGIC">
            A magic number used to detect the compatibility of navigation tile states. 
        </member>
        <member name="F:DotRecast.Detour.DtDetour.DT_NAVMESH_STATE_VERSION">
            A version number used to detect compatibility of navigation tile states. 
        </member>
        <member name="F:DotRecast.Detour.DtDetour.DT_EXT_LINK">
            A flag that indicates that an entity links to an external entity.
            (E.g. A polygon edge is a portal that links to another polygon.)
        </member>
        <member name="F:DotRecast.Detour.DtDetour.DT_NULL_LINK">
            A value that indicates the entity does not link to anything.
        </member>
        <member name="F:DotRecast.Detour.DtDetour.DT_MAX_AREAS">
            The maximum number of user defined area ids.
        </member>
        <member name="F:DotRecast.Detour.DtDetour.DT_RAY_CAST_LIMIT_PROPORTIONS">
            Limit raycasting during any angle pahfinding
            The limit is given as a multiple of the character radius
        </member>
        <member name="M:DotRecast.Detour.DtDetour.EncodePolyId(System.Int32,System.Int32,System.Int32)">
            @{
            @name Encoding and Decoding
            These functions are generally meant for internal use only.
            Derives a standard polygon reference.
             @note This function is generally meant for internal use only.
             @param[in]	salt	The tile's salt value.
             @param[in]	it		The index of the tile.
             @param[in]	ip		The index of the polygon within the tile.
        </member>
        <member name="M:DotRecast.Detour.DtDetour.DecodePolyId(System.Int64,System.Int32@,System.Int32@,System.Int32@)">
            Decodes a standard polygon reference.
            @note This function is generally meant for internal use only.
            @param[in] ref The polygon reference to decode.
            @param[out] salt The tile's salt value.
            @param[out] it The index of the tile.
            @param[out] ip The index of the polygon within the tile.
            @see #encodePolyId
        </member>
        <member name="M:DotRecast.Detour.DtDetour.DecodePolyIdSalt(System.Int64)">
            Extracts a tile's salt value from the specified polygon reference.
            @note This function is generally meant for internal use only.
            @param[in] ref The polygon reference.
            @see #encodePolyId
        </member>
        <member name="M:DotRecast.Detour.DtDetour.DecodePolyIdTile(System.Int64)">
            Extracts the tile's index from the specified polygon reference.
            @note This function is generally meant for internal use only.
            @param[in] ref The polygon reference.
            @see #encodePolyId
        </member>
        <member name="M:DotRecast.Detour.DtDetour.DecodePolyIdPoly(System.Int64)">
            Extracts the polygon's index (within its tile) from the specified
            polygon reference.
            @note This function is generally meant for internal use only.
            @param[in] ref The polygon reference.
            @see #encodePolyId
        </member>
        <member name="M:DotRecast.Detour.DtDetour.GetDetailTriEdgeFlags(System.Int32,System.Int32)">
            Get flags for edge in detail triangle.
            @param[in]	triFlags		The flags for the triangle (last component of detail vertices above).
            @param[in]	edgeIndex		The index of the first vertex of the edge. For instance, if 0,
            							returns flags for edge AB.
        </member>
        <member name="T:DotRecast.Detour.DtFindPathOptions">
            Options for dtNavMeshQuery::initSlicedFindPath and updateSlicedFindPath
        </member>
        <member name="T:DotRecast.Detour.DtLink">
            Defines a link between polygons.
            @note This structure is rarely if ever used by the end user.
            @see dtMeshTile
        </member>
        <member name="F:DotRecast.Detour.DtMeshData.detailVerts">
            The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]
        </member>
        <member name="F:DotRecast.Detour.DtMeshData.detailTris">
            The detail mesh's triangles. [(vertA, vertB, vertC, triFlags) * dtMeshHeader::detailTriCount].
            See dtDetailTriEdgeFlags and dtGetDetailTriEdgeFlags.
        </member>
        <member name="F:DotRecast.Detour.DtMeshData.bvTree">
            The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount]
            (Will be null if bounding volumes are disabled.)
        </member>
        <member name="T:DotRecast.Detour.DtMeshHeader">
            Provides high level information related to a dtMeshTile object. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.magic">
            Tile magic number. (Used to identify the data format.) 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.version">
            Tile data format version number. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.x">
            The x-position of the tile within the dtNavMesh tile grid. (x, y, layer) 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.y">
            The y-position of the tile within the dtNavMesh tile grid. (x, y, layer) 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.layer">
            The layer of the tile within the dtNavMesh tile grid. (x, y, layer) 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.userId">
            The user defined id of the tile. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.polyCount">
            The number of polygons in the tile. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.vertCount">
            The number of vertices in the tile. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.maxLinkCount">
            The number of allocated links. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.detailMeshCount">
            The number of sub-meshes in the detail mesh. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.detailVertCount">
            The number of unique vertices in the detail mesh. (In addition to the polygon vertices.) 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.detailTriCount">
            The number of triangles in the detail mesh. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.bvNodeCount">
            The number of bounding volume nodes. (Zero if bounding volumes are disabled.) 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.offMeshConCount">
            The number of off-mesh connections. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.offMeshBase">
            The index of the first polygon which is an off-mesh connection. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.walkableHeight">
            The height of the agents using the tile. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.walkableRadius">
            The radius of the agents using the tile. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.walkableClimb">
            The maximum climb height of the agents using the tile. 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.bmin">
            The minimum bounds of the tile's AABB. [(x, y, z)] 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.bmax">
            The maximum bounds of the tile's AABB. [(x, y, z)] 
        </member>
        <member name="F:DotRecast.Detour.DtMeshHeader.bvQuantFactor">
            The bounding volume quantization factor. 
        </member>
        <member name="T:DotRecast.Detour.DtMeshTile">
            Defines a navigation mesh tile.
            @ingroup detour
        </member>
        <member name="T:DotRecast.Detour.DtNavMesh">
            A navigation mesh based on tiles of convex polygons.
            @ingroup detour
        </member>
        <member name="F:DotRecast.Detour.DtNavMesh.m_maxVertPerPoly">
            The maximum number of vertices per navigation polygon. 
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetMaxTiles">
            The maximum number of tiles supported by the navigation mesh.
            @return The maximum number of tiles supported by the navigation mesh.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetTile(System.Int32)">
            Returns pointer to tile in the tile array.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetPolyRefBase(DotRecast.Detour.DtMeshTile)">
            Gets the polygon reference for the tile's base polygon.
             @param[in]	tile		The tile.
            @return The polygon reference for the base polygon in the specified tile.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.CalcTileLoc(Vector3,System.Int32@,System.Int32@)">
            Calculates the tile grid location for the specified world position.
             @param[in]	pos  The world position for the query. [(x, y, z)]
             @param[out]	tx		The tile's x-location. (x, y)
             @param[out]	ty		The tile's y-location. (x, y)
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetTileAndPolyByRef(System.Int64,DotRecast.Detour.DtMeshTile@,DotRecast.Detour.DtPoly@)">
            Gets the tile and polygon for the specified polygon reference.
             @param[in]		ref		The reference for the a polygon.
             @param[out]	tile	The tile containing the polygon.
             @param[out]	poly	The polygon.
            @return The status flags for the operation.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetTileAndPolyByRefUnsafe(System.Int64,DotRecast.Detour.DtMeshTile@,DotRecast.Detour.DtPoly@)">
             @par
            
             @warning Only use this function if it is known that the provided polygon
             reference is valid. This function is faster than #getTileAndPolyByRef,
             but
             it does not validate the reference.
             Returns the tile and polygon for the specified polygon reference.
              @param[in]		ref		A known valid reference for a polygon.
              @param[out]	tile	The tile containing the polygon.
              @param[out]	poly	The polygon.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.IsValidPolyRef(System.Int64)">
            Checks the validity of a polygon reference.
             @param[in]	ref		The polygon reference to check.
            @return True if polygon reference is valid for the navigation mesh.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.QueryPolygonsInTile(DotRecast.Detour.DtMeshTile,Vector3,Vector3)">
            Queries polygons within a tile.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.AddTile(DotRecast.Detour.DtMeshData,System.Int32,System.Int64,System.Int64@)">
             @par
            
             The add operation will fail if the data is in the wrong format, the allocated tile
             space is full, or there is a tile already at the specified reference.
            
             The lastRef parameter is used to restore a tile with the same tile
             reference it had previously used.  In this case the #dtPolyRef's for the
             tile will be restored to the same values they were before the tile was 
             removed.
            
             The nav mesh assumes exclusive access to the data passed and will make
             changes to the dynamic portion of the data. For that reason the data
             should not be reused in other nav meshes until the tile has been successfully
             removed from this nav mesh.
            
             @see dtCreateNavMeshData, #removeTile
             Adds a tile to the navigation mesh.
              @param[in]		data		Data for the new tile mesh. (See: #dtCreateNavMeshData)
              @param[in]		dataSize	Data size of the new tile mesh.
              @param[in]		flags		Tile flags. (See: #dtTileFlags)
              @param[in]		lastRef		The desired reference for the tile. (When reloading a tile.) [opt] [Default: 0]
              @param[out]	result		The tile reference. (If the tile was succesfully added.) [opt]
             @return The status flags for the operation. 
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.RemoveTile(System.Int64)">
             Removes the specified tile from the navigation mesh.
             @param[in] ref The reference of the tile to remove.
             @param[out] data Data associated with deleted tile.
             @param[out] dataSize Size of the data associated with deleted tile.
            
             This function returns the data for the tile so that, if desired,
             it can be added back to the navigation mesh at a later point.
            
             @see #addTile
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.ConnectIntLinks(DotRecast.Detour.DtMeshTile)">
            Builds internal polygons links for a tile.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.UnconnectLinks(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtMeshTile)">
            Removes external links at specified side.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.ConnectExtLinks(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtMeshTile,System.Int32)">
            Builds external polygon links for a tile.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.ConnectExtOffMeshLinks(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtMeshTile,System.Int32)">
            Builds external polygon links for a tile.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.FindConnectingPolys(Vector3,Vector3,DotRecast.Detour.DtMeshTile,System.Int32,System.Collections.Generic.List{DotRecast.Detour.DtConnectPoly}@)">
            Returns all polygons in neighbour tile based on portal defined by the segment.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.BaseOffMeshLinks(DotRecast.Detour.DtMeshTile)">
            Builds internal polygons links for a tile.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.ClosestPointOnDetailEdges(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtPoly,Vector3,System.Boolean)">
             Returns closest point on polygon.
            
             @param ref
             @param pos
             @return
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.FindNearestPolyInTile(DotRecast.Detour.DtMeshTile,Vector3,Vector3,Vector3@)">
            Find nearest polygon within a tile.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetNeighbourTilesAt(System.Int32,System.Int32,System.Int32,DotRecast.Detour.DtMeshTile[],System.Int32)">
            Returns neighbour tile based on side.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetTilesAt(System.Int32,System.Int32,DotRecast.Detour.DtMeshTile[],System.Int32)">
            Returns neighbour tile based on side.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetOffMeshConnectionPolyEndPoints(System.Int64,System.Int64,Vector3@,Vector3@)">
             Gets the endpoints for an off-mesh connection, ordered by "direction of travel".
              @param[in]		prevRef		The reference of the polygon before the connection.
              @param[in]		polyRef		The reference of the off-mesh connection polygon.
              @param[out]	startPos	The start position of the off-mesh connection. [(x, y, z)]
              @param[out]	endPos		The end position of the off-mesh connection. [(x, y, z)]
             @return The status flags for the operation.
             
             @par
            
             Off-mesh connections are stored in the navigation mesh as special 2-vertex 
             polygons with a single edge. At least one of the vertices is expected to be 
             inside a normal polygon. So an off-mesh connection is "entered" from a 
             normal polygon at one of its endpoints. This is the polygon identified by 
             the prevRef parameter.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.SetPolyFlags(System.Int64,System.Int32)">
            @{
            @name State Management
            These functions do not effect #dtTileRef or #dtPolyRef's. 
            Sets the user defined flags for the specified polygon.
             @param[in]	ref		The polygon reference.
             @param[in]	flags	The new flags for the polygon.
            @return The status flags for the operation.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetPolyFlags(System.Int64,System.Int32@)">
            Gets the user defined flags for the specified polygon.
             @param[in]		ref				The polygon reference.
             @param[out]	resultFlags		The polygon flags.
            @return The status flags for the operation.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.SetPolyArea(System.Int64,System.Char)">
            Sets the user defined area for the specified polygon.
             @param[in]	ref		The polygon reference.
             @param[in]	area	The new area id for the polygon. [Limit: DT_MAX_AREAS]
            @return The status flags for the operation.
        </member>
        <member name="M:DotRecast.Detour.DtNavMesh.GetPolyArea(System.Int64,System.Int32@)">
            Gets the user defined area for the specified polygon.
             @param[in]		ref			The polygon reference.
             @param[out]	resultArea	The area id for the polygon.
            @return The status flags for the operation.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshBuilder.CreateNavMeshData(DotRecast.Detour.DtNavMeshCreateParams)">
             @par
             
             The output data array is allocated using the detour allocator (dtAlloc()).  The method
             used to free the memory will be determined by how the tile is added to the navigation
             mesh.
            
             @see dtNavMesh, dtNavMesh::addTile()
        </member>
        <member name="T:DotRecast.Detour.DtNavMeshCreateParams">
            Represents the source data used to build an navigation mesh tile.
            @ingroup detour
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.verts">
            @name Polygon Mesh Attributes
            Used to create the base navigation graph.
            See #rcPolyMesh for details related to these attributes.
            @{
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.detailMeshes">
            @}
            @name Height Detail Attributes (Optional)
            See #rcPolyMeshDetail for details related to these attributes.
            @{
            
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConVerts">
            @}
            @name Off-Mesh Connections Attributes (Optional)
            Used to define a custom point-to-point edge within the navigation graph, an
            off-mesh connection is a user defined traversable connection made up to two vertices,
            at least one of which resides within a navigation mesh polygon.
            @{
            Off-mesh connection vertices. [(ax, ay, az, bx, by, bz) * #offMeshConCount] [Unit: wu]
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConRad">
            Off-mesh connection radii. [Size: #offMeshConCount] [Unit: wu]
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConFlags">
            User defined flags assigned to the off-mesh connections. [Size: #offMeshConCount]
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConAreas">
            User defined area ids assigned to the off-mesh connections. [Size: #offMeshConCount]
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConBidirectional">
            The permitted travel direction of the off-mesh connections. [Size: #offMeshConCount]
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConUserData">
            The user defined ids of the off-mesh connection. [Size: #offMeshConCount]
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConCount">
            The number of off-mesh connections. [Limit: >= 0]
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.userId">
            @}
            @name Tile Attributes
            @note The tile grid/layer data can be left at zero if the destination is a single tile mesh.
            @{
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.walkableHeight">
            @}
            @name General Configuration Attributes
            @{
        </member>
        <member name="F:DotRecast.Detour.DtNavMeshCreateParams.buildBvTree">
            True if a bounding volume tree should be built for the tile.
            @note The BVTree is not normally needed for layered navigation meshes.
        </member>
        <member name="T:DotRecast.Detour.DtNavMeshParams">
            Configuration parameters used to define multi-tile navigation meshes.
            The values are used to allocate space during the initialization of a navigation mesh.
            @see dtNavMesh::init()
            @ingroup detour
        </member>
        <member name="T:DotRecast.Detour.DtNavMeshQuery">
            Provides the ability to perform pathfinding related queries against
            a navigation mesh.
            @ingroup detour
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.#ctor(DotRecast.Detour.DtNavMesh)">
             @class dtNavMeshQuery
            
             For methods that support undersized buffers, if the buffer is too small 
             to hold the entire result set the return status of the method will include 
             the #DT_BUFFER_TOO_SMALL flag.
            
             Constant member functions can be used by multiple clients without side
             effects. (E.g. No change to the closed list. No impact on an in-progress
             sliced path query. Etc.)
             
             Walls and portals: A @e wall is a polygon segment that is 
             considered impassable. A @e portal is a passable segment between polygons.
             A portal may be treated as a wall based on the dtQueryFilter used for a query.
            
             @see dtNavMesh, dtQueryFilter, #dtAllocNavMeshQuery(), #dtAllocNavMeshQuery()
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindRandomPoint(DotRecast.Detour.IDtQueryFilter,System.Random,System.Int64@,Vector3@)">
            Returns random location on navmesh.
            Polygons are chosen weighted by area. The search runs in linear related to number of polygon.
             @param[in]		filter			The polygon filter to apply to the query.
             @param[in]		frand			Function returning a random number [0..1).
             @param[out]	randomRef		The reference id of the random location.
             @param[out]	randomPt		The random location. 
            @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindRandomPointAroundCircle(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Random,System.Int64@,Vector3@)">
            Returns random location on navmesh within the reach of specified location.
            Polygons are chosen weighted by area. The search runs in linear related to number of polygon.
            The location is not exactly constrained by the circle, but it limits the visited polygons.
             @param[in]		startRef		The reference id of the polygon where the search starts.
             @param[in]		centerPos		The center of the search circle. [(x, y, z)]
             @param[in]		maxRadius		The radius of the search circle. [Units: wu]
             @param[in]		filter			The polygon filter to apply to the query.
             @param[in]		frand			Function returning a random number [0..1).
             @param[out]	randomRef		The reference id of the random location.
             @param[out]	randomPt		The random location. [(x, y, z)]
            @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindRandomPointWithinCircle(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Random,System.Int64@,Vector3@)">
             Returns random location on navmesh within the reach of specified location. Polygons are chosen weighted by area.
             The search runs in linear related to number of polygon. The location is strictly constrained by the circle.
            
             @param startRef
                        The reference id of the polygon where the search starts.
             @param centerPos
                        The center of the search circle. [(x, y, z)]
             @param maxRadius
             @param filter
                        The polygon filter to apply to the query.
             @param frand
                        Function returning a random number [0..1).
             @return Random location
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindRandomPointAroundCircle(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Random,DotRecast.Detour.IDtPolygonByCircleConstraint,System.Int64@,Vector3@)">
            Returns random location on navmesh within the reach of specified location.
            Polygons are chosen weighted by area. The search runs in linear related to number of polygon.
            The location is not exactly constrained by the circle, but it limits the visited polygons.
             @param[in]		startRef		The reference id of the polygon where the search starts.
             @param[in]		centerPos		The center of the search circle. [(x, y, z)]
             @param[in]		maxRadius		The radius of the search circle. [Units: wu]
             @param[in]		filter			The polygon filter to apply to the query.
             @param[in]		frand			Function returning a random number [0..1).
             @param[in]		constraint      
             @param[out]	randomRef		The reference id of the random location.
             @param[out]	randomPt		The random location. [(x, y, z)]
            @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.ClosestPointOnPoly(System.Int64,Vector3,Vector3@,System.Boolean@)">
             @par
            
             Uses the detail polygons to find the surface height. (Most accurate.)
            
             @p pos does not have to be within the bounds of the polygon or navigation mesh.
            
             See closestPointOnPolyBoundary() for a limited but faster option.
            
             Finds the closest point on the specified polygon.
              @param[in]		ref			The reference id of the polygon.
              @param[in]		pos			The position to check. [(x, y, z)]
              @param[out]	closest		The closest point on the polygon. [(x, y, z)]
              @param[out]	posOverPoly	True of the position is over the polygon.
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.ClosestPointOnPolyBoundary(System.Int64,Vector3,Vector3@)">
             @par
            
             Much faster than ClosestPointOnPoly().
            
             If the provided position lies within the polygon's xz-bounds (above or below), 
             then @p pos and @p closest will be equal.
            
             The height of @p closest will be the polygon boundary.  The height detail is not used.
             
             @p pos does not have to be within the bounds of the polybon or the navigation mesh.
             
             Returns a point on the boundary closest to the source point if the source point is outside the 
             polygon's xz-bounds.
              @param[in]		ref			The reference id to the polygon.
              @param[in]		pos			The position to check. [(x, y, z)]
              @param[out]	closest		The closest point. [(x, y, z)]
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.GetPolyHeight(System.Int64,Vector3,System.Single@)">
             @par
            
             Will return #DT_FAILURE if the provided position is outside the xz-bounds
             of the polygon.
            
             Gets the height of the polygon at the provided position using the height detail. (Most accurate.)
             @param[in] ref The reference id of the polygon.
             @param[in] pos A position within the xz-bounds of the polygon. [(x, y, z)]
             @param[out] height The height at the surface of the polygon.
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindNearestPoly(Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Int64@,Vector3@,System.Boolean@)">
            Finds the polygon nearest to the specified center point.
            [opt] means the specified parameter can be a null pointer, in that case the output parameter will not be set.
            
             @param[in]		center		The center of the search box. [(x, y, z)]
             @param[in]		halfExtents	The search distance along each axis. [(x, y, z)]
             @param[in]		filter		The polygon filter to apply to the query.
             @param[out]	nearestRef	The reference id of the nearest polygon. Will be set to 0 if no polygon is found.
             @param[out]	nearestPt	The nearest point on the polygon. Unchanged if no polygon is found. [opt] [(x, y, z)]
             @param[out]	isOverPoly 	Set to true if the point's X/Z coordinate lies inside the polygon, false otherwise. Unchanged if no polygon is found. [opt]
            @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.QueryPolygonsInTile(DotRecast.Detour.DtMeshTile,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,DotRecast.Detour.IDtPolyQuery)">
            Queries polygons within a tile.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.QueryPolygons(Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Int64[],System.Int32@,System.Int32)">
             @par 
            
             If no polygons are found, the function will return #DT_SUCCESS with a
             @p polyCount of zero.
            
             If @p polys is too small to hold the entire result set, then the array will 
             be filled to capacity. The method of choosing which polygons from the 
             full set are included in the partial result set is undefined.
            
             Finds polygons that overlap the search box.
              @param[in]		center		The center of the search box. [(x, y, z)]
              @param[in]		halfExtents		The search distance along each axis. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[out]	polys		The reference ids of the polygons that overlap the query box.
              @param[out]	polyCount	The number of polygons in the search result.
              @param[in]		maxPolys	The maximum number of polygons the search result can hold.
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.QueryPolygons(Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,DotRecast.Detour.IDtPolyQuery)">
             @par 
            
             The query will be invoked with batches of polygons. Polygons passed
             to the query have bounding boxes that overlap with the center and halfExtents
             passed to this function. The dtPolyQuery::process function is invoked multiple
             times until all overlapping polygons have been processed.
            
             Finds polygons that overlap the search box.
              @param[in]		center		The center of the search box. [(x, y, z)]
              @param[in]		halfExtents		The search distance along each axis. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[in]		query		The query. Polygons found will be batched together and passed to this query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindPath(System.Int64,System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Collections.Generic.List{System.Int64}@,DotRecast.Detour.DtFindPathOption)">
             @par
            
             If the end polygon cannot be reached through the navigation graph,
             the last polygon in the path will be the nearest the end polygon.
            
             If the path array is to small to hold the full result, it will be filled as 
             far as possible from the start polygon toward the end polygon.
            
             The start and end positions are used to calculate traversal costs. 
             (The y-values impact the result.)
            
             @name Standard Pathfinding Functions
             @{
             Finds a path from the start polygon to the end polygon.
              @param[in]		startRef	The reference id of the start polygon.
              @param[in]		endRef		The reference id of the end polygon.
              @param[in]		startPos	A position within the start polygon. [(x, y, z)]
              @param[in]		endPos		A position within the end polygon. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[out]	path		An ordered list of polygon references representing the path. (Start to end.) 
              							[(polyRef) * @p pathCount]
              @param[out]	pathCount	The number of polygons returned in the @p path array.
              @param[in]		maxPath		The maximum number of polygons the @p path array can hold. [Limit: >= 1]
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.InitSlicedFindPath(System.Int64,System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Int32)">
            @}
             @name Sliced Pathfinding Functions
             Common use case:
            	-# Call initSlicedFindPath() to initialize the sliced path query.
            	-# Call updateSlicedFindPath() until it returns complete.
            	-# Call finalizeSlicedFindPath() to get the path.
            @{ 
             Initializes a sliced path query.
              @param[in]		startRef	The reference id of the start polygon.
              @param[in]		endRef		The reference id of the end polygon.
              @param[in]		startPos	A position within the start polygon. [(x, y, z)]
              @param[in]		endPos		A position within the end polygon. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[in]		options		query options (see: #dtFindPathOptions)
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.UpdateSlicedFindPath(System.Int32,System.Int32@)">
            Updates an in-progress sliced path query.
             @param[in]		maxIter		The maximum number of iterations to perform.
             @param[out]	doneIters	The actual number of iterations completed. [opt]
            @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FinalizeSlicedFindPath(System.Collections.Generic.List{System.Int64}@)">
            Finalizes and returns the results of a sliced path query.
             @param[out]	path		An ordered list of polygon references representing the path. (Start to end.) 
             							[(polyRef) * @p pathCount]
             @param[out]	pathCount	The number of polygons returned in the @p path array.
             @param[in]		maxPath		The max number of polygons the path array can hold. [Limit: >= 1]
            @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FinalizeSlicedFindPathPartial(System.Collections.Generic.List{System.Int64},System.Int32,System.Collections.Generic.List{System.Int64}@)">
            Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest
            polygon on the existing path that was visited during the search.
             @param[in]		existing		An array of polygon references for the existing path.
             @param[in]		existingSize	The number of polygon in the @p existing array.
             @param[out]	path			An ordered list of polygon references representing the path. (Start to end.) 
             								[(polyRef) * @p pathCount]
             @param[out]	pathCount		The number of polygons returned in the @p path array.
             @param[in]		maxPath			The max number of polygons the @p path array can hold. [Limit: >= 1]
            @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindStraightPath(Vector3,Vector3,System.Collections.Generic.List{System.Int64},System.Int32,System.Span{DotRecast.Detour.DtStraightPath},System.Int32@,System.Int32,System.Int32)">
             @par
             
             This method peforms what is often called 'string pulling'.
            
             The start position is clamped to the first polygon in the path, and the 
             end position is clamped to the last. So the start and end positions should 
             normally be within or very near the first and last polygons respectively.
            
             The returned polygon references represent the reference id of the polygon 
             that is entered at the associated path position. The reference id associated 
             with the end point will always be zero.  This allows, for example, matching 
             off-mesh link points to their representative polygons.
            
             If the provided result buffers are too small for the entire result set, 
             they will be filled as far as possible from the start toward the end 
             position.
            
             Finds the straight path from the start to the end position within the polygon corridor.
              @param[in]		startPos			Path start position. [(x, y, z)]
              @param[in]		endPos				Path end position. [(x, y, z)]
              @param[in]		path				An array of polygon references that represent the path corridor.
              @param[in]		pathSize			The number of polygons in the @p path array.
              @param[out]	straightPath		Points describing the straight path. [(x, y, z) * @p straightPathCount].
              @param[in]		maxStraightPath		The maximum number of points the straight path arrays can hold.  [Limit: > 0]
              @param[in]		options				Query options. (see: #dtStraightPathOptions)
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.MoveAlongSurface(System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,Vector3@,System.Span{System.Int64},System.Int32@,System.Int32)">
             @par
            
             This method is optimized for small delta movement and a small number of 
             polygons. If used for too great a distance, the result set will form an 
             incomplete path.
            
             @p resultPos will equal the @p endPos if the end is reached. 
             Otherwise the closest reachable position will be returned.
             
             @p resultPos is not projected onto the surface of the navigation 
             mesh. Use #getPolyHeight if this is needed.
            
             This method treats the end position in the same manner as 
             the #raycast method. (As a 2D point.) See that method's documentation 
             for details.
             
             If the @p visited array is too small to hold the entire result set, it will 
             be filled as far as possible from the start position toward the end 
             position.
            
             Moves from the start to the end position constrained to the navigation mesh.
              @param[in]		startRef		The reference id of the start polygon.
              @param[in]		startPos		A position of the mover within the start polygon. [(x, y, x)]
              @param[in]		endPos			The desired end position of the mover. [(x, y, z)]
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	resultPos		The result position of the mover. [(x, y, z)]
              @param[out]	visited			The reference ids of the polygons visited during the move.
              @param[out]	visitedCount	The number of polygons visited during the move.
              @param[in]		maxVisitedSize	The maximum number of polygons the @p visited array can hold.
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.Raycast(System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Single@,Vector3@,System.Collections.Generic.List{System.Int64}@)">
             @par
            
             This method is meant to be used for quick, short distance checks.
            
             If the path array is too small to hold the result, it will be filled as 
             far as possible from the start postion toward the end position.
            
             <b>Using the Hit Parameter (t)</b>
             
             If the hit parameter is a very high value (FLT_MAX), then the ray has hit 
             the end position. In this case the path represents a valid corridor to the 
             end position and the value of @p hitNormal is undefined.
            
             If the hit parameter is zero, then the start position is on the wall that 
             was hit and the value of @p hitNormal is undefined.
            
             If 0 &lt; t &lt; 1.0 then the following applies:
            
             @code
             distanceToHitBorder = distanceToEndPosition * t
             hitPoint = startPos + (endPos - startPos) * t
             @endcode
            
             <b>Use Case Restriction</b>
            
             The raycast ignores the y-value of the end position. (2D check.) This 
             places significant limits on how it can be used. For example:
            
             Consider a scene where there is a main floor with a second floor balcony 
             that hangs over the main floor. So the first floor mesh extends below the 
             balcony mesh. The start position is somewhere on the first floor. The end 
             position is on the balcony.
            
             The raycast will search toward the end position along the first floor mesh. 
             If it reaches the end position's xz-coordinates it will indicate FLT_MAX
             (no wall hit), meaning it reached the end position. This is one example of why
             this method is meant for short distance checks.
            
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.Raycast(System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Int32,DotRecast.Detour.DtRaycastHit@,System.Int64)">
             @par
            
             This method is meant to be used for quick, short distance checks.
            
             If the path array is too small to hold the result, it will be filled as 
             far as possible from the start postion toward the end position.
            
             <b>Using the Hit Parameter t of RaycastHit</b>
             
             If the hit parameter is a very high value (FLT_MAX), then the ray has hit 
             the end position. In this case the path represents a valid corridor to the 
             end position and the value of @p hitNormal is undefined.
            
             If the hit parameter is zero, then the start position is on the wall that 
             was hit and the value of @p hitNormal is undefined.
            
             If 0 &lt; t &lt; 1.0 then the following applies:
            
             @code
             distanceToHitBorder = distanceToEndPosition * t
             hitPoint = startPos + (endPos - startPos) * t
             @endcode
            
             <b>Use Case Restriction</b>
            
             The raycast ignores the y-value of the end position. (2D check.) This 
             places significant limits on how it can be used. For example:
            
             Consider a scene where there is a main floor with a second floor balcony 
             that hangs over the main floor. So the first floor mesh extends below the 
             balcony mesh. The start position is somewhere on the first floor. The end 
             position is on the balcony.
            
             The raycast will search toward the end position along the first floor mesh. 
             If it reaches the end position's xz-coordinates it will indicate FLT_MAX
             (no wall hit), meaning it reached the end position. This is one example of why
             this method is meant for short distance checks.
            
             Casts a 'walkability' ray along the surface of the navigation mesh from 
             the start position toward the end position.
              @param[in]		startRef	The reference id of the start polygon.
              @param[in]		startPos	A position within the start polygon representing 
              							the start of the ray. [(x, y, z)]
              @param[in]		endPos		The position to cast the ray toward. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[in]		options		govern how the raycast behaves. See dtRaycastOptions
              @param[out]	hit			Pointer to a raycast hit structure which will be filled by the results.
              @param[in]		prevRef		parent of start ref. Used during for cost calculation [opt]
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindPolysAroundCircle(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Single}@)">
             @par
            
             At least one result array must be provided.
            
             The order of the result set is from least to highest cost to reach the polygon.
            
             A common use case for this method is to perform Dijkstra searches.
             Candidate polygons are found by searching the graph beginning at the start polygon.
            
             If a polygon is not found via the graph search, even if it intersects the
             search circle, it will not be included in the result set. For example:
            
             polyA is the start polygon.
             polyB shares an edge with polyA. (Is adjacent.)
             polyC shares an edge with polyB, but not with polyA
             Even if the search circle overlaps polyC, it will not be included in the
             result set unless polyB is also in the set.
            
             The value of the center point is used as the start position for cost
             calculations. It is not projected onto the surface of the mesh, so its
             y-value will effect the costs.
            
             Intersection tests occur in 2D. All polygons and the search circle are
             projected onto the xz-plane. So the y-value of the center point does not
             effect intersection tests.
            
             If the result arrays are to small to hold the entire result set, they will be
             filled to capacity.
            
            @}
             @name Dijkstra Search Functions
             @{ 
             Finds the polygons along the navigation graph that touch the specified circle.
              @param[in]		startRef		The reference id of the polygon where the search starts.
              @param[in]		centerPos		The center of the search circle. [(x, y, z)]
              @param[in]		radius			The radius of the search circle.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	resultRef		The reference ids of the polygons touched by the circle. [opt]
              @param[out]	resultParent	The reference ids of the parent polygons for each result. 
              								Zero if a result polygon has no parent. [opt]
              @param[out]	resultCost		The search cost from @p centerPos to the polygon. [opt]
              @param[out]	resultCount		The number of polygons found. [opt]
              @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindPolysAroundShape(System.Int64,Vector3[],DotRecast.Detour.IDtQueryFilter,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Single}@)">
             @par
            
             The order of the result set is from least to highest cost.
             
             At least one result array must be provided.
            
             A common use case for this method is to perform Dijkstra searches. 
             Candidate polygons are found by searching the graph beginning at the start 
             polygon.
             
             The same intersection test restrictions that apply to findPolysAroundCircle()
             method apply to this method.
             
             The 3D centroid of the search polygon is used as the start position for cost 
             calculations.
             
             Intersection tests occur in 2D. All polygons are projected onto the 
             xz-plane. So the y-values of the vertices do not effect intersection tests.
             
             If the result arrays are is too small to hold the entire result set, they will 
             be filled to capacity.
            
             Finds the polygons along the naviation graph that touch the specified convex polygon.
              @param[in]		startRef		The reference id of the polygon where the search starts.
              @param[in]		verts			The vertices describing the convex polygon. (CCW) 
              								[(x, y, z) * @p nverts]
              @param[in]		nverts			The number of vertices in the polygon.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	resultRef		The reference ids of the polygons touched by the search polygon. [opt]
              @param[out]	resultParent	The reference ids of the parent polygons for each result. Zero if a 
              								result polygon has no parent. [opt]
              @param[out]	resultCost		The search cost from the centroid point to the polygon. [opt]
              @param[out]	resultCount		The number of polygons found.
              @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindLocalNeighbourhood(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Int64}@)">
             @par
            
             This method is optimized for a small search radius and small number of result 
             polygons.
            
             Candidate polygons are found by searching the navigation graph beginning at 
             the start polygon.
            
             The same intersection test restrictions that apply to the findPolysAroundCircle 
             mehtod applies to this method.
            
             The value of the center point is used as the start point for cost calculations. 
             It is not projected onto the surface of the mesh, so its y-value will effect 
             the costs.
             
             Intersection tests occur in 2D. All polygons and the search circle are 
             projected onto the xz-plane. So the y-value of the center point does not 
             effect intersection tests.
             
             If the result arrays are is too small to hold the entire result set, they will 
             be filled to capacity.
             
             Finds the non-overlapping navigation polygons in the local neighbourhood around the center position.
              @param[in]		startRef		The reference id of the polygon where the search starts.
              @param[in]		centerPos		The center of the query circle. [(x, y, z)]
              @param[in]		radius			The radius of the query circle.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	resultRef		The reference ids of the polygons touched by the circle.
              @param[out]	resultParent	The reference ids of the parent polygons for each result. 
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.GetPolyWallSegments(System.Int64,DotRecast.Detour.IDtQueryFilter,System.Span{DotRecast.Detour.RcSegmentVert},System.Span{System.Int64},System.Int32@,System.Int32)">
             @par
            
             If the @p segmentRefs parameter is provided, then all polygon segments will be returned. 
             Otherwise only the wall segments are returned.
             
             A segment that is normally a portal will be included in the result set as a 
             wall if the @p filter results in the neighbor polygon becoomming impassable.
             
             The @p segmentVerts and @p segmentRefs buffers should normally be sized for the 
             maximum segments per polygon of the source navigation mesh.
             
             Returns the segments for the specified polygon, optionally including portals.
              @param[in]		ref				The reference id of the polygon.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	segmentVerts	The segments. [(ax, ay, az, bx, by, bz) * segmentCount]
              @param[out]	segmentRefs		The reference ids of each segment's neighbor polygon. 
              								Or zero if the segment is a wall. [opt] [(parentRef) * @p segmentCount] 
              @param[out]	segmentCount	The number of segments returned.
              @param[in]		maxSegments		The maximum number of segments the result arrays can hold.
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.FindDistanceToWall(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Single@,Vector3@,Vector3@)">
             @par
            
             @p hitPos is not adjusted using the height detail data.
            
             @p hitDist will equal the search radius if there is no wall within the
             radius. In this case the values of @p hitPos and @p hitNormal are
             undefined.
            
             The normal will become unpredicable if @p hitDist is a very small number.
            
             Finds the distance from the specified position to the nearest polygon wall.
              @param[in]		startRef		The reference id of the polygon containing @p centerPos.
              @param[in]		centerPos		The center of the search circle. [(x, y, z)]
              @param[in]		maxRadius		The radius of the search circle.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	hitDist			The distance to the nearest wall from @p centerPos.
              @param[out]	hitPos			The nearest position on the wall that was hit. [(x, y, z)]
              @param[out]	hitNormal		The normalized ray formed from the wall point to the 
              								source point. [(x, y, z)]
             @returns The status flags for the query.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.IsValidPolyRef(System.Int64,DotRecast.Detour.IDtQueryFilter)">
            Returns true if the polygon reference is valid and passes the filter restrictions.
            @param[in] ref The polygon reference to check.
            @param[in] filter The filter to apply.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.GetAttachedNavMesh">
            Gets the navigation mesh the query object is using.
            @return The navigation mesh the query object is using.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.GetPathFromDijkstraSearch(System.Int64,System.Collections.Generic.List{System.Int64}@)">
            Gets a path from the explored nodes in the previous search.
             @param[in]		endRef		The reference id of the end polygon.
             @param[out]	path		An ordered list of polygon references representing the path. (Start to end.)
             							[(polyRef) * @p pathCount]
             @param[out]	pathCount	The number of polygons returned in the @p path array.
             @param[in]		maxPath		The maximum number of polygons the @p path array can hold. [Limit: >= 0]
             @returns		The status flags. Returns DT_FAILURE | DT_INVALID_PARAM if any parameter is wrong, or if
             				@p endRef was not explored in the previous search. Returns DT_SUCCESS | DT_BUFFER_TOO_SMALL
             				if @p path cannot contain the entire path. In this case it is filled to capacity with a partial path.
             				Otherwise returns DT_SUCCESS.
             @remarks		The result of this function depends on the state of the query object. For that reason it should only
             				be used immediately after one of the two Dijkstra searches, findPolysAroundCircle or findPolysAroundShape.
        </member>
        <member name="M:DotRecast.Detour.DtNavMeshQuery.IsInClosedList(System.Int64)">
             @par
            
             The closed list is the list of polygons that were fully evaluated during 
             the last navigation graph search. (A* or Dijkstra)
             
        </member>
        <member name="T:DotRecast.Detour.DtNavMeshRaycast">
            Simple helper to find an intersection between a ray and a nav mesh
        </member>
        <member name="T:DotRecast.Detour.DtOffMeshConnection">
            Defines an navigation mesh off-mesh connection within a dtMeshTile object.
            An off-mesh connection is a user defined traversable connection made up to two vertices.
        </member>
        <member name="F:DotRecast.Detour.DtOffMeshConnection.rad">
            The radius of the endpoints. [Limit: >= 0]
        </member>
        <member name="F:DotRecast.Detour.DtOffMeshConnection.poly">
            The polygon reference of the connection within the tile.
        </member>
        <member name="F:DotRecast.Detour.DtOffMeshConnection.side">
            End point side.
        </member>
        <member name="F:DotRecast.Detour.DtOffMeshConnection.userData">
            The id of the offmesh connection. (User assigned when the navigation mesh is built.)
        </member>
        <member name="T:DotRecast.Detour.DtPoly">
            Defines a polygon within a dtMeshTile object.
            @ingroup detour
        </member>
        <member name="F:DotRecast.Detour.DtPoly.firstLink">
            Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)
        </member>
        <member name="F:DotRecast.Detour.DtPoly.verts">
            The indices of the polygon's vertices.
            The actual vertices are located in dtMeshTile::verts.
        </member>
        <member name="F:DotRecast.Detour.DtPoly.neis">
            Packed data representing neighbor polygons references and flags for each edge.
        </member>
        <member name="F:DotRecast.Detour.DtPoly.flags">
            The user defined polygon flags.
        </member>
        <member name="F:DotRecast.Detour.DtPoly.vertCount">
            The number of vertices in the polygon.
        </member>
        <member name="F:DotRecast.Detour.DtPoly.areaAndtype">
            The bit packed area id and polygon type.
            @note Use the structure's set and get methods to access this value.
        </member>
        <member name="M:DotRecast.Detour.DtPoly.SetArea(System.Int32)">
            Sets the user defined area id. [Limit: &lt; #DT_MAX_AREAS]
        </member>
        <member name="M:DotRecast.Detour.DtPoly.SetPolyType(System.Int32)">
            Sets the polygon type. (See: #dtPolyTypes.)
        </member>
        <member name="M:DotRecast.Detour.DtPoly.GetArea">
            Gets the user defined area id.
        </member>
        <member name="M:DotRecast.Detour.DtPoly.GetPolyType">
            Gets the polygon type. (See: #dtPolyTypes)
        </member>
        <member name="T:DotRecast.Detour.DtPolyDetail">
            Defines the location of detail sub-mesh data within a dtMeshTile.
        </member>
        <member name="T:DotRecast.Detour.DtPolyTypes">
            Flags representing the type of a navigation mesh polygon.
        </member>
        <member name="T:DotRecast.Detour.DtQueryDefaultFilter">
             <b>The Default Implementation</b>
            
             At construction: All area costs default to 1.0. All flags are included and none are excluded.
            
             If a polygon has both an include and an exclude flag, it will be excluded.
            
             The way filtering works, a navigation mesh polygon must have at least one flag set to ever be considered by a query.
             So a polygon with no flags will never be considered.
            
             Setting the include flags to 0 will result in all polygons being excluded.
            
             <b>Custom Implementations</b>
            
             Implement a custom query filter by overriding the virtual PassFilter() and GetCost() functions. If this is done, both
             functions should be as fast as possible. Use cached local copies of data rather than accessing your own objects where
             possible.
            
             Custom implementations do not need to adhere to the flags or cost logic used by the default implementation.
            
             In order for A* searches to work properly, the cost should be proportional to the travel distance. Implementing a
             cost modifier less than 1.0 is likely to lead to problems during pathfinding.
            
             @see NavMeshQuery
        </member>
        <member name="T:DotRecast.Detour.DtRaycastHit">
            Provides information about raycast hit
            filled by dtNavMeshQuery::raycast
            @ingroup detour
        </member>
        <member name="F:DotRecast.Detour.DtRaycastHit.t">
            The hit parameter. (FLT_MAX if no wall hit.)
        </member>
        <member name="F:DotRecast.Detour.DtRaycastHit.hitNormal">
            hitNormal	The normal of the nearest wall hit. [(x, y, z)]
        </member>
        <member name="F:DotRecast.Detour.DtRaycastHit.hitEdgeIndex">
            The index of the edge on the final polygon where the wall was hit.
        </member>
        <member name="F:DotRecast.Detour.DtRaycastHit.path">
            Pointer to an array of reference ids of the visited polygons. [opt]
        </member>
        <member name="F:DotRecast.Detour.DtRaycastHit.pathCost">
             The cost of the path until hit.
        </member>
        <member name="T:DotRecast.Detour.DtRaycastOptions">
            Options for dtNavMeshQuery::raycast
        </member>
        <member name="F:DotRecast.Detour.DtStraightPath.pos">
            The local path corridor corners for the agent. (Staight path.) [(x, y, z) * #ncorners]
        </member>
        <member name="F:DotRecast.Detour.DtStraightPath.flags">
            The local path corridor corner flags. (See: #dtStraightPathFlags) [(flags) * #ncorners]
        </member>
        <member name="F:DotRecast.Detour.DtStraightPath.refs">
            The reference id of the polygon being entered at the corner. [(polyRef) * #ncorners]
        </member>
        <member name="T:DotRecast.Detour.DtStraightPathFlags">
            Vertex flags returned by dtNavMeshQuery::findStraightPath.
        </member>
        <member name="T:DotRecast.Detour.DtStraightPathOptions">
            Options for dtNavMeshQuery::findStraightPath.
        </member>
        <member name="M:DotRecast.Detour.DtUtils.OverlapQuantBounds(Vector3Int@,Vector3Int@,Vector3Int@,Vector3Int@)">
            Determines if two axis-aligned bounding boxes overlap.
            @param[in] amin Minimum bounds of box A. [(x, y, z)]
            @param[in] amax Maximum bounds of box A. [(x, y, z)]
            @param[in] bmin Minimum bounds of box B. [(x, y, z)]
            @param[in] bmax Maximum bounds of box B. [(x, y, z)]
            @return True if the two AABB's overlap.
            @see dtOverlapBounds
        </member>
        <member name="M:DotRecast.Detour.DtUtils.OverlapBounds(Vector3,Vector3,Vector3,Vector3)">
            Determines if two axis-aligned bounding boxes overlap.
            @param[in] amin Minimum bounds of box A. [(x, y, z)]
            @param[in] amax Maximum bounds of box A. [(x, y, z)]
            @param[in] bmin Minimum bounds of box B. [(x, y, z)]
            @param[in] bmax Maximum bounds of box B. [(x, y, z)]
            @return True if the two AABB's overlap.
            @see dtOverlapQuantBounds
        </member>
        <member name="M:DotRecast.Detour.DtUtils.OverlapPolyPoly2D(System.Span{Vector3},System.Span{Vector3})">
             @par
            
             All vertices are projected onto the xz-plane, so the y-values are ignored.
        </member>
        <member name="M:DotRecast.Detour.DtUtils.TriArea2D(Vector3,Vector3,Vector3)">
            @}
            @name Computational geometry helper functions.
            @{
            Derives the signed xz-plane area of the triangle ABC, or the
            relationship of line AB to point C.
            @param[in] a Vertex A. [(x, y, z)]
            @param[in] b Vertex B. [(x, y, z)]
            @param[in] c Vertex C. [(x, y, z)]
            @return The signed xz-plane area of the triangle.
        </member>
        <member name="M:DotRecast.Detour.DtUtils.PointInPolygon(Vector3,System.Span{Vector3})">
             @par
            
             All points are projected onto the xz-plane, so the y-values are ignored.
        </member>
        <member name="M:DotRecast.Detour.DtUtils.Perp2D(Vector3,Vector3)">
             Derives the xz-plane 2D perp product of the two vectors. (uz*vx - ux*vz)
             @param[in] u The LHV vector [(x, y, z)]
             @param[in] v The RHV vector [(x, y, z)]
             @return The dot product on the xz-plane.
            
             The vectors are projected onto the xz-plane, so the y-values are
             ignored.
             TODO should be called DOT2D
        </member>
        <member name="T:DotRecast.Detour.IDtPolyQuery">
            Provides custom polygon query behavior.
            Used by dtNavMeshQuery::queryPolygons.
            @ingroup detour
        </member>
        <member name="M:DotRecast.Detour.IDtPolyQuery.Process(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtPoly[],System.Span{System.Int64},System.Int32)">
            Called for each batch of unique polygons touched by the search area in dtNavMeshQuery::queryPolygons.
            This can be called multiple times for a single query.
        </member>
        <member name="F:NavMeshParams_t.tileSizeXY">
            <summary>
            The size of the tiles on the xz-plane. [Limit: &gt;= 0]
            </summary>
        </member>
        <member name="F:NavMeshParams_t.maxTiles">
            <summary>
            The number of tiles along the xy axis.
            </summary>
        </member>
        <member name="F:NavMeshParams_t.origin">
            <summary>
            The world space origin of the navigation mesh's tile space. [(x, y, z)]
            </summary>
        </member>
        <member name="F:NavMeshParams_t.maxAgentRadius">
            <summary>
            The maximum radius of any agent that will be added to the crowd. [Limit: > 0]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.tileX">
            <summary>
            The tiles x position in tile coordinates.
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.tileY">
            <summary>
            The tiles y position in tile coordinates.
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.tileSizeXY">
            <summary>
            The width/height size of tile's on the xy-plane. [Limit: &gt;= 0] [Units: vx]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.borderSize">
            <summary>
            The size of the non-navigable border around the heightfield. [Limit: &gt;=0] [Units: vx]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.cellSize">
            <summary>
            The xz-plane cell size to use for fields. [Limit: &gt; 0] [Units: wu]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.cellHeight">
            <summary>
            The y-axis cell size to use for fields. [Limit: &gt; 0] [Units: wu]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.bounds">
            <summary>
            The bounds of the field's AABB. [Units: wu]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.walkableSlopeAngle">
            <summary>
            The maximum slope that is considered walkable. [Limits: 0 &lt;= value &lt; 90] [Units: Degrees]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.walkableHeight">
            <summary>
            Minimum floor to 'ceiling' height that will still allow the floor area to 
            be considered walkable. [Limit: &gt;= 3] [Units: vx]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.walkableClimb">
            <summary>
            Maximum ledge height that is considered to still be traversable. [Limit: &gt;=0] [Units: vx]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.walkableRadius">
            <summary>
            The distance to erode/shrink the walkable area of the heightfield away from 
            obstructions.  [Limit: &gt;=0] [Units: vx]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.maxEdgeLen">
            <summary>
            The maximum allowed length for contour edges along the border of the mesh. [Limit: &gt;=0] [Units: vx]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.maxSimplificationError">
            <summary>
            The maximum distance a simplified contour's border edges should deviate 
            the original raw contour. [Limit: &gt;=0] [Units: vx]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.minRegionArea">
            <summary>
            The minimum number of cells allowed to form isolated island areas. [Limit: &gt;=0] [Units: vx]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.mergeRegionArea">
            <summary>
            Any regions with a span count smaller than this value will, if possible, 
            be merged with larger regions. [Limit: &gt;=0] [Units: vx]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.maxVertsPerPoly">
            <summary>
            The maximum number of vertices allowed for polygons generated during the 
            contour to polygon conversion process. [Limit: &gt;= 3] 
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.detailSampleDist">
            <summary>
            Sets the sampling distance to use when generating the detail mesh.
            (For height detail only.) [Limits: 0 or &gt;= 0.9] [Units: wu]
            </summary>
        </member>
        <member name="F:NavTileGenConfig_t.detailSampleMaxError">
            <summary>
            The maximum distance the detail mesh surface should deviate from heightfield
            data. (For height detail only.) [Limit: &gt;=0] [Units: wu]
            </summary>
        </member>
        <member name="T:SamplerStateHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:SwapChainHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_AsyncGPUReadback_DispatchManagedReadTextureCallback(System.IntPtr,System.IntPtr,System.Int64,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.AsyncGPUReadback.DispatchManagedReadTextureCallback( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_AsyncGPUReadback_DispatchManagedReadBufferCallback(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.AsyncGPUReadback.DispatchManagedReadBufferCallback( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxAudio_MixingThread_MixOneBuffer">
            <summary>
            Sandbox.Audio.MixingThread.MixOneBuffer( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_ConVarSystem_RegisterNativeVar(System.IntPtr)">
            <summary>
            Sandbox.ConVarSystem.RegisterNativeVar( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_ConVarSystem_RegisterNativeCommand(System.IntPtr)">
            <summary>
            Sandbox.ConVarSystem.RegisterNativeCommand( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_ConVarSystem_OnConVarChanged(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ConVarSystem.OnConVarChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxDgnstcs_Logging_RegisterEngineLogger(System.Int32,System.IntPtr)">
            <summary>
            Sandbox.Diagnostics.Logging.RegisterEngineLogger( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_Bootstrap_EnvironmentExit(System.Int32)">
            <summary>
            Sandbox.Engine.Bootstrap.EnvironmentExit( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMouseMotion(System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnMouseMotion( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMousePositionChange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnMousePositionChange( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMouseButton(System.Int64,System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnMouseButton( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnKey(System.Int64,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnKey( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnText(System.UInt32)">
            <summary>
            Sandbox.Engine.InputRouter.OnText( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnWindowActive(System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnWindowActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMouseWheel(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnMouseWheel( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnImeStart">
            <summary>
            Sandbox.Engine.InputRouter.OnImeStart( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnImeComposition(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnImeComposition( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnImeEnd">
            <summary>
            Sandbox.Engine.InputRouter.OnImeEnd( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerButton(System.Int32,System.Int64,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnGameControllerButton( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerAxis(System.Int32,System.Int64,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnGameControllerAxis( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerConnected(System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnGameControllerConnected( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerDisconnected(System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnGameControllerDisconnected( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnConsoleCommand(System.IntPtr)">
            <summary>
            Sandbox.Engine.InputRouter.OnConsoleCommand( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_CloseApplication">
            <summary>
            Sandbox.Engine.InputRouter.CloseApplication( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_SystemInfo_Set(System.IntPtr,System.UInt16,System.UInt64,System.UInt64)">
            <summary>
            Sandbox.Engine.SystemInfo.Set( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_SystemInfo_SetGpu(System.IntPtr,System.IntPtr,System.UInt64)">
            <summary>
            Sandbox.Engine.SystemInfo.SetGpu( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_Print(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.Print( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_DispatchConsoleCommand(System.IntPtr,System.IntPtr,System.Int64)">
            <summary>
            Sandbox.EngineLoop.DispatchConsoleCommand( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_OnClientOutput">
            <summary>
            Sandbox.EngineLoop.OnClientOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_OnPresent">
            <summary>
            Sandbox.EngineLoop.OnPresent( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_OnSceneViewSubmitted(System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.OnSceneViewSubmitted( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Graphics_OnLayer(System.Int32,ManagedRenderSetup_t)">
            <summary>
            Sandbox.Graphics.OnLayer( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_HandleIndex_RegisterHandle(System.IntPtr,System.UInt32)">
            <summary>
            Sandbox.HandleIndex.RegisterHandle( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_HandleIndex_FreeHandle(System.Int32)">
            <summary>
            Sandbox.HandleIndex.FreeHandle( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnLobbyInvite(System.UInt64,System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnLobbyInvite( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnMemberEntered(System.UInt64,System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnMemberEntered( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnMemberLeave(System.UInt64,System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnMemberLeave( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnEntered(System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnEntered( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnCreated(System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnDataUpdate(System.UInt64,System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnChatMessage(System.UInt64,System.UInt64,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.LobbyManager.OnChatMessage( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSocketConnection(Sandbox.Network.HSteamListenSocket,Sandbox.Network.HSteamNetConnection)">
            <summary>
            Sandbox.Network.SteamNetwork.OnSocketConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSocketDisconnection(Sandbox.Network.HSteamListenSocket,Sandbox.Network.HSteamNetConnection)">
            <summary>
            Sandbox.Network.SteamNetwork.OnSocketDisconnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_ShouldAcceptConnection(Sandbox.Network.HSteamListenSocket,Sandbox.Network.HSteamNetConnection)">
            <summary>
            Sandbox.Network.SteamNetwork.ShouldAcceptConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnDisconnection(Sandbox.Network.HSteamNetConnection,System.Int32,System.IntPtr)">
            <summary>
            Sandbox.Network.SteamNetwork.OnDisconnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSessionEstablished(System.UInt64)">
            <summary>
            Sandbox.Network.SteamNetwork.OnSessionEstablished( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSessionFailed(Sandbox.Network.HSteamListenSocket,System.UInt64)">
            <summary>
            Sandbox.Network.SteamNetwork.OnSessionFailed( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxPhysics_PhysicsEngine_OnPhysicsJointBreak(System.Int32)">
            <summary>
            Sandbox.Physics.PhysicsEngine.OnPhysicsJointBreak( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxPhysics_PhysicsEngine_OnActive(System.Int32,Transform,Vector3,Vector3)">
            <summary>
            Sandbox.Physics.PhysicsEngine.OnActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_RealTime_Update(System.Single)">
            <summary>
            Sandbox.RealTime.Update( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxRndrng_RenderPipeline_InternalAddLayersToView(System.IntPtr,NativeEngine.RenderViewport,System.IntPtr,System.IntPtr,System.Int64,System.IntPtr,NativeEngine.RenderViewport)">
            <summary>
            Sandbox.Rendering.RenderPipeline.InternalAddLayersToView( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_RenderTarget_Flush">
            <summary>
            Sandbox.RenderTarget.Flush( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Resource_OnResourceReloaded(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Resource.OnResourceReloaded( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_ScnCstmbjctRndr_RenderObject(ManagedRenderSetup_t,System.Int32)">
            <summary>
            Sandbox.SceneCustomObjectRender.RenderObject( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_SceneSystem_OnBeforeRender(System.Int32,ManagedRenderSetup_t)">
            <summary>
            Sandbox.SceneSystem.OnBeforeRender( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_SceneSystem_OnAfterRender(System.Int32,ManagedRenderSetup_t)">
            <summary>
            Sandbox.SceneSystem.OnAfterRender( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_ScreenRecorder_RecordVideoFrame(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ScreenRecorder.RecordVideoFrame( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_ScreenRecorder_IsRecording">
            <summary>
            Sandbox.ScreenRecorder.IsRecording( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_ScrnshtSrvc_ProcessFrame(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ScreenshotService.ProcessFrame( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_Inventory_OnDefinitionUpdate">
            <summary>
            Sandbox.Services.Inventory.OnDefinitionUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_Inventory_OnPricesUpdate(System.Int32,System.IntPtr)">
            <summary>
            Sandbox.Services.Inventory.OnPricesUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_Inventory_OnPurchaseResult(System.Int32,System.UInt64,System.UInt64)">
            <summary>
            Sandbox.Services.Inventory.OnPurchaseResult( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_ServerList_OnStarted(System.UInt32)">
            <summary>
            Sandbox.Services.ServerList.OnStarted( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_ServerList_OnServerResponded(System.UInt32,System.IntPtr,System.UInt64)">
            <summary>
            Sandbox.Services.ServerList.OnServerResponded( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_ServerList_OnFinished(System.UInt32)">
            <summary>
            Sandbox.Services.ServerList.OnFinished( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnTextureCreatedInternal(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.OnTextureCreatedInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnInitAudioInternal(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Sandbox.VideoPlayer.OnInitAudioInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnFreeAudioInternal(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.OnFreeAudioInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnTextureDataInternal(System.UInt32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.VideoPlayer.OnTextureDataInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnLoadedInternal(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.OnLoadedInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_WantsTextureData(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.WantsTextureData( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnFinishedInternal(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.OnFinishedInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnRepeatedInternal(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.OnRepeatedInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_InternalIsActive">
            <summary>
            Sandbox.VR.VRSystem.InternalIsActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_InternalWantsInit">
            <summary>
            Sandbox.VR.VRSystem.InternalWantsInit( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_BeginFrame">
            <summary>
            Sandbox.VR.VRSystem.BeginFrame( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_EndFrame">
            <summary>
            Sandbox.VR.VRSystem.EndFrame( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_Submit(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.VR.VRSystem.Submit( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_GetVulkanInstanceExtensionsRequired">
            <summary>
            Sandbox.VR.VRSystem.GetVulkanInstanceExtensionsRequired( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_GetVulkanDeviceExtensionsRequired">
            <summary>
            Sandbox.VR.VRSystem.GetVulkanDeviceExtensionsRequired( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_RenderOverlays">
            <summary>
            Sandbox.VR.VRSystem.RenderOverlays( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Steamworks_Dispatch_OnClientCallback(System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Steamworks.Dispatch.OnClientCallback( ... )
            </summary>
        </member>
        <member name="T:Steamworks.CallResult`1">
            <summary>
            An awaitable version of a SteamAPICall_t.
            </summary>
        </member>
        <member name="M:Steamworks.CallResult`1.OnCompleted(System.Action)">
            <summary>
            This gets called if IsComplete returned false on the first call.
            The Action "continues" the async call. We pass it to the Dispatch
            to be called when the callback returns.
            </summary>
        </member>
        <member name="M:Steamworks.CallResult`1.GetResult">
            <summary>
            Gets the result. This is called internally by the async shit.
            </summary>
        </member>
        <member name="P:Steamworks.CallResult`1.IsCompleted">
            <summary>
            Return true if complete or failed
            </summary>
        </member>
        <member name="M:Steamworks.CallResult`1.GetAwaiter">
            <summary>
            This is what makes this struct awaitable
            </summary>
        </member>
        <member name="T:Steamworks.ICallbackData">
            <summary>
            Gives us a generic way to get the CallbackId of structs
            </summary>
        </member>
        <member name="T:Steamworks.Dispatch">
            <summary>
            Responsible for all callback/call result handling. This manually pumps Steam's message queue
            and dispatches those events to any waiting callbacks/call results.
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.OnClientCallback(System.Int32,System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Called if an exception happens during a callback/call result. This is needed because the
            exception isn't always accessible when running async.. and can fail silently. With
            this hooked you won't be stuck wondering what happened.
            </summary>
        </member>
        <member name="F:Steamworks.Dispatch.actionsToCall">
            <summary>
            To be safe we don't call the continuation functions while iterating
            the Callback list. This is maybe overly safe because the only way this
            could be an issue is if the callback list is modified in the continuation
            which would only happen if starting or shutting down in the callback.
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.ProcessCallback(Steamworks.CallbackType,System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            A callback is a general global message.
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.CallbackToString(Steamworks.CallbackType,System.IntPtr,System.Int32)">
            <summary>
            Given a callback, try to turn it into a string
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.ProcessResult(Steamworks.CallbackType,System.IntPtr,System.Int32)">
            <summary>
            A result is a reply to a specific command
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.OnCallComplete``1(Steamworks.Data.SteamAPICall_t,System.Action,System.Boolean)">
            <summary>
            Watch for a Steam API call.
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.Install``1(System.Action{``0},System.Boolean)">
            <summary>
            Install a global callback. The passed function will get called if it's all good.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.Join">
            <summary>
            Try to join this room. Will return RoomEnter.Success on success,
            and anything else is a failure
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.Leave">
            <summary>
            Leave a lobby; this will take effect immediately on the client side
            other users in the lobby will be notified by a LobbyChatUpdate_t callback
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.InviteFriend(Steamworks.SteamId)">
            <summary>
            Invite another user to the lobby
            will return true if the invite is successfully sent, whether or not the target responds
            returns false if the local user is not connected to the Steam servers
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.InviteOverlay">
            <summary>
            Invite another user to the lobby
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.MemberCount">
            <summary>
            Get current lobby's member count
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.Members">
            <summary>
            Returns current members. Need to be in the lobby to see the users.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.GetData(System.String)">
            <summary>
            Get data associated with this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.SetData(System.String,System.String)">
            <summary>
            Get data associated with this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.DeleteData(System.String)">
            <summary>
            Removes a metadata key from the lobby
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.Data">
            <summary>
            Get all data for this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.GetMemberData(Steamworks.Friend,System.String)">
            <summary>
            Gets per-user metadata for someone in this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.SetMemberData(System.String,System.String)">
            <summary>
            Sets per-user metadata (for the local user implicitly)
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.RefreshData">
            <summary>
            Refreshes metadata for a lobby you're not necessarily in right now
            you never do this for lobbies you're a member of, only if your
            this will send down all the metadata associated with a lobby
            this is an asynchronous call
            returns false if the local user is not connected to the Steam servers
            results will be returned by a LobbyDataUpdate_t callback
            if the specified lobby doesn't exist, LobbyDataUpdate_t::m_bSuccess will be set to false
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.MaxMembers">
            <summary>
            Max members able to join this lobby. Cannot be over 250.
            Can only be set by the owner
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.Owner">
            <summary>
            You must be the lobby owner to set the owner
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.IsOwnedBy(Steamworks.SteamId)">
            <summary>
            Check if the specified SteamId owns the lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceClose">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceFar">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceWorldwide">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithKeyValue(System.String,System.String)">
            <summary>
            Filter by specified key/value pair; string parameters
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithLower(System.String,System.Int32)">
            <summary>
            Numerical filter where value is less than the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithHigher(System.String,System.Int32)">
            <summary>
            Numerical filter where value is greater than the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithEqual(System.String,System.Int32)">
            <summary>
            Numerical filter where value must be equal to the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithNotEqual(System.String,System.Int32)">
            <summary>
            Numerical filter where value must not equal the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.AddNumericalFilter(System.String,System.Int32,Steamworks.LobbyComparison)">
            <summary>
            Test key, initialize numerical filter list if necessary, then add new numerical filter
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.OrderByNear(System.String,System.Int32)">
            <summary>
            Order filtered results according to key/values nearest the provided key/value pair.
            Can specify multiple near value filters; each successive filter is lower priority than the previous.
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithSlotsAvailable(System.Int32)">
            <summary>
            returns only lobbies with the specified number of slots available
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithMaxResults(System.Int32)">
            <summary>
            sets how many results to return, the lower the count the faster it is to download the lobby results
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.RequestAsync">
            <summary>
            Run the query, get the matching lobbies
            </summary>
        </member>
        <member name="M:Steamworks.SteamClient.Init(System.Int32)">
            <summary>
            Initialize the steam client.
            </summary>
        </member>
        <member name="P:Steamworks.SteamClient.IsValid">
            <summary>
            Check if Steam is loaded and accessible.
            </summary>		
        </member>
        <member name="F:Steamworks.SteamClient.SteamId">
            <summary>
            Gets the Steam ID of the account currently logged into the Steam client. This is 
            commonly called the 'current user', or 'local user'.
            A Steam ID is a unique identifier for a Steam accounts, Steam groups, Lobbies and Chat 
            rooms, and used to differentiate users in all parts of the Steamworks API.
            </summary>
        </member>
        <member name="F:Steamworks.SteamClient.Name">
            <summary>
            returns the local players name - guaranteed to not be NULL.
            this is the same name as on the users community profile page
            </summary>
        </member>
        <member name="F:Steamworks.SteamClient.AppId">
            <summary>
            returns the appID of the current process
            </summary>
        </member>
        <member name="T:Steamworks.SteamFriends">
            <summary>
            Functions for clients to access data about Steam friends
            </summary>
        </member>
        <member name="P:Steamworks.SteamFriends.OnPersonaStateChange">
            <summary>
            Called when a friends' status changes
            </summary>
        </member>
        <member name="P:Steamworks.SteamFriends.OnGameRichPresenceJoinRequested">
            <summary>
            Called when the user tries to join a game from their friends list
            rich presence will have been set with the "connect" key which is set here
            </summary>
        </member>
        <member name="P:Steamworks.SteamFriends.OnFriendRichPresenceUpdate">
            <summary>
            Callback indicating updated data about friends rich presence information
            </summary>
        </member>
        <member name="P:Steamworks.SteamFriends.OnGameLobbyJoinRequested">
            <summary>
            Called when the user tries to join a game from their friends list
            in a lobby
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.OpenUserOverlay(Steamworks.SteamId,System.String)">
            <summary>
            "steamid" - Opens the overlay web browser to the specified user or groups profile.
            "chat" - Opens a chat window to the specified user, or joins the group chat.
            "jointrade" - Opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API.
            "stats" - Opens the overlay web browser to the specified user's stats.
            "achievements" - Opens the overlay web browser to the specified user's achievements.
            "friendadd" - Opens the overlay in minimal mode prompting the user to add the target user as a friend.
            "friendremove" - Opens the overlay in minimal mode prompting the user to remove the target friend.
            "friendrequestaccept" - Opens the overlay in minimal mode prompting the user to accept an incoming friend invite.
            "friendrequestignore" - Opens the overlay in minimal mode prompting the user to ignore an incoming friend invite.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.OpenGameInviteOverlay(Steamworks.SteamId)">
            <summary>
            Activates the Steam Overlay to open the invite dialog. Invitations sent from this dialog will be for the provided lobby.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.RequestUserInformation(Steamworks.SteamId,System.Boolean)">
            <summary>
            Requests the persona name and optionally the avatar of a specified user.
            NOTE: It's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them.
            returns true if we're fetching the data, false if we already have it
            </summary>
        </member>
        <member name="T:Steamworks.SteamMatchmaking">
            <summary>
            Functions for clients to access matchmaking services, favorites, and to operate on game lobbies
            </summary>
        </member>
        <member name="P:Steamworks.SteamMatchmaking.MaxLobbyKeyLength">
            <summary>
            Maximum number of characters a lobby metadata key can be
            </summary>
        </member>
        <member name="M:Steamworks.SteamMatchmaking.CreateLobbyAsync(System.Int32)">
            <summary>
            Creates a new invisible lobby. Call lobby.SetPublic to take it online.
            </summary>
        </member>
        <member name="M:Steamworks.SteamMatchmaking.JoinLobbyAsync(Steamworks.SteamId)">
            <summary>
            Attempts to directly join the specified lobby
            </summary>
        </member>
        <member name="T:Steamworks.SteamUtils">
            <summary>
            Interface which provides access to a range of miscellaneous utility functions
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.GetImageSize(System.Int32,System.UInt32@,System.UInt32@)">
            <summary>
            returns true if the image exists, and the buffer was successfully filled out
            results are returned in RGBA format
            the destination buffer size should be 4 * height * width * sizeof(char)
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.GetImage(System.Int32)">
            <summary>
            returns the image in RGBA format
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.IsRunningOnSteamDeck">
            <summary>
            returns true if Steam itself is running on the Steam Deck
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsMe">
            <summary>
            Returns true if this is the local user
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsFriend">
            <summary>
            Return true if this is a friend
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsBlocked">
            <summary>
            Returns true if you have this user blocked
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsPlayingThisGame">
            <summary>
            Return true if this user is playing the game we're running
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsPlaying">
            <summary>
            Return true if this user is playing another game
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsOnline">
            <summary>
            Returns true if this friend is online
            </summary>
        </member>
        <member name="M:Steamworks.Friend.RequestInfoAsync">
            <summary>
            Sometimes we don't know the user's name. This will wait until we have
            downloaded the information on this user.
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsAway">
            <summary>
            Returns true if this friend is marked as away
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsBusy">
            <summary>
            Returns true if this friend is marked as busy
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsSnoozing">
            <summary>
            Returns true if this friend is marked as snoozing
            </summary>
        </member>
        <member name="M:Steamworks.Friend.InviteToGame(System.String)">
            <summary>
            Invite this friend to the game that we are playing
            </summary>
        </member>
        <member name="M:Steamworks.Friend.OpenInOverlay(System.String)">
            <summary>
            Activates the Steam Overlay to a specific dialog
            </summary>
            <param name="type">
            "steamid" - Opens the overlay web browser to the specified user or groups profile.
            "chat" - Opens a chat window to the specified user, or joins the group chat.
            "jointrade" - Opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API.
            "stats" - Opens the overlay web browser to the specified user's stats.
            "achievements" - Opens the overlay web browser to the specified user's achievements.
            "friendadd" - Opens the overlay in minimal mode prompting the user to add the target user as a friend.
            "friendremove" - Opens the overlay in minimal mode prompting the user to remove the target friend.
            "friendrequestaccept" - Opens the overlay in minimal mode prompting the user to accept an incoming friend invite.
            "friendrequestignore" - Opens the overlay in minimal mode prompting the user to ignore an incoming friend invite.
            </param>
        </member>
        <member name="M:Steamworks.Friend.SendMessage(System.String)">
            <summary>
            Sends a message to a Steam friend. Returns true if success
            </summary>
        </member>
        <member name="M:Steamworks.Helpers.TakeBuffer(System.Int32)">
            <summary>
            Returns a buffer. This will get returned and reused later on.
            We shouldn't really be using this anymore. 
            </summary>
        </member>
        <member name="M:SandboxSystemExtensions.HasRenderMeshes(Sandbox.Model)">
            <summary>
            Returns false if model has no valid render meshes, or is null.
            </summary>
        </member>
        <member name="T:NativeResourceCache">
            <summary>
            We only want 1 instance of a Resource class in C# and we want that to have 1 strong handle to native.
            So we need a WeakReference lookup everytime we get a Resource from native to match that class.
            This way GC can work for us and free anything we're no longer using anywhere, fantastic!
            
            However sometimes GC is very good at it's job and will free Resources we don't keep a strong reference to
            in generation 0 or 1 immediately after usage. This can cause the resource to need to be loaded every frame.
            Or worse be finalized at unpredictable times.
            
            So we keep a sliding memory cache of the Resources - realistically these only need to live for an extra frame.
            But it's probably nice to keep around for longer if they're going to be used on and off.
            </summary>
        </member>
        <member name="F:NativeResourceCache.WeakTable">
            <summary>
            We still want a WeakReference cache because we might have a strong reference somewhere to a resource
            that has been expired from the cache. And we absolutely only want 1 instance of the resource.
            </summary>
        </member>
        <member name="M:NativeResourceCache.Tick">
            <summary>
            Ticks the underlying MemoryCache to clear expired entries
            </summary>
        </member>
        <member name="M:NativeResourceCache.Clear">
            <summary>
            Clear the cache when games are closed etc. ready for a <see cref="M:System.GC.Collect"/>
            </summary>
        </member>
        <member name="T:TemporaryEffect">
            <summary>
            Destroys a GameObject after a number of seconds. If the GameObject or its children have any 
            components that implement ITemporaryEffect we will wait for those to be finished before destroying.
            This is particularly useful if you want to delete a GameObject but want to wait for sounds or particles 
            to conclude.
            </summary>
        </member>
        <member name="F:TemporaryEffect.DestroyAfterSeconds">
            <summary>
            Number of seconds to wait before destroying
            </summary>
        </member>
        <member name="F:TemporaryEffect.WaitForChildEffects">
            <summary>
            If true we will wait for any ITemporaryEffect's to finish before destroying
            </summary>
        </member>
        <member name="F:TemporaryEffect.BecomeOrphan">
            <summary>
            If the parent GameObject is destroyed we should become orphaned instead of being destroyed ourselves.
            Once orphaned we'll stop all looping effects and wait to die.
            </summary>
        </member>
        <member name="M:TemporaryEffect.CreateOrphans(Sandbox.GameObject,System.Boolean)">
            <summary>
            Look at the children in this GameObject and orphan any temporary effects
            </summary>
        </member>
        <member name="P:PrefabInstanceData.Patch">
            <summary>
            Gets the cached patch representing differences between this instance and its source prefab.
            No guarantee this is up to date, except when in editor, calculating a patch is fairly expensive so we only do it when serializing or editing.
            </summary>
        </member>
        <member name="P:PrefabInstanceData.InstanceToPrefabLookup">
            <summary>
            Translate from this instances guids to prefab guids
            </summary>
        </member>
        <member name="P:PrefabInstanceData.PrefabToInstanceLookup">
            <summary>
            Translate from prefab guids to this instances guids
            </summary>
        </member>
        <member name="P:PrefabInstanceData.IsNested">
            <summary>
            A prefab instance that is nested only contains the prefab source and lookup data, no patch.
            </summary>
        </member>
        <member name="P:PrefabInstanceData.PrefabSource">
            <summary>
            The filename of the prefab this object is defined in.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.InitLookups(System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
            <summary>
            Initialize lookups for this prefab instance.
            </summary>
            <param name="prefabToInstance">Mapping from prefab GUIDs to instance GUIDs</param>
        </member>
        <member name="M:PrefabInstanceData.InitPatch(Sandbox.Json.Patch)">
            <summary>
            Initialize patch data for this prefab instance.
            </summary>
            <param name="patch">Existing patch to use</param>
        </member>
        <member name="M:PrefabInstanceData.RefreshPatch">
            <summary>
            Updates the cached patch that represents differences between this instance and its source prefab.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.ClearPatch(System.Boolean)">
            <summary>
            Clear Patch for this instance, can be used to revert back to the original state.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.IsAddedGameObject(Sandbox.GameObject)">
            <summary>
            Returns true if this GameObject has been added to a prefab instance.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.IsAddedComponent(Sandbox.Component)">
            <summary>
            Returns true if this Component has been added to a prefab instance.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.IsPropertyOverridden(System.Object,System.String,System.Boolean)">
            <summary>
            Returns true if the property of the owner was overridden by the prefab instance.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.IsModified">
            <summary>
            Returns true if the prefab instance was modified.
            1. If any property was changed on any descendant
            2. If any GameObject/Component was added
            3. If any GameObject/Component was moved
            4. If any GameObject/Component was removed
            </summary>
        </member>
        <member name="F:PrefabInstanceData._ignoredProperties">
            <summary>
            Some properties are always overridden by a prefab instance, we may want to ignore them so they don't show as modified in the UI.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.ShouldIgnoreBasicOverride(System.Guid,System.String)">
            <summary>
            Determines if a basic GameObject override should be ignored.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.IsGameObjectModified(Sandbox.GameObject,System.Boolean)">
            <summary>
            Returns true if:
            1. Any property of the GameObject or descendant has been modified
            2. If any GameObject/Component was added/removed to the GameObject
            </summary>
        </member>
        <member name="M:PrefabInstanceData.IsComponentModified(Sandbox.Component)">
            <summary>
            Returns true if any property of the component was changed on the instance.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.RevertPropertyChange(System.Object,System.String)">
            <summary>
            Reverts the properties value back to the prefab's value.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.UpdateComponentFromPrefab(Sandbox.Component)">
            <summary>
            Helper function used when Discarding/Reverting.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.RevertComponentChanges(Sandbox.Component)">
            <summary>
            Reverts all the components properties back to the prefab's value.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.UpdateGameObjectFromPrefab(Sandbox.GameObject,System.Boolean)">
            <summary>
            Helper function used when Discarding/Reverting.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.RevertGameObjectChanges(Sandbox.GameObject)">
            <summary>
            Reverts all the changes made to the GameObject and descendants (Additions, Removals, PropertyOverrides) back to the prefab's value.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.ApplyPropertyChangeToPrefab(System.Object,System.String)">
            <summary>
            Applies the changes made to the property back to the prefab.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.ApplyComponentChangesToPrefab(Sandbox.Component)">
            <summary>
            Applies the changes made to the component back to the prefab.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.PrepareInstanceJsonForPrefabUpdate(Sandbox.GameObject)">
            <summary>
            Prepares instance JSON data for application to a prefab by updating GUID mappings 
            and translating instance GUIDs to their prefab equivalents.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.ApplyGameObjectChangesToPrefab(Sandbox.GameObject)">
            <summary>
            Applies the changes made to the GameObject and descendants back to the prefab.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.OverridePrefabWithInstance">
            <summary>
            Overrides the prefab definition with the current instance state, making the instance match the prefab exactly.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.UpdateLookups(System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
            <summary>
            Creates the bidirectional GUID lookups from the provided mapping.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.RemapTransformPropertyName(System.String)">
            <summary>
            We don't serialize the GameTransform, we always serialize Position, Rotation and Scale.
            So we always need to use those keys, when handling GameTransform properties.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.RemapGuids(System.Text.Json.Nodes.JsonNode,System.Collections.Generic.Dictionary{System.Guid,System.Guid},System.Boolean)">
            <summary>
            Remap all guids in the json to the new guids in the remap table.
            </summary>
            <param name="node">Node that will be modified.</param>
            <param name="remapTable">The table to use for guid translation.</param>
            <param name="remapAddedPrefabInstances">If true, will also remap objects that have their own mapping (added prefab instances).</param>
        </member>
        <member name="M:PrefabInstanceData.ValidatePrefabToInstanceIdLookup(System.Collections.Generic.Dictionary{System.Guid,System.Guid},System.String)">
            <summary>
            Ensures the prefab-to-instance GUID mapping is valid by adding missing entries and removing obsolete ones.
            </summary>
            <param name="oldPrefabToInstanceLookup">The existing GUID mapping to validate</param>
            <param name="prefabSource">The source path of the prefab file</param>
            <returns>A validated mapping containing only relevant GUIDs with appropriate instance IDs</returns>
        </member>
        <member name="M:PrefabInstanceData.GetRequiredPrefabGuids(Sandbox.PrefabCacheScene)">
            <summary>
            Gets all required GUIDs from a prefab scene.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.AddNewObjectsToInstanceToPrefabLookup(Sandbox.GameObject,System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
            <summary>
            Adds new GUID mappings to the instance lookup based on the required GUIDs from the given prefab instance root.
            </summary>
        </member>
        <member name="M:PrefabInstanceData.GetRequiredInstanceGuids(Sandbox.GameObject)">
            <summary>
            Gets all GUIDs contained inside a go hierarchy
            </summary>
        </member>
        <member name="T:SceneObjectAnimationSequence">
            <summary>
            Hidden class. addon code should only ever access AnimationSequence.
            </summary>
        </member>
        <member name="T:SceneObjectDirectPlayback">
            <summary>
            Hidden class. addon code should only ever access DirectPlayback.
            </summary>
        </member>
        <member name="T:SceneObjectMorphCollection">
            <summary>
            Hidden class. addon code should only ever access MorphCollection.
            </summary>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.RenderFragment">
            <summary>
            Represents a segment of UI content, implemented as a delegate that
            writes the content to a <see cref="T:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder"/>.
            </summary>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.RenderFragment`1">
            <summary>
            Represents a segment of UI content for an object of type <typeparamref name="TValue"/>, implemented as
            a function that returns a <see cref="T:Microsoft.AspNetCore.Components.RenderFragment"/>.
            </summary>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.IComponent">
            <summary>
            A component type
            </summary>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.ParameterAttribute">
            <summary>
            Signifies a parameter attribute
            </summary>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.ComponentBase">
            <summary>
            A base component
            </summary>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder">
            <summary>
            This is a tree renderer for panels. If we ever use razor on other ui we'll want to make a copy of
            this class and do the specific things to that.
            </summary>
            <summary>
            This is a tree renderer for panels. If we ever use razor on other ui we'll want to make a copy of
            this class and do the specific things to that.
            </summary>
            <summary>
            This is a tree renderer for panels. If we ever use razor on other ui we'll want to make a copy of 
            this class and do the specific things to that.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Block.Reset">
            <summary>
            Reset to an unseen, unlooped state
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Block.CheckCacheValue(System.Int32,System.Int32)">
            <summary>
            Allows caching a block so you can avoid repeating unnecessary steps. 
            Calling this will return true if it's already cached, false if it's not.
            If it's not it'll add to the cache so that next time it will return true.
            </summary>
        </member>
        <member name="F:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Block.increments">
            <summary>
            For loops, how many times has this been seen
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Start">
            <summary>
            Called once before building the tree
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Finish">
            <summary>
            Called once after building the tree
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddLocation(System.String,System.Int32,System.Int32)">
            <summary>
            Add the current source location. Used to record in which file the element was created.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.OpenElement(System.Int32,System.String,System.Object)">
            <summary>
            Start working on this element
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Object)">
            <summary>
            Handles "style" and "class" attributes..
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddStyleDefinitions(System.Int32,System.String)">
            <summary>
            Styles from a style block
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute``1(System.Int32,System.Action{``0})">
            <summary>
             <![CDATA[ <Icon OnSomething=@Function></Icon> ]]>
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.CloseElement">
            <summary>
            Finish working on this element
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddContent``1(System.Int32,``0)">
            <summary>
            Handles text content within an element
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Clear">
            <summary>
            Delete all of the elements created by this render tree
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddReferenceCapture``1(System.Int32,``0,System.Action{``0})">
            <summary>
            Implements @ref
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Action)">
            <summary>
            Handles @onclick=@( () => DoSomething( "boobies" ) )
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Handles @onclick=@( () => await DoSomethingAsync( "boobies" ) )
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Action{Sandbox.UI.PanelEvent})">
            <summary>
            Handles @onclick=@( ( PanelEvent e ) => DoSomething( e.This, "boobies" ) )
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddMarkupContent(System.Int32,System.String)">
            <summary>
            Add markup to the current element
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.OpenElement``1(System.Int32,System.Object)">
            <summary>
            Create a panel of type T
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute``1(System.Int32,System.Object,System.Action{``0})">
            <summary>
            Called to set attributes on a panel directly
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddBind``1(System.Int32,System.String,System.Func{``0},System.Action{``0})">
            <summary>
            Called to set attributes on a panel directly
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.UpdateBinds">
            <summary>
            Update bound variables and return true if any of them changed
            </summary>
        </member>
        <member name="P:Microsoft.AspNetCore.Components.EventHandlerAttribute.AttributeName">
            <summary>
            Gets the attribute name.
            </summary>
        </member>
        <member name="P:Microsoft.AspNetCore.Components.EventHandlerAttribute.EventArgsType">
            <summary>
            Gets the event argument type.
            </summary>
        </member>
        <member name="P:Microsoft.AspNetCore.Components.EventHandlerAttribute.EnableStopPropagation">
            <summary>
            Gets the event's ability to stop propagation.
            </summary>
        </member>
        <member name="P:Microsoft.AspNetCore.Components.EventHandlerAttribute.EnablePreventDefault">
            <summary>
            Gets the event's ability to prevent default event flow.
            </summary>
        </member>
        <member name="T:Microsoft.AspNetCore.Components.EditorRequiredAttribute">
            <summary>
            Specifies that the component parameter is required to be provided by the user when authoring it in the editor.
            <para>
            If a value for this parameter is not provided, editors or build tools may provide warnings indicating the user to
            specify a value. This attribute is only valid on properties marked with <see cref="T:Microsoft.AspNetCore.Components.ParameterAttribute"/>.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.AspNetCore.Components.RouteAttribute.Url">
            <summary>
            The full url of this route (ie "/home/section/page")
            </summary>
        </member>
        <member name="P:Microsoft.AspNetCore.Components.RouteAttribute.Parts">
            <summary>
            The url split into parts (ie "home" "section" "page" )
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.RouteAttribute.FindValidTarget(System.String,System.String)">
            <summary>
            Given a URL, check out TypeLibrary and find a valid target
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.RouteAttribute.IsUrl(System.String)">
            <summary>
            True if this matches the passed in url.
            Queries are trimmed and ignored <c>( ?query=fff )</c>
            Variables are tested (but not type matched or anything)
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Components.RouteAttribute.ExtractProperties(System.String)">
            <summary>
            Given a Url, check for {properties} and convert them to key values
            </summary>
        </member>
    </members>
</doc>
